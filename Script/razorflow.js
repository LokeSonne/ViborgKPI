(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.Bar = factory();
    }
}(this, function () {/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("buildutils/almond", function(){});

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
 * Build: `lodash exports="amd"`
 */
;(function(){function n(n,t,r){r=(r||0)-1;for(var e=n?n.length:0;++r<e;)if(n[r]===t)return r;return-1}function t(t,r){var e=typeof r;if(t=t.l,"boolean"==e||null==r)return t[r]?0:-1;"number"!=e&&"string"!=e&&(e="object");var u="number"==e?r:d+r;return t=(t=t[e])&&t[u],"object"==e?t&&-1<n(t,r)?0:-1:t?0:-1}function r(n){var t=this.l,r=typeof n;if("boolean"==r||null==n)t[n]=true;else{"number"!=r&&"string"!=r&&(r="object");var e="number"==r?n:d+n,t=t[r]||(t[r]={});"object"==r?(t[e]||(t[e]=[])).push(n):t[e]=true
}}function e(n){return n.charCodeAt(0)}function u(n,t){for(var r=n.m,e=t.m,u=-1,o=r.length;++u<o;){var a=r[u],i=e[u];if(a!==i){if(a>i||typeof a=="undefined")return 1;if(a<i||typeof i=="undefined")return-1}}return n.n-t.n}function o(n){var t=-1,e=n.length,u=n[0],o=n[e/2|0],a=n[e-1];if(u&&typeof u=="object"&&o&&typeof o=="object"&&a&&typeof a=="object")return false;for(u=l(),u["false"]=u["null"]=u["true"]=u.undefined=false,o=l(),o.k=n,o.l=u,o.push=r;++t<e;)o.push(n[t]);return o}function a(n){return"\\"+Y[n]
}function i(){return v.pop()||[]}function l(){return y.pop()||{k:null,l:null,m:null,"false":false,n:0,"null":false,number:null,object:null,push:null,string:null,"true":false,undefined:false,o:null}}function f(n){return typeof n.toString!="function"&&typeof(n+"")=="string"}function c(n){n.length=0,v.length<w&&v.push(n)}function p(n){var t=n.l;t&&p(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,y.length<w&&y.push(n)}function s(n,t,r){t||(t=0),typeof r=="undefined"&&(r=n?n.length:0);var e=-1;r=r-t||0;for(var u=Array(0>r?0:r);++e<r;)u[e]=n[t+e];
return u}function g(r){function v(n){return n&&typeof n=="object"&&!qr(n)&&wr.call(n,"__wrapped__")?n:new y(n)}function y(n,t){this.__chain__=!!t,this.__wrapped__=n}function w(n){function t(){if(e){var n=s(e);jr.apply(n,arguments)}if(this instanceof t){var o=nt(r.prototype),n=r.apply(o,n||arguments);return Ct(n)?n:o}return r.apply(u,n||arguments)}var r=n[0],e=n[2],u=n[4];return Tr(t,n),t}function Y(n,t,r,e,u){if(r){var o=r(n);if(typeof o!="undefined")return o}if(!Ct(n))return n;var a=hr.call(n);if(!V[a]||!zr.nodeClass&&f(n))return n;
var l=$r[a];switch(a){case z:case T:return new l(+n);case W:case M:return new l(n);case J:return o=l(n.source,S.exec(n)),o.lastIndex=n.lastIndex,o}if(a=qr(n),t){var p=!e;e||(e=i()),u||(u=i());for(var g=e.length;g--;)if(e[g]==n)return u[g];o=a?l(n.length):{}}else o=a?s(n):Yr({},n);return a&&(wr.call(n,"index")&&(o.index=n.index),wr.call(n,"input")&&(o.input=n.input)),t?(e.push(n),u.push(o),(a?Xr:te)(n,function(n,a){o[a]=Y(n,t,r,e,u)}),p&&(c(e),c(u)),o):o}function nt(n){return Ct(n)?Sr(n):{}}function rt(n,t,r){if(typeof n!="function")return Ht;
if(typeof t=="undefined"||!("prototype"in n))return n;var e=n.__bindData__;if(typeof e=="undefined"&&(zr.funcNames&&(e=!n.name),e=e||!zr.funcDecomp,!e)){var u=dr.call(n);zr.funcNames||(e=!A.test(u)),e||(e=B.test(u),Tr(n,e))}if(false===e||true!==e&&1&e[1])return n;switch(r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,o){return n.call(t,r,e,u,o)}}return Mt(n,t)}function et(n){function t(){var n=l?a:this;
if(u){var h=s(u);jr.apply(h,arguments)}return(o||c)&&(h||(h=s(arguments)),o&&jr.apply(h,o),c&&h.length<i)?(e|=16,et([r,p?e:-4&e,h,null,a,i])):(h||(h=arguments),f&&(r=n[g]),this instanceof t?(n=nt(r.prototype),h=r.apply(n,h),Ct(h)?h:n):r.apply(n,h))}var r=n[0],e=n[1],u=n[2],o=n[3],a=n[4],i=n[5],l=1&e,f=2&e,c=4&e,p=8&e,g=r;return Tr(t,n),t}function ut(r,e){var u=-1,a=ht(),i=r?r.length:0,l=i>=_&&a===n,f=[];if(l){var c=o(e);c?(a=t,e=c):l=false}for(;++u<i;)c=r[u],0>a(e,c)&&f.push(c);return l&&p(e),f}function ot(n,t,r,e){e=(e||0)-1;
for(var u=n?n.length:0,o=[];++e<u;){var a=n[e];if(a&&typeof a=="object"&&typeof a.length=="number"&&(qr(a)||bt(a))){t||(a=ot(a,t,r));var i=-1,l=a.length,f=o.length;for(o.length+=l;++i<l;)o[f++]=a[i]}else r||o.push(a)}return o}function at(n,t,r,e,u,o){if(r){var a=r(n,t);if(typeof a!="undefined")return!!a}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&X[typeof n]||t&&X[typeof t]))return false;if(null==n||null==t)return n===t;var l=hr.call(n),p=hr.call(t);if(l==$&&(l=G),p==$&&(p=G),l!=p)return false;switch(l){case z:case T:return+n==+t;
case W:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case J:case M:return n==ir(t)}if(p=l==L,!p){var s=wr.call(n,"__wrapped__"),g=wr.call(t,"__wrapped__");if(s||g)return at(s?n.__wrapped__:n,g?t.__wrapped__:t,r,e,u,o);if(l!=G||!zr.nodeClass&&(f(n)||f(t)))return false;if(l=!zr.argsObject&&bt(n)?or:n.constructor,s=!zr.argsObject&&bt(t)?or:t.constructor,l!=s&&!(jt(l)&&l instanceof l&&jt(s)&&s instanceof s)&&"constructor"in n&&"constructor"in t)return false}for(l=!u,u||(u=i()),o||(o=i()),s=u.length;s--;)if(u[s]==n)return o[s]==t;
var h=0,a=true;if(u.push(n),o.push(t),p){if(s=n.length,h=t.length,(a=h==s)||e)for(;h--;)if(p=s,g=t[h],e)for(;p--&&!(a=at(n[p],g,r,e,u,o)););else if(!(a=at(n[h],g,r,e,u,o)))break}else ne(t,function(t,i,l){return wr.call(l,i)?(h++,a=wr.call(n,i)&&at(n[i],t,r,e,u,o)):void 0}),a&&!e&&ne(n,function(n,t,r){return wr.call(r,t)?a=-1<--h:void 0});return u.pop(),o.pop(),l&&(c(u),c(o)),a}function it(n,t,r,e,u){(qr(t)?Dt:te)(t,function(t,o){var a,i,l=t,f=n[o];if(t&&((i=qr(t))||re(t))){for(l=e.length;l--;)if(a=e[l]==t){f=u[l];
break}if(!a){var c;r&&(l=r(f,t),c=typeof l!="undefined")&&(f=l),c||(f=i?qr(f)?f:[]:re(f)?f:{}),e.push(t),u.push(f),c||it(f,t,r,e,u)}}else r&&(l=r(f,t),typeof l=="undefined"&&(l=t)),typeof l!="undefined"&&(f=l);n[o]=f})}function lt(n,t){return n+br(Fr()*(t-n+1))}function ft(r,e,u){var a=-1,l=ht(),f=r?r.length:0,s=[],g=!e&&f>=_&&l===n,h=u||g?i():s;for(g&&(h=o(h),l=t);++a<f;){var v=r[a],y=u?u(v,a,r):v;(e?!a||h[h.length-1]!==y:0>l(h,y))&&((u||g)&&h.push(y),s.push(v))}return g?(c(h.k),p(h)):u&&c(h),s}function ct(n){return function(t,r,e){var u={};
if(r=v.createCallback(r,e,3),qr(t)){e=-1;for(var o=t.length;++e<o;){var a=t[e];n(u,a,r(a,e,t),t)}}else Xr(t,function(t,e,o){n(u,t,r(t,e,o),o)});return u}}function pt(n,t,r,e,u,o){var a=1&t,i=4&t,l=16&t,f=32&t;if(!(2&t||jt(n)))throw new lr;l&&!r.length&&(t&=-17,l=r=false),f&&!e.length&&(t&=-33,f=e=false);var c=n&&n.__bindData__;return c&&true!==c?(c=s(c),c[2]&&(c[2]=s(c[2])),c[3]&&(c[3]=s(c[3])),!a||1&c[1]||(c[4]=u),!a&&1&c[1]&&(t|=8),!i||4&c[1]||(c[5]=o),l&&jr.apply(c[2]||(c[2]=[]),r),f&&Er.apply(c[3]||(c[3]=[]),e),c[1]|=t,pt.apply(null,c)):(1==t||17===t?w:et)([n,t,r,e,u,o])
}function st(){Q.h=F,Q.b=Q.c=Q.g=Q.i="",Q.e="t",Q.j=true;for(var n,t=0;n=arguments[t];t++)for(var r in n)Q[r]=n[r];t=Q.a,Q.d=/^[^,]+/.exec(t)[0],n=rr,t="return function("+t+"){",r=Q;var e="var n,t="+r.d+",E="+r.e+";if(!t)return E;"+r.i+";";r.b?(e+="var u=t.length;n=-1;if("+r.b+"){",zr.unindexedChars&&(e+="if(s(t)){t=t.split('')}"),e+="while(++n<u){"+r.g+";}}else{"):zr.nonEnumArgs&&(e+="var u=t.length;n=-1;if(u&&p(t)){while(++n<u){n+='';"+r.g+";}}else{"),zr.enumPrototypes&&(e+="var G=typeof t=='function';"),zr.enumErrorProps&&(e+="var F=t===k||t instanceof Error;");
var u=[];if(zr.enumPrototypes&&u.push('!(G&&n=="prototype")'),zr.enumErrorProps&&u.push('!(F&&(n=="message"||n=="name"))'),r.j&&r.f)e+="var C=-1,D=B[typeof t]&&v(t),u=D?D.length:0;while(++C<u){n=D[C];",u.length&&(e+="if("+u.join("&&")+"){"),e+=r.g+";",u.length&&(e+="}"),e+="}";else if(e+="for(n in t){",r.j&&u.push("m.call(t, n)"),u.length&&(e+="if("+u.join("&&")+"){"),e+=r.g+";",u.length&&(e+="}"),e+="}",zr.nonEnumShadows){for(e+="if(t!==A){var i=t.constructor,r=t===(i&&i.prototype),f=t===J?I:t===k?j:L.call(t),x=y[f];",k=0;7>k;k++)e+="n='"+r.h[k]+"';if((!(r&&x[n])&&m.call(t,n))",r.j||(e+="||(!x[n]&&t[n]!==A[n])"),e+="){"+r.g+"}";
e+="}"}return(r.b||zr.nonEnumArgs)&&(e+="}"),e+=r.c+";return E",n("d,j,k,m,o,p,q,s,v,A,B,y,I,J,L",t+e+"}")(rt,q,cr,wr,b,bt,qr,xt,Q.f,pr,X,Lr,M,sr,hr)}function gt(n){return Vr[n]}function ht(){var t=(t=v.indexOf)===Tt?n:t;return t}function vt(n){return typeof n=="function"&&vr.test(n)}function yt(n){var t,r;return!n||hr.call(n)!=G||(t=n.constructor,jt(t)&&!(t instanceof t))||!zr.argsClass&&bt(n)||!zr.nodeClass&&f(n)?false:zr.ownLast?(ne(n,function(n,t,e){return r=wr.call(e,t),false}),false!==r):(ne(n,function(n,t){r=t
}),typeof r=="undefined"||wr.call(n,r))}function mt(n){return Hr[n]}function bt(n){return n&&typeof n=="object"&&typeof n.length=="number"&&hr.call(n)==$||false}function dt(n,t,r){var e=Wr(n),u=e.length;for(t=rt(t,r,3);u--&&(r=e[u],false!==t(n[r],r,n)););return n}function _t(n){var t=[];return ne(n,function(n,r){jt(n)&&t.push(r)}),t.sort()}function wt(n){for(var t=-1,r=Wr(n),e=r.length,u={};++t<e;){var o=r[t];u[n[o]]=o}return u}function jt(n){return typeof n=="function"}function Ct(n){return!(!n||!X[typeof n])
}function kt(n){return typeof n=="number"||n&&typeof n=="object"&&hr.call(n)==W||false}function xt(n){return typeof n=="string"||n&&typeof n=="object"&&hr.call(n)==M||false}function Et(n){for(var t=-1,r=Wr(n),e=r.length,u=Zt(e);++t<e;)u[t]=n[r[t]];return u}function Ot(n,t,r){var e=-1,u=ht(),o=n?n.length:0,a=false;return r=(0>r?Br(0,o+r):r)||0,qr(n)?a=-1<u(n,t,r):typeof o=="number"?a=-1<(xt(n)?n.indexOf(t,r):u(n,t,r)):Xr(n,function(n){return++e<r?void 0:!(a=n===t)}),a}function St(n,t,r){var e=true;if(t=v.createCallback(t,r,3),qr(n)){r=-1;
for(var u=n.length;++r<u&&(e=!!t(n[r],r,n)););}else Xr(n,function(n,r,u){return e=!!t(n,r,u)});return e}function At(n,t,r){var e=[];if(t=v.createCallback(t,r,3),qr(n)){r=-1;for(var u=n.length;++r<u;){var o=n[r];t(o,r,n)&&e.push(o)}}else Xr(n,function(n,r,u){t(n,r,u)&&e.push(n)});return e}function It(n,t,r){if(t=v.createCallback(t,r,3),!qr(n)){var e;return Xr(n,function(n,r,u){return t(n,r,u)?(e=n,false):void 0}),e}r=-1;for(var u=n.length;++r<u;){var o=n[r];if(t(o,r,n))return o}}function Dt(n,t,r){if(t&&typeof r=="undefined"&&qr(n)){r=-1;
for(var e=n.length;++r<e&&false!==t(n[r],r,n););}else Xr(n,t,r);return n}function Nt(n,t,r){var e=n,u=n?n.length:0;if(t=t&&typeof r=="undefined"?t:rt(t,r,3),qr(n))for(;u--&&false!==t(n[u],u,n););else{if(typeof u!="number")var o=Wr(n),u=o.length;else zr.unindexedChars&&xt(n)&&(e=n.split(""));Xr(n,function(n,r,a){return r=o?o[--u]:--u,t(e[r],r,a)})}return n}function Bt(n,t,r){var e=-1,u=n?n.length:0,o=Zt(typeof u=="number"?u:0);if(t=v.createCallback(t,r,3),qr(n))for(;++e<u;)o[e]=t(n[e],e,n);else Xr(n,function(n,r,u){o[++e]=t(n,r,u)
});return o}function Pt(n,t,r){var u=-1/0,o=u;if(typeof t!="function"&&r&&r[t]===n&&(t=null),null==t&&qr(n)){r=-1;for(var a=n.length;++r<a;){var i=n[r];i>o&&(o=i)}}else t=null==t&&xt(n)?e:v.createCallback(t,r,3),Xr(n,function(n,r,e){r=t(n,r,e),r>u&&(u=r,o=n)});return o}function Rt(n,t,r,e){var u=3>arguments.length;if(t=v.createCallback(t,e,4),qr(n)){var o=-1,a=n.length;for(u&&(r=n[++o]);++o<a;)r=t(r,n[o],o,n)}else Xr(n,function(n,e,o){r=u?(u=false,n):t(r,n,e,o)});return r}function Ft(n,t,r,e){var u=3>arguments.length;
return t=v.createCallback(t,e,4),Nt(n,function(n,e,o){r=u?(u=false,n):t(r,n,e,o)}),r}function $t(n){var t=-1,r=n?n.length:0,e=Zt(typeof r=="number"?r:0);return Dt(n,function(n){var r=lt(0,++t);e[t]=e[r],e[r]=n}),e}function Lt(n,t,r){var e;if(t=v.createCallback(t,r,3),qr(n)){r=-1;for(var u=n.length;++r<u&&!(e=t(n[r],r,n)););}else Xr(n,function(n,r,u){return!(e=t(n,r,u))});return!!e}function zt(n,t,r){var e=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=-1;for(t=v.createCallback(t,r,3);++o<u&&t(n[o],o,n);)e++
}else if(e=t,null==e||r)return n?n[0]:h;return s(n,0,Pr(Br(0,e),u))}function Tt(t,r,e){if(typeof e=="number"){var u=t?t.length:0;e=0>e?Br(0,u+e):e||0}else if(e)return e=Kt(t,r),t[e]===r?e:-1;return n(t,r,e)}function qt(n,t,r){if(typeof t!="number"&&null!=t){var e=0,u=-1,o=n?n.length:0;for(t=v.createCallback(t,r,3);++u<o&&t(n[u],u,n);)e++}else e=null==t||r?1:Br(0,t);return s(n,e)}function Kt(n,t,r,e){var u=0,o=n?n.length:u;for(r=r?v.createCallback(r,e,1):Ht,t=r(t);u<o;)e=u+o>>>1,r(n[e])<t?u=e+1:o=e;
return u}function Wt(n,t,r,e){return typeof t!="boolean"&&null!=t&&(e=r,r=typeof t!="function"&&e&&e[t]===n?null:t,t=false),null!=r&&(r=v.createCallback(r,e,3)),ft(n,t,r)}function Gt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,r=n?Pt(ae(n,"length")):0,e=Zt(0>r?0:r);++t<r;)e[t]=ae(n,t);return e}function Jt(n,t){var r=-1,e=n?n.length:0,u={};for(t||!e||qr(n[0])||(t=[]);++r<e;){var o=n[r];t?u[o]=t[r]:o&&(u[o[0]]=o[1])}return u}function Mt(n,t){return 2<arguments.length?pt(n,17,s(arguments,2),null,t):pt(n,1,null,null,t)
}function Vt(n,t,r){var e,u,o,a,i,l,f,c=0,p=false,s=true;if(!jt(n))throw new lr;if(t=Br(0,t)||0,true===r)var g=true,s=false;else Ct(r)&&(g=r.leading,p="maxWait"in r&&(Br(t,r.maxWait)||0),s="trailing"in r?r.trailing:s);var v=function(){var r=t-(ie()-a);0<r?l=kr(v,r):(u&&mr(u),r=f,u=l=f=h,r&&(c=ie(),o=n.apply(i,e),l||u||(e=i=null)))},y=function(){l&&mr(l),u=l=f=h,(s||p!==t)&&(c=ie(),o=n.apply(i,e),l||u||(e=i=null))};return function(){if(e=arguments,a=ie(),i=this,f=s&&(l||!g),false===p)var r=g&&!l;else{u||g||(c=a);
var h=p-(a-c),m=0>=h;m?(u&&(u=mr(u)),c=a,o=n.apply(i,e)):u||(u=kr(y,h))}return m&&l?l=mr(l):l||t===p||(l=kr(v,t)),r&&(m=true,o=n.apply(i,e)),!m||l||u||(e=i=null),o}}function Ht(n){return n}function Ut(n,t,r){var e=true,u=t&&_t(t);t&&(r||u.length)||(null==r&&(r=t),o=y,t=n,n=v,u=_t(t)),false===r?e=false:Ct(r)&&"chain"in r&&(e=r.chain);var o=n,a=jt(o);Dt(u,function(r){var u=n[r]=t[r];a&&(o.prototype[r]=function(){var t=this.__chain__,r=this.__wrapped__,a=[r];if(jr.apply(a,arguments),a=u.apply(n,a),e||t){if(r===a&&Ct(a))return this;
a=new o(a),a.__chain__=t}return a})})}function Qt(){}function Xt(n){return function(t){return t[n]}}function Yt(){return this.__wrapped__}r=r?tt.defaults(Z.Object(),r,tt.pick(Z,R)):Z;var Zt=r.Array,nr=r.Boolean,tr=r.Date,rr=r.Function,er=r.Math,ur=r.Number,or=r.Object,ar=r.RegExp,ir=r.String,lr=r.TypeError,fr=[],cr=r.Error.prototype,pr=or.prototype,sr=ir.prototype,gr=r._,hr=pr.toString,vr=ar("^"+ir(hr).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),yr=er.ceil,mr=r.clearTimeout,br=er.floor,dr=rr.prototype.toString,_r=vt(_r=or.getPrototypeOf)&&_r,wr=pr.hasOwnProperty,jr=fr.push,Cr=pr.propertyIsEnumerable,kr=r.setTimeout,xr=fr.splice,Er=fr.unshift,Or=function(){try{var n={},t=vt(t=or.defineProperty)&&t,r=t(n,n,n)&&t
}catch(e){}return r}(),Sr=vt(Sr=or.create)&&Sr,Ar=vt(Ar=Zt.isArray)&&Ar,Ir=r.isFinite,Dr=r.isNaN,Nr=vt(Nr=or.keys)&&Nr,Br=er.max,Pr=er.min,Rr=r.parseInt,Fr=er.random,$r={};$r[L]=Zt,$r[z]=nr,$r[T]=tr,$r[K]=rr,$r[G]=or,$r[W]=ur,$r[J]=ar,$r[M]=ir;var Lr={};Lr[L]=Lr[T]=Lr[W]={constructor:true,toLocaleString:true,toString:true,valueOf:true},Lr[z]=Lr[M]={constructor:true,toString:true,valueOf:true},Lr[q]=Lr[K]=Lr[J]={constructor:true,toString:true},Lr[G]={constructor:true},function(){for(var n=F.length;n--;){var t,r=F[n];
for(t in Lr)wr.call(Lr,t)&&!wr.call(Lr[t],r)&&(Lr[t][r]=false)}}(),y.prototype=v.prototype;var zr=v.support={};!function(){var n=function(){this.x=1},t={0:1,length:1},e=[];n.prototype={valueOf:1,y:1};for(var u in new n)e.push(u);for(u in arguments);zr.argsClass=hr.call(arguments)==$,zr.argsObject=arguments.constructor==or&&!(arguments instanceof Zt),zr.enumErrorProps=Cr.call(cr,"message")||Cr.call(cr,"name"),zr.enumPrototypes=Cr.call(n,"prototype"),zr.funcDecomp=!vt(r.WinRTError)&&B.test(g),zr.funcNames=typeof rr.name=="string",zr.nonEnumArgs=0!=u,zr.nonEnumShadows=!/valueOf/.test(e),zr.ownLast="x"!=e[0],zr.spliceObjects=(fr.splice.call(t,0,1),!t[0]),zr.unindexedChars="xx"!="x"[0]+or("x")[0];
try{zr.nodeClass=!(hr.call(document)==G&&!({toString:0}+""))}catch(o){zr.nodeClass=true}}(1),v.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:I,variable:"",imports:{_:v}},Sr||(nt=function(){function n(){}return function(t){if(Ct(t)){n.prototype=t;var e=new n;n.prototype=null}return e||r.Object()}}());var Tr=Or?function(n,t){U.value=t,Or(n,"__bindData__",U)}:Qt;zr.argsClass||(bt=function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&wr.call(n,"callee")&&!Cr.call(n,"callee")||false
});var qr=Ar||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&hr.call(n)==L||false},Kr=st({a:"z",e:"[]",i:"if(!(B[typeof z]))return E",g:"E.push(n)"}),Wr=Nr?function(n){return Ct(n)?zr.enumPrototypes&&typeof n=="function"||zr.nonEnumArgs&&n.length&&bt(n)?Kr(n):Nr(n):[]}:Kr,Gr={a:"g,e,K",i:"e=e&&typeof K=='undefined'?e:d(e,K,3)",b:"typeof u=='number'",v:Wr,g:"if(e(t[n],n,g)===false)return E"},Jr={a:"z,H,l",i:"var a=arguments,b=0,c=typeof l=='number'?2:a.length;while(++b<c){t=a[b];if(t&&B[typeof t]){",v:Wr,g:"if(typeof E[n]=='undefined')E[n]=t[n]",c:"}}"},Mr={i:"if(!B[typeof t])return E;"+Gr.i,b:false},Vr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Hr=wt(Vr),Ur=ar("("+Wr(Hr).join("|")+")","g"),Qr=ar("["+Wr(Vr).join("")+"]","g"),Xr=st(Gr),Yr=st(Jr,{i:Jr.i.replace(";",";if(c>3&&typeof a[c-2]=='function'){var e=d(a[--c-1],a[c--],2)}else if(c>2&&typeof a[c-1]=='function'){e=a[--c]}"),g:"E[n]=e?e(E[n],t[n]):t[n]"}),Zr=st(Jr),ne=st(Gr,Mr,{j:false}),te=st(Gr,Mr);
jt(/x/)&&(jt=function(n){return typeof n=="function"&&hr.call(n)==K});var re=_r?function(n){if(!n||hr.call(n)!=G||!zr.argsClass&&bt(n))return false;var t=n.valueOf,r=vt(t)&&(r=_r(t))&&_r(r);return r?n==r||_r(n)==r:yt(n)}:yt,ee=ct(function(n,t,r){wr.call(n,r)?n[r]++:n[r]=1}),ue=ct(function(n,t,r){(wr.call(n,r)?n[r]:n[r]=[]).push(t)}),oe=ct(function(n,t,r){n[r]=t}),ae=Bt,ie=vt(ie=tr.now)&&ie||function(){return(new tr).getTime()},le=8==Rr(j+"08")?Rr:function(n,t){return Rr(xt(n)?n.replace(D,""):n,t||0)};
return v.after=function(n,t){if(!jt(t))throw new lr;return function(){return 1>--n?t.apply(this,arguments):void 0}},v.assign=Yr,v.at=function(n){var t=arguments,r=-1,e=ot(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:e.length,u=Zt(t);for(zr.unindexedChars&&xt(n)&&(n=n.split(""));++r<t;)u[r]=n[e[r]];return u},v.bind=Mt,v.bindAll=function(n){for(var t=1<arguments.length?ot(arguments,true,false,1):_t(n),r=-1,e=t.length;++r<e;){var u=t[r];n[u]=pt(n[u],1,null,null,n)}return n},v.bindKey=function(n,t){return 2<arguments.length?pt(t,19,s(arguments,2),null,n):pt(t,3,null,null,n)
},v.chain=function(n){return n=new y(n),n.__chain__=true,n},v.compact=function(n){for(var t=-1,r=n?n.length:0,e=[];++t<r;){var u=n[t];u&&e.push(u)}return e},v.compose=function(){for(var n=arguments,t=n.length;t--;)if(!jt(n[t]))throw new lr;return function(){for(var t=arguments,r=n.length;r--;)t=[n[r].apply(this,t)];return t[0]}},v.constant=function(n){return function(){return n}},v.countBy=ee,v.create=function(n,t){var r=nt(n);return t?Yr(r,t):r},v.createCallback=function(n,t,r){var e=typeof n;if(null==n||"function"==e)return rt(n,t,r);
if("object"!=e)return Xt(n);var u=Wr(n),o=u[0],a=n[o];return 1!=u.length||a!==a||Ct(a)?function(t){for(var r=u.length,e=false;r--&&(e=at(t[u[r]],n[u[r]],null,true)););return e}:function(n){return n=n[o],a===n&&(0!==a||1/a==1/n)}},v.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,pt(n,4,null,null,null,t)},v.debounce=Vt,v.defaults=Zr,v.defer=function(n){if(!jt(n))throw new lr;var t=s(arguments,1);return kr(function(){n.apply(h,t)},1)},v.delay=function(n,t){if(!jt(n))throw new lr;var r=s(arguments,2);
return kr(function(){n.apply(h,r)},t)},v.difference=function(n){return ut(n,ot(arguments,true,true,1))},v.filter=At,v.flatten=function(n,t,r,e){return typeof t!="boolean"&&null!=t&&(e=r,r=typeof t!="function"&&e&&e[t]===n?null:t,t=false),null!=r&&(n=Bt(n,r,e)),ot(n,t)},v.forEach=Dt,v.forEachRight=Nt,v.forIn=ne,v.forInRight=function(n,t,r){var e=[];ne(n,function(n,t){e.push(t,n)});var u=e.length;for(t=rt(t,r,3);u--&&false!==t(e[u--],e[u],n););return n},v.forOwn=te,v.forOwnRight=dt,v.functions=_t,v.groupBy=ue,v.indexBy=oe,v.initial=function(n,t,r){var e=0,u=n?n.length:0;
if(typeof t!="number"&&null!=t){var o=u;for(t=v.createCallback(t,r,3);o--&&t(n[o],o,n);)e++}else e=null==t||r?1:t||e;return s(n,0,Pr(Br(0,u-e),u))},v.intersection=function(){for(var r=[],e=-1,u=arguments.length,a=i(),l=ht(),f=l===n,s=i();++e<u;){var g=arguments[e];(qr(g)||bt(g))&&(r.push(g),a.push(f&&g.length>=_&&o(e?r[e]:s)))}var f=r[0],h=-1,v=f?f.length:0,y=[];n:for(;++h<v;){var m=a[0],g=f[h];if(0>(m?t(m,g):l(s,g))){for(e=u,(m||s).push(g);--e;)if(m=a[e],0>(m?t(m,g):l(r[e],g)))continue n;y.push(g)
}}for(;u--;)(m=a[u])&&p(m);return c(a),c(s),y},v.invert=wt,v.invoke=function(n,t){var r=s(arguments,2),e=-1,u=typeof t=="function",o=n?n.length:0,a=Zt(typeof o=="number"?o:0);return Dt(n,function(n){a[++e]=(u?t:n[t]).apply(n,r)}),a},v.keys=Wr,v.map=Bt,v.mapValues=function(n,t,r){var e={};return t=v.createCallback(t,r,3),te(n,function(n,r,u){e[r]=t(n,r,u)}),e},v.max=Pt,v.memoize=function(n,t){if(!jt(n))throw new lr;var r=function(){var e=r.cache,u=t?t.apply(this,arguments):d+arguments[0];return wr.call(e,u)?e[u]:e[u]=n.apply(this,arguments)
};return r.cache={},r},v.merge=function(n){var t=arguments,r=2;if(!Ct(n))return n;if("number"!=typeof t[2]&&(r=t.length),3<r&&"function"==typeof t[r-2])var e=rt(t[--r-1],t[r--],2);else 2<r&&"function"==typeof t[r-1]&&(e=t[--r]);for(var t=s(arguments,1,r),u=-1,o=i(),a=i();++u<r;)it(n,t[u],e,o,a);return c(o),c(a),n},v.min=function(n,t,r){var u=1/0,o=u;if(typeof t!="function"&&r&&r[t]===n&&(t=null),null==t&&qr(n)){r=-1;for(var a=n.length;++r<a;){var i=n[r];i<o&&(o=i)}}else t=null==t&&xt(n)?e:v.createCallback(t,r,3),Xr(n,function(n,r,e){r=t(n,r,e),r<u&&(u=r,o=n)
});return o},v.omit=function(n,t,r){var e={};if(typeof t!="function"){var u=[];ne(n,function(n,t){u.push(t)});for(var u=ut(u,ot(arguments,true,false,1)),o=-1,a=u.length;++o<a;){var i=u[o];e[i]=n[i]}}else t=v.createCallback(t,r,3),ne(n,function(n,r,u){t(n,r,u)||(e[r]=n)});return e},v.once=function(n){var t,r;if(!jt(n))throw new lr;return function(){return t?r:(t=true,r=n.apply(this,arguments),n=null,r)}},v.pairs=function(n){for(var t=-1,r=Wr(n),e=r.length,u=Zt(e);++t<e;){var o=r[t];u[t]=[o,n[o]]}return u
},v.partial=function(n){return pt(n,16,s(arguments,1))},v.partialRight=function(n){return pt(n,32,null,s(arguments,1))},v.pick=function(n,t,r){var e={};if(typeof t!="function")for(var u=-1,o=ot(arguments,true,false,1),a=Ct(n)?o.length:0;++u<a;){var i=o[u];i in n&&(e[i]=n[i])}else t=v.createCallback(t,r,3),ne(n,function(n,r,u){t(n,r,u)&&(e[r]=n)});return e},v.pluck=ae,v.property=Xt,v.pull=function(n){for(var t=arguments,r=0,e=t.length,u=n?n.length:0;++r<e;)for(var o=-1,a=t[r];++o<u;)n[o]===a&&(xr.call(n,o--,1),u--);
return n},v.range=function(n,t,r){n=+n||0,r=typeof r=="number"?r:+r||1,null==t&&(t=n,n=0);var e=-1;t=Br(0,yr((t-n)/(r||1)));for(var u=Zt(t);++e<t;)u[e]=n,n+=r;return u},v.reject=function(n,t,r){return t=v.createCallback(t,r,3),At(n,function(n,r,e){return!t(n,r,e)})},v.remove=function(n,t,r){var e=-1,u=n?n.length:0,o=[];for(t=v.createCallback(t,r,3);++e<u;)r=n[e],t(r,e,n)&&(o.push(r),xr.call(n,e--,1),u--);return o},v.rest=qt,v.shuffle=$t,v.sortBy=function(n,t,r){var e=-1,o=qr(t),a=n?n.length:0,f=Zt(typeof a=="number"?a:0);
for(o||(t=v.createCallback(t,r,3)),Dt(n,function(n,r,u){var a=f[++e]=l();o?a.m=Bt(t,function(t){return n[t]}):(a.m=i())[0]=t(n,r,u),a.n=e,a.o=n}),a=f.length,f.sort(u);a--;)n=f[a],f[a]=n.o,o||c(n.m),p(n);return f},v.tap=function(n,t){return t(n),n},v.throttle=function(n,t,r){var e=true,u=true;if(!jt(n))throw new lr;return false===r?e=false:Ct(r)&&(e="leading"in r?r.leading:e,u="trailing"in r?r.trailing:u),H.leading=e,H.maxWait=t,H.trailing=u,Vt(n,t,H)},v.times=function(n,t,r){n=-1<(n=+n)?n:0;var e=-1,u=Zt(n);
for(t=rt(t,r,1);++e<n;)u[e]=t(e);return u},v.toArray=function(n){return n&&typeof n.length=="number"?zr.unindexedChars&&xt(n)?n.split(""):s(n):Et(n)},v.transform=function(n,t,r,e){var u=qr(n);if(null==r)if(u)r=[];else{var o=n&&n.constructor;r=nt(o&&o.prototype)}return t&&(t=v.createCallback(t,e,4),(u?Xr:te)(n,function(n,e,u){return t(r,n,e,u)})),r},v.union=function(){return ft(ot(arguments,true,true))},v.uniq=Wt,v.values=Et,v.where=At,v.without=function(n){return ut(n,s(arguments,1))},v.wrap=function(n,t){return pt(t,16,[n])
},v.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var r=arguments[n];if(qr(r)||bt(r))var e=e?ft(ut(e,r).concat(ut(r,e))):r}return e||[]},v.zip=Gt,v.zipObject=Jt,v.collect=Bt,v.drop=qt,v.each=Dt,v.eachRight=Nt,v.extend=Yr,v.methods=_t,v.object=Jt,v.select=At,v.tail=qt,v.unique=Wt,v.unzip=Gt,Ut(v),v.clone=function(n,t,r,e){return typeof t!="boolean"&&null!=t&&(e=r,r=t,t=false),Y(n,t,typeof r=="function"&&rt(r,e,1))},v.cloneDeep=function(n,t,r){return Y(n,true,typeof t=="function"&&rt(t,r,1))},v.contains=Ot,v.escape=function(n){return null==n?"":ir(n).replace(Qr,gt)
},v.every=St,v.find=It,v.findIndex=function(n,t,r){var e=-1,u=n?n.length:0;for(t=v.createCallback(t,r,3);++e<u;)if(t(n[e],e,n))return e;return-1},v.findKey=function(n,t,r){var e;return t=v.createCallback(t,r,3),te(n,function(n,r,u){return t(n,r,u)?(e=r,false):void 0}),e},v.findLast=function(n,t,r){var e;return t=v.createCallback(t,r,3),Nt(n,function(n,r,u){return t(n,r,u)?(e=n,false):void 0}),e},v.findLastIndex=function(n,t,r){var e=n?n.length:0;for(t=v.createCallback(t,r,3);e--;)if(t(n[e],e,n))return e;
return-1},v.findLastKey=function(n,t,r){var e;return t=v.createCallback(t,r,3),dt(n,function(n,r,u){return t(n,r,u)?(e=r,false):void 0}),e},v.has=function(n,t){return n?wr.call(n,t):false},v.identity=Ht,v.indexOf=Tt,v.isArguments=bt,v.isArray=qr,v.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&hr.call(n)==z||false},v.isDate=function(n){return n&&typeof n=="object"&&hr.call(n)==T||false},v.isElement=function(n){return n&&1===n.nodeType||false},v.isEmpty=function(n){var t=true;if(!n)return t;var r=hr.call(n),e=n.length;
return r==L||r==M||(zr.argsClass?r==$:bt(n))||r==G&&typeof e=="number"&&jt(n.splice)?!e:(te(n,function(){return t=false}),t)},v.isEqual=function(n,t,r,e){return at(n,t,typeof r=="function"&&rt(r,e,2))},v.isFinite=function(n){return Ir(n)&&!Dr(parseFloat(n))},v.isFunction=jt,v.isNaN=function(n){return kt(n)&&n!=+n},v.isNull=function(n){return null===n},v.isNumber=kt,v.isObject=Ct,v.isPlainObject=re,v.isRegExp=function(n){return n&&X[typeof n]&&hr.call(n)==J||false},v.isString=xt,v.isUndefined=function(n){return typeof n=="undefined"
},v.lastIndexOf=function(n,t,r){var e=n?n.length:0;for(typeof r=="number"&&(e=(0>r?Br(0,e+r):Pr(r,e-1))+1);e--;)if(n[e]===t)return e;return-1},v.mixin=Ut,v.noConflict=function(){return r._=gr,this},v.noop=Qt,v.now=ie,v.parseInt=le,v.random=function(n,t,r){var e=null==n,u=null==t;return null==r&&(typeof n=="boolean"&&u?(r=n,n=1):u||typeof t!="boolean"||(r=t,u=true)),e&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,r||n%1||t%1?(r=Fr(),Pr(n+r*(t-n+parseFloat("1e-"+((r+"").length-1))),t)):lt(n,t)},v.reduce=Rt,v.reduceRight=Ft,v.result=function(n,t){if(n){var r=n[t];
return jt(r)?n[t]():r}},v.runInContext=g,v.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:Wr(n).length},v.some=Lt,v.sortedIndex=Kt,v.template=function(n,t,r){var e=v.templateSettings;n=ir(n||""),r=Zr({},r,e);var u,o=Zr({},r.imports,e.imports),e=Wr(o),o=Et(o),i=0,l=r.interpolate||N,f="__p+='",l=ar((r.escape||N).source+"|"+l.source+"|"+(l===I?O:N).source+"|"+(r.evaluate||N).source+"|$","g");n.replace(l,function(t,r,e,o,l,c){return e||(e=o),f+=n.slice(i,c).replace(P,a),r&&(f+="'+__e("+r+")+'"),l&&(u=true,f+="';"+l+";\n__p+='"),e&&(f+="'+((__t=("+e+"))==null?'':__t)+'"),i=c+t.length,t
}),f+="';",l=r=r.variable,l||(r="obj",f="with("+r+"){"+f+"}"),f=(u?f.replace(C,""):f).replace(x,"$1").replace(E,"$1;"),f="function("+r+"){"+(l?"":r+"||("+r+"={});")+"var __t,__p='',__e=_.escape"+(u?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+f+"return __p}";try{var c=rr(e,"return "+f).apply(h,o)}catch(p){throw p.source=f,p}return t?c(t):(c.source=f,c)},v.unescape=function(n){return null==n?"":ir(n).replace(Ur,mt)},v.uniqueId=function(n){var t=++m;return ir(null==n?"":n)+t
},v.all=St,v.any=Lt,v.detect=It,v.findWhere=It,v.foldl=Rt,v.foldr=Ft,v.include=Ot,v.inject=Rt,Ut(function(){var n={};return te(v,function(t,r){v.prototype[r]||(n[r]=t)}),n}(),false),v.first=zt,v.last=function(n,t,r){var e=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=v.createCallback(t,r,3);o--&&t(n[o],o,n);)e++}else if(e=t,null==e||r)return n?n[u-1]:h;return s(n,Br(0,u-e))},v.sample=function(n,t,r){return n&&typeof n.length!="number"?n=Et(n):zr.unindexedChars&&xt(n)&&(n=n.split("")),null==t||r?n?n[lt(0,n.length-1)]:h:(n=$t(n),n.length=Pr(Br(0,t),n.length),n)
},v.take=zt,v.head=zt,te(v,function(n,t){var r="sample"!==t;v.prototype[t]||(v.prototype[t]=function(t,e){var u=this.__chain__,o=n(this.__wrapped__,t,e);return u||null!=t&&(!e||r&&typeof t=="function")?new y(o,u):o})}),v.VERSION="2.4.1",v.prototype.chain=function(){return this.__chain__=true,this},v.prototype.toString=function(){return ir(this.__wrapped__)},v.prototype.value=Yt,v.prototype.valueOf=Yt,Xr(["join","pop","shift"],function(n){var t=fr[n];v.prototype[n]=function(){var n=this.__chain__,r=t.apply(this.__wrapped__,arguments);
return n?new y(r,n):r}}),Xr(["push","reverse","sort","unshift"],function(n){var t=fr[n];v.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),Xr(["concat","slice","splice"],function(n){var t=fr[n];v.prototype[n]=function(){return new y(t.apply(this.__wrapped__,arguments),this.__chain__)}}),zr.spliceObjects||Xr(["pop","shift","splice"],function(n){var t=fr[n],r="splice"==n;v.prototype[n]=function(){var n=this.__chain__,e=this.__wrapped__,u=t.apply(e,arguments);return 0===e.length&&delete e[0],n||r?new y(u,n):u
}}),v}var h,v=[],y=[],m=0,b={},d=+new Date+"",_=75,w=40,j=" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000",C=/\b__p\+='';/g,x=/\b(__p\+=)''\+/g,E=/(__e\(.*?\)|\b__t\))\+'';/g,O=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,S=/\w*$/,A=/^\s*function[ \n\r\t]+\w/,I=/<%=([\s\S]+?)%>/g,D=RegExp("^["+j+"]*0+(?=.$)"),N=/($^)/,B=/\bthis\b/,P=/['\n\r\t\u2028\u2029\\]/g,R="Array Boolean Date Error Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "),F="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),$="[object Arguments]",L="[object Array]",z="[object Boolean]",T="[object Date]",q="[object Error]",K="[object Function]",W="[object Number]",G="[object Object]",J="[object RegExp]",M="[object String]",V={};
V[K]=false,V[$]=V[L]=V[z]=V[T]=V[W]=V[G]=V[J]=V[M]=true;var H={leading:false,maxWait:0,trailing:false},U={configurable:false,enumerable:false,value:null,writable:false},Q={a:"",b:null,c:"",d:"",e:"",v:null,g:"",h:null,support:null,i:"",j:false},X={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},Y={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},Z=X[typeof window]&&window||this,nt=X[typeof global]&&global;!nt||nt.global!==nt&&nt.window!==nt||(Z=nt);var tt=g();typeof define=="function"&&typeof define.amd=="object"&&define.amd&& define('vendor/lodash',[],function(){return tt
})}).call(this);
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.core',[], f);
})(function(){

/*jshint eqnull: true, loopfunc: true, evil: true, boss: true, freeze: false*/
(function($, undefined) {
    var kendo = window.kendo = window.kendo || { cultures: {} },
        extend = $.extend,
        each = $.each,
        isArray = $.isArray,
        proxy = $.proxy,
        noop = $.noop,
        math = Math,
        Template,
        JSON = window.JSON || {},
        support = {},
        percentRegExp = /%/,
        formatRegExp = /\{(\d+)(:[^\}]+)?\}/g,
        boxShadowRegExp = /(\d+(?:\.?)\d*)px\s*(\d+(?:\.?)\d*)px\s*(\d+(?:\.?)\d*)px\s*(\d+)?/i,
        numberRegExp = /^(\+|-?)\d+(\.?)\d*$/,
        FUNCTION = "function",
        STRING = "string",
        NUMBER = "number",
        OBJECT = "object",
        NULL = "null",
        BOOLEAN = "boolean",
        UNDEFINED = "undefined",
        getterCache = {},
        setterCache = {},
        slice = [].slice,
        globalize = window.Globalize;

    kendo.version = "$KENDO_VERSION";

    function Class() {}

    Class.extend = function(proto) {
        var base = function() {},
            member,
            that = this,
            subclass = proto && proto.init ? proto.init : function () {
                that.apply(this, arguments);
            },
            fn;

        base.prototype = that.prototype;
        fn = subclass.fn = subclass.prototype = new base();

        for (member in proto) {
            if (proto[member] != null && proto[member].constructor === Object) {
                // Merge object members
                fn[member] = extend(true, {}, base.prototype[member], proto[member]);
            } else {
                fn[member] = proto[member];
            }
        }

        fn.constructor = subclass;
        subclass.extend = that.extend;

        return subclass;
    };

    Class.prototype._initOptions = function(options) {
        this.options = deepExtend({}, this.options, options);
    };

    var isFunction = kendo.isFunction = function(fn) {
        return typeof fn === "function";
    };

    var preventDefault = function() {
        this._defaultPrevented = true;
    };

    var isDefaultPrevented = function() {
        return this._defaultPrevented === true;
    };

    var Observable = Class.extend({
        init: function() {
            this._events = {};
        },

        bind: function(eventName, handlers, one) {
            var that = this,
                idx,
                eventNames = typeof eventName === STRING ? [eventName] : eventName,
                length,
                original,
                handler,
                handlersIsFunction = typeof handlers === FUNCTION,
                events;

            if (handlers === undefined) {
                for (idx in eventName) {
                    that.bind(idx, eventName[idx]);
                }
                return that;
            }

            for (idx = 0, length = eventNames.length; idx < length; idx++) {
                eventName = eventNames[idx];

                handler = handlersIsFunction ? handlers : handlers[eventName];

                if (handler) {
                    if (one) {
                        original = handler;
                        handler = function() {
                            that.unbind(eventName, handler);
                            original.apply(that, arguments);
                        };
                        handler.original = original;
                    }
                    events = that._events[eventName] = that._events[eventName] || [];
                    events.push(handler);
                }
            }

            return that;
        },

        one: function(eventNames, handlers) {
            return this.bind(eventNames, handlers, true);
        },

        first: function(eventName, handlers) {
            var that = this,
                idx,
                eventNames = typeof eventName === STRING ? [eventName] : eventName,
                length,
                handler,
                handlersIsFunction = typeof handlers === FUNCTION,
                events;

            for (idx = 0, length = eventNames.length; idx < length; idx++) {
                eventName = eventNames[idx];

                handler = handlersIsFunction ? handlers : handlers[eventName];

                if (handler) {
                    events = that._events[eventName] = that._events[eventName] || [];
                    events.unshift(handler);
                }
            }

            return that;
        },

        trigger: function(eventName, e) {
            var that = this,
                events = that._events[eventName],
                idx,
                length;

            if (events) {
                e = e || {};

                e.sender = that;

                e._defaultPrevented = false;

                e.preventDefault = preventDefault;

                e.isDefaultPrevented = isDefaultPrevented;

                events = events.slice();

                for (idx = 0, length = events.length; idx < length; idx++) {
                    events[idx].call(that, e);
                }

                return e._defaultPrevented === true;
            }

            return false;
        },

        unbind: function(eventName, handler) {
            var that = this,
                events = that._events[eventName],
                idx;

            if (eventName === undefined) {
                that._events = {};
            } else if (events) {
                if (handler) {
                    for (idx = events.length - 1; idx >= 0; idx--) {
                        if (events[idx] === handler || events[idx].original === handler) {
                            events.splice(idx, 1);
                        }
                    }
                } else {
                    that._events[eventName] = [];
                }
            }

            return that;
        }
    });


     function compilePart(part, stringPart) {
         if (stringPart) {
             return "'" +
                 part.split("'").join("\\'")
                     .split('\\"').join('\\\\\\"')
                     .replace(/\n/g, "\\n")
                     .replace(/\r/g, "\\r")
                     .replace(/\t/g, "\\t") + "'";
         } else {
             var first = part.charAt(0),
                 rest = part.substring(1);

             if (first === "=") {
                 return "+(" + rest + ")+";
             } else if (first === ":") {
                 return "+e(" + rest + ")+";
             } else {
                 return ";" + part + ";o+=";
             }
         }
     }

    var argumentNameRegExp = /^\w+/,
        encodeRegExp = /\$\{([^}]*)\}/g,
        escapedCurlyRegExp = /\\\}/g,
        curlyRegExp = /__CURLY__/g,
        escapedSharpRegExp = /\\#/g,
        sharpRegExp = /__SHARP__/g,
        zeros = ["", "0", "00", "000", "0000"];

    Template = {
        paramName: "data", // name of the parameter of the generated template
        useWithBlock: true, // whether to wrap the template in a with() block
        render: function(template, data) {
            var idx,
                length,
                html = "";

            for (idx = 0, length = data.length; idx < length; idx++) {
                html += template(data[idx]);
            }

            return html;
        },
        compile: function(template, options) {
            var settings = extend({}, this, options),
                paramName = settings.paramName,
                argumentName = paramName.match(argumentNameRegExp)[0],
                useWithBlock = settings.useWithBlock,
                functionBody = "var o,e=kendo.htmlEncode;",
                fn,
                parts,
                idx;

            if (isFunction(template)) {
                if (template.length === 2) {
                    //looks like jQuery.template
                    return function(d) {
                        return template($, { data: d }).join("");
                    };
                }
                return template;
            }

            functionBody += useWithBlock ? "with(" + paramName + "){" : "";

            functionBody += "o=";

            parts = template
                .replace(escapedCurlyRegExp, "__CURLY__")
                .replace(encodeRegExp, "#=e($1)#")
                .replace(curlyRegExp, "}")
                .replace(escapedSharpRegExp, "__SHARP__")
                .split("#");

            for (idx = 0; idx < parts.length; idx ++) {
                functionBody += compilePart(parts[idx], idx % 2 === 0);
            }

            functionBody += useWithBlock ? ";}" : ";";

            functionBody += "return o;";

            functionBody = functionBody.replace(sharpRegExp, "#");

            try {
                fn = new Function(argumentName, functionBody);
                fn._slotCount = Math.floor(parts.length / 2);
                return fn;
            } catch(e) {
                throw new Error(kendo.format("Invalid template:'{0}' Generated code:'{1}'", template, functionBody));
            }
        }
    };

function pad(number, digits, end) {
    number = number + "";
    digits = digits || 2;
    end = digits - number.length;

    if (end) {
        return zeros[digits].substring(0, end) + number;
    }

    return number;
}

    //JSON stringify
(function() {
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"" : '\\"',
            "\\": "\\\\"
        },
        rep,
        toString = {}.toString;


    if (typeof Date.prototype.toJSON !== FUNCTION) {

        Date.prototype.toJSON = function () {
            var that = this;

            return isFinite(that.valueOf()) ?
                pad(that.getUTCFullYear(), 4) + "-" +
                pad(that.getUTCMonth() + 1)   + "-" +
                pad(that.getUTCDate())        + "T" +
                pad(that.getUTCHours())       + ":" +
                pad(that.getUTCMinutes())     + ":" +
                pad(that.getUTCSeconds())     + "Z" : null;
        };

        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () {
            return this.valueOf();
        };
    }

    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? "\"" + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === STRING ? c :
                "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + "\"" : "\"" + string + "\"";
    }

    function str(key, holder) {
        var i,
            k,
            v,
            length,
            mind = gap,
            partial,
            value = holder[key],
            type;

        if (value && typeof value === OBJECT && typeof value.toJSON === FUNCTION) {
            value = value.toJSON(key);
        }

        if (typeof rep === FUNCTION) {
            value = rep.call(holder, key, value);
        }

        type = typeof value;
        if (type === STRING) {
            return quote(value);
        } else if (type === NUMBER) {
            return isFinite(value) ? String(value) : NULL;
        } else if (type === BOOLEAN || type === NULL) {
            return String(value);
        } else if (type === OBJECT) {
            if (!value) {
                return NULL;
            }
            gap += indent;
            partial = [];
            if (toString.apply(value) === "[object Array]") {
                length = value.length;
                for (i = 0; i < length; i++) {
                    partial[i] = str(i, value) || NULL;
                }
                v = partial.length === 0 ? "[]" : gap ?
                    "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" :
                    "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }
            if (rep && typeof rep === OBJECT) {
                length = rep.length;
                for (i = 0; i < length; i++) {
                    if (typeof rep[i] === STRING) {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ": " : ":") + v);
                        }
                    }
                }
            } else {
                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ": " : ":") + v);
                        }
                    }
                }
            }

            v = partial.length === 0 ? "{}" : gap ?
                "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" :
                "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

    if (typeof JSON.stringify !== FUNCTION) {
        JSON.stringify = function (value, replacer, space) {
            var i;
            gap = "";
            indent = "";

            if (typeof space === NUMBER) {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

            } else if (typeof space === STRING) {
                indent = space;
            }

            rep = replacer;
            if (replacer && typeof replacer !== FUNCTION && (typeof replacer !== OBJECT || typeof replacer.length !== NUMBER)) {
                throw new Error("JSON.stringify");
            }

            return str("", {"": value});
        };
    }
})();

// Date and Number formatting
(function() {
    var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|"[^"]*"|'[^']*'/g,
        standardFormatRegExp =  /^(n|c|p|e)(\d*)$/i,
        literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g,
        commaRegExp = /\,/g,
        EMPTY = "",
        POINT = ".",
        COMMA = ",",
        SHARP = "#",
        ZERO = "0",
        PLACEHOLDER = "??",
        //EN = "da-DK",
        EN = "en-US",
        objectToString = {}.toString;

    //cultures
    kendo.cultures["en-US"] = {
        name: EN,
        numberFormat: {
            pattern: ["-n"],
            decimals: 2,
            ",": ",",
            ".": ".",
            groupSize: [3],
            percent: {
                pattern: ["-n %", "n %"],
                decimals: 2,
                ",": ",",
                ".": ".",
                groupSize: [3],
                symbol: "%"
            },
            currency: {
                pattern: ["($n)", "$n"],
                decimals: 2,
                ",": ",",
                ".": ".",
                groupSize: [3],
                symbol: "$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
                },
                months: {
                    names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
                },
                AM: [ "AM", "am", "AM" ],
                PM: [ "PM", "pm", "PM" ],
                patterns: {
                    d: "M/d/yyyy",
                    D: "dddd, MMMM dd, yyyy",
                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                    g: "M/d/yyyy h:mm tt",
                    G: "M/d/yyyy h:mm:ss tt",
                    m: "MMMM dd",
                    M: "MMMM dd",
                    s: "yyyy'-'MM'-'ddTHH':'mm':'ss",
                    t: "h:mm tt",
                    T: "h:mm:ss tt",
                    u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
                    y: "MMMM, yyyy",
                    Y: "MMMM, yyyy"
                },
                "/": "/",
                ":": ":",
                firstDay: 0,
                twoDigitYearMax: 2029
            }
        }
    };

    //	kendo.cultures["da-DK"] = {
	//	name: "da-DK",
	//	numberFormat: {
	//		pattern: ["-n"],
	//		decimals: 2,
	//		",": ".",
	//		".": ",",
	//		groupSize: [3],
	//		percent: {
	//			pattern: ["-n %", "n %"],
	//			decimals: 2,
	//			",": ".",
	//			".": ",",
	//			groupSize: [3],
	//			symbol: "%"
	//		},
	//		currency: {
	//			name: "Danish Krone",
	//			abbr: "DKK",
	//			pattern: ["$ -n", "$ n"],
	//			decimals: 2,
	//			",": ".",
	//			".": ",",
	//			groupSize: [3],
	//			symbol: "kr."
	//		}
	//	},
	//	calendars: {
	//		standard: {
	//			days: {
	//				names: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"],
	//				namesAbbr: ["søn", "man", "tir", "ons", "tor", "fre", "lør"],
	//				namesShort: ["sø", "ma", "ti", "on", "to", "fr", "lø"]
	//			},
	//			months: {
	//				names: ["januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december"],
	//				namesAbbr: ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
	//			},
	//			AM: [""],
	//			PM: [""],
	//			patterns: {
	//				d: "dd-MM-yyyy",
	//				D: "d. MMMM yyyy",
	//				F: "d. MMMM yyyy HH:mm:ss",
	//				g: "dd-MM-yyyy HH:mm",
	//				G: "dd-MM-yyyy HH:mm:ss",
	//				m: "d. MMMM",
	//				M: "d. MMMM",
	//				s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
	//				t: "HH:mm",
	//				T: "HH:mm:ss",
	//				u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
	//				y: "MMMM yyyy",
	//				Y: "MMMM yyyy"
	//			},
	//			"/": "-",
	//			":": ":",
	//			firstDay: 1
	//		}
	//	}
	//};



     function findCulture(culture) {
        if (culture) {
            if (culture.numberFormat) {
                return culture;
            }

            if (typeof culture === STRING) {
                var cultures = kendo.cultures;
                return cultures[culture] || cultures[culture.split("-")[0]] || null;
            }

            return null;
        }

        return null;
    }

    function getCulture(culture) {
        if (culture) {
            culture = findCulture(culture);
        }

        return culture || kendo.cultures.current;
    }

    function expandNumberFormat(numberFormat) {
        numberFormat.groupSizes = numberFormat.groupSize;
        numberFormat.percent.groupSizes = numberFormat.percent.groupSize;
        numberFormat.currency.groupSizes = numberFormat.currency.groupSize;
    }

    kendo.culture = function(cultureName) {
        var cultures = kendo.cultures, culture;

        if (cultureName !== undefined) {
            culture = findCulture(cultureName) || cultures[EN];
            culture.calendar = culture.calendars.standard;
            cultures.current = culture;

            if (globalize) {
                expandNumberFormat(culture.numberFormat);
            }

        } else {
            return cultures.current;
        }
    };

    kendo.findCulture = findCulture;
    kendo.getCulture = getCulture;

    //set current culture to en-US.
    kendo.culture(EN);

    function formatDate(date, format, culture) {
        culture = getCulture(culture);

        var calendar = culture.calendars.standard,
            days = calendar.days,
            months = calendar.months;

        format = calendar.patterns[format] || format;

        return format.replace(dateFormatRegExp, function (match) {
            var result;

            if (match === "d") {
                result = date.getDate();
            } else if (match === "dd") {
                result = pad(date.getDate());
            } else if (match === "ddd") {
                result = days.namesAbbr[date.getDay()];
            } else if (match === "dddd") {
                result = days.names[date.getDay()];
            } else if (match === "M") {
                result = date.getMonth() + 1;
            } else if (match === "MM") {
                result = pad(date.getMonth() + 1);
            } else if (match === "MMM") {
                result = months.namesAbbr[date.getMonth()];
            } else if (match === "MMMM") {
                result = months.names[date.getMonth()];
            } else if (match === "yy") {
                result = pad(date.getFullYear() % 100);
            } else if (match === "yyyy") {
                result = pad(date.getFullYear(), 4);
            } else if (match === "h" ) {
                result = date.getHours() % 12 || 12;
            } else if (match === "hh") {
                result = pad(date.getHours() % 12 || 12);
            } else if (match === "H") {
                result = date.getHours();
            } else if (match === "HH") {
                result = pad(date.getHours());
            } else if (match === "m") {
                result = date.getMinutes();
            } else if (match === "mm") {
                result = pad(date.getMinutes());
            } else if (match === "s") {
                result = date.getSeconds();
            } else if (match === "ss") {
                result = pad(date.getSeconds());
            } else if (match === "f") {
                result = math.floor(date.getMilliseconds() / 100);
            } else if (match === "ff") {
                result = date.getMilliseconds();
                if (result > 99) {
                    result = math.floor(result / 10);
                }

                result = pad(result);
            } else if (match === "fff") {
                result = pad(date.getMilliseconds(), 3);
            } else if (match === "tt") {
                result = date.getHours() < 12 ? calendar.AM[0] : calendar.PM[0];
            }

            return result !== undefined ? result : match.slice(1, match.length - 1);
        });
    }

    //number formatting
    function formatNumber(number, format, culture) {
        culture = getCulture(culture);

        var numberFormat = culture.numberFormat,
            groupSize = numberFormat.groupSize[0],
            groupSeparator = numberFormat[COMMA],
            decimal = numberFormat[POINT],
            precision = numberFormat.decimals,
            pattern = numberFormat.pattern[0],
            literals = [],
            symbol,
            isCurrency, isPercent,
            customPrecision,
            formatAndPrecision,
            negative = number < 0,
            integer,
            fraction,
            integerLength,
            fractionLength,
            replacement = EMPTY,
            value = EMPTY,
            idx,
            length,
            ch,
            hasGroup,
            hasNegativeFormat,
            decimalIndex,
            sharpIndex,
            zeroIndex,
            hasZero, hasSharp,
            percentIndex,
            currencyIndex,
            startZeroIndex,
            start = -1,
            end;

        //return empty string if no number
        if (number === undefined) {
            return EMPTY;
        }

        if (!isFinite(number)) {
            return number;
        }

        //if no format then return number.toString() or number.toLocaleString() if culture.name is not defined
        if (!format) {
            return culture.name.length ? number.toLocaleString() : number.toString();
        }

        formatAndPrecision = standardFormatRegExp.exec(format);

        // standard formatting
        if (formatAndPrecision) {
            format = formatAndPrecision[1].toLowerCase();

            isCurrency = format === "c";
            isPercent = format === "p";

            if (isCurrency || isPercent) {
                //get specific number format information if format is currency or percent
                numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;
                groupSize = numberFormat.groupSize[0];
                groupSeparator = numberFormat[COMMA];
                decimal = numberFormat[POINT];
                precision = numberFormat.decimals;
                symbol = numberFormat.symbol;
                pattern = numberFormat.pattern[negative ? 0 : 1];
            }

            customPrecision = formatAndPrecision[2];

            if (customPrecision) {
                precision = +customPrecision;
            }

            //return number in exponential format
            if (format === "e") {
                return customPrecision ? number.toExponential(precision) : number.toExponential(); // toExponential() and toExponential(undefined) differ in FF #653438.
            }

            // multiply if format is percent
            if (isPercent) {
                number *= 100;
            }

            number = round(number, precision);
            negative = number < 0;
            number = number.split(POINT);

            integer = number[0];
            fraction = number[1];

            //exclude "-" if number is negative.
            if (negative) {
                integer = integer.substring(1);
            }

            value = integer;
            integerLength = integer.length;

            //add group separator to the number if it is longer enough
            if (integerLength >= groupSize) {
                value = EMPTY;
                for (idx = 0; idx < integerLength; idx++) {
                    if (idx > 0 && (integerLength - idx) % groupSize === 0) {
                        value += groupSeparator;
                    }
                    value += integer.charAt(idx);
                }
            }

            if (fraction) {
                value += decimal + fraction;
            }

            if (format === "n" && !negative) {
                return value;
            }

            number = EMPTY;

            for (idx = 0, length = pattern.length; idx < length; idx++) {
                ch = pattern.charAt(idx);

                if (ch === "n") {
                    number += value;
                } else if (ch === "$" || ch === "%") {
                    number += symbol;
                } else {
                    number += ch;
                }
            }

            return number;
        }

        //custom formatting
        //
        //separate format by sections.

        //make number positive
        if (negative) {
            number = -number;
        }

        if (format.indexOf("'") > -1 || format.indexOf("\"") > -1 || format.indexOf("\\") > -1) {
            format = format.replace(literalRegExp, function (match) {
                var quoteChar = match.charAt(0).replace("\\", ""),
                    literal = match.slice(1).replace(quoteChar, "");

                literals.push(literal);

                return PLACEHOLDER;
            });
        }

        format = format.split(";");
        if (negative && format[1]) {
            //get negative format
            format = format[1];
            hasNegativeFormat = true;
        } else if (number === 0) {
            //format for zeros
            format = format[2] || format[0];
            if (format.indexOf(SHARP) == -1 && format.indexOf(ZERO) == -1) {
                //return format if it is string constant.
                return format;
            }
        } else {
            format = format[0];
        }

        percentIndex = format.indexOf("%");
        currencyIndex = format.indexOf("$");

        isPercent = percentIndex != -1;
        isCurrency = currencyIndex != -1;

        //multiply number if the format has percent
        if (isPercent) {
            number *= 100;
        }

        if (isCurrency && format[currencyIndex - 1] === "\\") {
            format = format.split("\\").join("");
            isCurrency = false;
        }

        if (isCurrency || isPercent) {
            //get specific number format information if format is currency or percent
            numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;
            groupSize = numberFormat.groupSize[0];
            groupSeparator = numberFormat[COMMA];
            decimal = numberFormat[POINT];
            precision = numberFormat.decimals;
            symbol = numberFormat.symbol;
        }

        hasGroup = format.indexOf(COMMA) > -1;
        if (hasGroup) {
            format = format.replace(commaRegExp, EMPTY);
        }

        decimalIndex = format.indexOf(POINT);
        length = format.length;

        if (decimalIndex != -1) {
            fraction = number.toString().split("e");
            if (fraction[1]) {
                fraction = round(number, Math.abs(fraction[1]));
            } else {
                fraction = fraction[0];
            }
            fraction = fraction.split(POINT)[1] || EMPTY;
            zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;
            sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;
            hasZero = zeroIndex > -1;
            hasSharp = sharpIndex > -1;
            idx = fraction.length;

            if (!hasZero && !hasSharp) {
                format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);
                length = format.length;
                decimalIndex = -1;
                idx = 0;
            } if (hasZero && zeroIndex > sharpIndex) {
                idx = zeroIndex;
            } else if (sharpIndex > zeroIndex) {
                if (hasSharp && idx > sharpIndex) {
                    idx = sharpIndex;
                } else if (hasZero && idx < zeroIndex) {
                    idx = zeroIndex;
                }
            }

            if (idx > -1) {
                number = round(number, idx);
            }
        } else {
            number = round(number);
        }

        sharpIndex = format.indexOf(SHARP);
        startZeroIndex = zeroIndex = format.indexOf(ZERO);

        //define the index of the first digit placeholder
        if (sharpIndex == -1 && zeroIndex != -1) {
            start = zeroIndex;
        } else if (sharpIndex != -1 && zeroIndex == -1) {
            start = sharpIndex;
        } else {
            start = sharpIndex > zeroIndex ? zeroIndex : sharpIndex;
        }

        sharpIndex = format.lastIndexOf(SHARP);
        zeroIndex = format.lastIndexOf(ZERO);

        //define the index of the last digit placeholder
        if (sharpIndex == -1 && zeroIndex != -1) {
            end = zeroIndex;
        } else if (sharpIndex != -1 && zeroIndex == -1) {
            end = sharpIndex;
        } else {
            end = sharpIndex > zeroIndex ? sharpIndex : zeroIndex;
        }

        if (start == length) {
            end = start;
        }

        if (start != -1) {
            value = number.toString().split(POINT);
            integer = value[0];
            fraction = value[1] || EMPTY;

            integerLength = integer.length;
            fractionLength = fraction.length;

            if (negative && (number * -1) >= 0) {
                negative = false;
            }

            //add group separator to the number if it is longer enough
            if (hasGroup) {
                if (integerLength === groupSize && integerLength < decimalIndex - startZeroIndex) {
                    integer = groupSeparator + integer;
                } else if (integerLength > groupSize) {
                    value = EMPTY;
                    for (idx = 0; idx < integerLength; idx++) {
                        if (idx > 0 && (integerLength - idx) % groupSize === 0) {
                            value += groupSeparator;
                        }
                        value += integer.charAt(idx);
                    }

                    integer = value;
                }
            }

            number = format.substring(0, start);

            if (negative && !hasNegativeFormat) {
                number += "-";
            }

            for (idx = start; idx < length; idx++) {
                ch = format.charAt(idx);

                if (decimalIndex == -1) {
                    if (end - idx < integerLength) {
                        number += integer;
                        break;
                    }
                } else {
                    if (zeroIndex != -1 && zeroIndex < idx) {
                        replacement = EMPTY;
                    }

                    if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {
                        number += integer;
                        idx = decimalIndex;
                    }

                    if (decimalIndex === idx) {
                        number += (fraction ? decimal : EMPTY) + fraction;
                        idx += end - decimalIndex + 1;
                        continue;
                    }
                }

                if (ch === ZERO) {
                    number += ch;
                    replacement = ch;
                } else if (ch === SHARP) {
                    number += replacement;
                }
            }

            if (end >= start) {
                number += format.substring(end + 1);
            }

            //replace symbol placeholders
            if (isCurrency || isPercent) {
                value = EMPTY;
                for (idx = 0, length = number.length; idx < length; idx++) {
                    ch = number.charAt(idx);
                    value += (ch === "$" || ch === "%") ? symbol : ch;
                }
                number = value;
            }

            length = literals.length;

            if (length) {
                for (idx = 0; idx < length; idx++) {
                    number = number.replace(PLACEHOLDER, literals[idx]);
                }
            }
        }

        return number;
    }

    var round = function(value, precision) {
        precision = precision || 0;

        value = value.toString().split('e');
        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision)));

        value = value.toString().split('e');
        value = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));

        return value.toFixed(precision);
    };

    var toString = function(value, fmt, culture) {
        if (fmt) {
            if (objectToString.call(value) === "[object Date]") {
                return formatDate(value, fmt, culture);
            } else if (typeof value === NUMBER) {
                return formatNumber(value, fmt, culture);
            }
        }

        return value !== undefined ? value : "";
    };

    if (globalize) {
        toString = function(value, format, culture) {
            if ($.isPlainObject(culture)) {
                culture = culture.name;
            }

            return globalize.format(value, format, culture);
        };
    }

    kendo.format = function(fmt) {
        var values = arguments;

        return fmt.replace(formatRegExp, function(match, index, placeholderFormat) {
            var value = values[parseInt(index, 10) + 1];

            return toString(value, placeholderFormat ? placeholderFormat.substring(1) : "");
        });
    };

    kendo._extractFormat = function (format) {
        if (format.slice(0,3) === "{0:") {
            format = format.slice(3, format.length - 1);
        }

        return format;
    };

    kendo._activeElement = function() {
        try {
            return document.activeElement;
        } catch(e) {
            return document.documentElement.activeElement;
        }
    };

    kendo._round = round;
    kendo.toString = toString;
})();


(function() {
    var nonBreakingSpaceRegExp = /\u00A0/g,
        exponentRegExp = /[eE][\-+]?[0-9]+/,
        shortTimeZoneRegExp = /[+|\-]\d{1,2}/,
        longTimeZoneRegExp = /[+|\-]\d{1,2}:\d{2}/,
        dateRegExp = /^\/Date\((.*?)\)\/$/,
        offsetRegExp = /[+-]\d*/,
        formatsSequence = ["G", "g", "d", "F", "D", "y", "m", "T", "t"],
        numberRegExp = {
            2: /^\d{1,2}/,
            3: /^\d{1,3}/,
            4: /^\d{4}/
        },
        objectToString = {}.toString;

    function outOfRange(value, start, end) {
        return !(value >= start && value <= end);
    }

    function designatorPredicate(designator) {
        return designator.charAt(0);
    }

    function mapDesignators(designators) {
        return $.map(designators, designatorPredicate);
    }

    //if date's day is different than the typed one - adjust
    function adjustDST(date, hours) {
        if (!hours && date.getHours() === 23) {
            date.setHours(date.getHours() + 2);
        }
    }

    function lowerArray(data) {
        var idx = 0,
            length = data.length,
            array = [];

        for (; idx < length; idx++) {
            array[idx] = (data[idx] + "").toLowerCase();
        }

        return array;
    }

    function lowerLocalInfo(localInfo) {
        var newLocalInfo = {}, property;

        for (property in localInfo) {
            newLocalInfo[property] = lowerArray(localInfo[property]);
        }

        return newLocalInfo;
    }

    function parseExact(value, format, culture) {
        if (!value) {
            return null;
        }

        var lookAhead = function (match) {
                var i = 0;
                while (format[idx] === match) {
                    i++;
                    idx++;
                }
                if (i > 0) {
                    idx -= 1;
                }
                return i;
            },
            getNumber = function(size) {
                var rg = numberRegExp[size] || new RegExp('^\\d{1,' + size + '}'),
                    match = value.substr(valueIdx, size).match(rg);

                if (match) {
                    match = match[0];
                    valueIdx += match.length;
                    return parseInt(match, 10);
                }
                return null;
            },
            getIndexByName = function (names, lower) {
                var i = 0,
                    length = names.length,
                    name, nameLength,
                    subValue;

                for (; i < length; i++) {
                    name = names[i];
                    nameLength = name.length;
                    subValue = value.substr(valueIdx, nameLength);

                    if (lower) {
                        subValue = subValue.toLowerCase();
                    }

                    if (subValue == name) {
                        valueIdx += nameLength;
                        return i + 1;
                    }
                }
                return null;
            },
            checkLiteral = function() {
                var result = false;
                if (value.charAt(valueIdx) === format[idx]) {
                    valueIdx++;
                    result = true;
                }
                return result;
            },
            calendar = culture.calendars.standard,
            year = null,
            month = null,
            day = null,
            hours = null,
            minutes = null,
            seconds = null,
            milliseconds = null,
            idx = 0,
            valueIdx = 0,
            literal = false,
            date = new Date(),
            twoDigitYearMax = calendar.twoDigitYearMax || 2029,
            defaultYear = date.getFullYear(),
            ch, count, length, pattern,
            pmHour, UTC, ISO8601, matches,
            amDesignators, pmDesignators,
            hoursOffset, minutesOffset,
            hasTime, match;

        if (!format) {
            format = "d"; //shord date format
        }

        //if format is part of the patterns get real format
        pattern = calendar.patterns[format];
        if (pattern) {
            format = pattern;
        }

        format = format.split("");
        length = format.length;

        for (; idx < length; idx++) {
            ch = format[idx];

            if (literal) {
                if (ch === "'") {
                    literal = false;
                } else {
                    checkLiteral();
                }
            } else {
                if (ch === "d") {
                    count = lookAhead("d");
                    if (!calendar._lowerDays) {
                        calendar._lowerDays = lowerLocalInfo(calendar.days);
                    }

                    day = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerDays[count == 3 ? "namesAbbr" : "names"], true);

                    if (day === null || outOfRange(day, 1, 31)) {
                        return null;
                    }
                } else if (ch === "M") {
                    count = lookAhead("M");
                    if (!calendar._lowerMonths) {
                        calendar._lowerMonths = lowerLocalInfo(calendar.months);
                    }
                    month = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerMonths[count == 3 ? 'namesAbbr' : 'names'], true);

                    if (month === null || outOfRange(month, 1, 12)) {
                        return null;
                    }
                    month -= 1; //because month is zero based
                } else if (ch === "y") {
                    count = lookAhead("y");
                    year = getNumber(count);

                    if (year === null) {
                        return null;
                    }

                    if (count == 2) {
                        if (typeof twoDigitYearMax === "string") {
                            twoDigitYearMax = defaultYear + parseInt(twoDigitYearMax, 10);
                        }

                        year = (defaultYear - defaultYear % 100) + year;
                        if (year > twoDigitYearMax) {
                            year -= 100;
                        }
                    }
                } else if (ch === "h" ) {
                    lookAhead("h");
                    hours = getNumber(2);
                    if (hours == 12) {
                        hours = 0;
                    }
                    if (hours === null || outOfRange(hours, 0, 11)) {
                        return null;
                    }
                } else if (ch === "H") {
                    lookAhead("H");
                    hours = getNumber(2);
                    if (hours === null || outOfRange(hours, 0, 23)) {
                        return null;
                    }
                } else if (ch === "m") {
                    lookAhead("m");
                    minutes = getNumber(2);
                    if (minutes === null || outOfRange(minutes, 0, 59)) {
                        return null;
                    }
                } else if (ch === "s") {
                    lookAhead("s");
                    seconds = getNumber(2);
                    if (seconds === null || outOfRange(seconds, 0, 59)) {
                        return null;
                    }
                } else if (ch === "f") {
                    count = lookAhead("f");

                    match = value.substr(valueIdx, count).match(numberRegExp[3]);
                    milliseconds = getNumber(count);

                    if (milliseconds !== null) {
                        match = match[0].length;

                        if (match < 3) {
                            milliseconds *= Math.pow(10, (3 - match));
                        }

                        if (count > 3) {
                            milliseconds = parseInt(milliseconds.toString().substring(0, 3), 10);
                        }
                    }

                    if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
                        return null;
                    }

                } else if (ch === "t") {
                    count = lookAhead("t");
                    amDesignators = calendar.AM;
                    pmDesignators = calendar.PM;

                    if (count === 1) {
                        amDesignators = mapDesignators(amDesignators);
                        pmDesignators = mapDesignators(pmDesignators);
                    }

                    pmHour = getIndexByName(pmDesignators);
                    if (!pmHour && !getIndexByName(amDesignators)) {
                        return null;
                    }
                }
                else if (ch === "z") {
                    UTC = true;
                    count = lookAhead("z");

                    if (value.substr(valueIdx, 1) === "Z") {
                        if (!ISO8601) {
                            return null;
                        }

                        checkLiteral();
                        continue;
                    }

                    matches = value.substr(valueIdx, 6)
                                   .match(count > 2 ? longTimeZoneRegExp : shortTimeZoneRegExp);

                    if (!matches) {
                        return null;
                    }

                    matches = matches[0];
                    valueIdx = matches.length;
                    matches = matches.split(":");

                    hoursOffset = parseInt(matches[0], 10);
                    if (outOfRange(hoursOffset, -12, 13)) {
                        return null;
                    }

                    if (count > 2) {
                        minutesOffset = parseInt(matches[1], 10);
                        if (isNaN(minutesOffset) || outOfRange(minutesOffset, 0, 59)) {
                            return null;
                        }
                    }
                } else if (ch === "T") {
                    ISO8601 = checkLiteral();
                } else if (ch === "'") {
                    literal = true;
                    checkLiteral();
                } else if (!checkLiteral()) {
                    return null;
                }
            }
        }

        hasTime = hours !== null || minutes !== null || seconds || null;

        if (year === null && month === null && day === null && hasTime) {
            year = defaultYear;
            month = date.getMonth();
            day = date.getDate();
        } else {
            if (year === null) {
                year = defaultYear;
            }

            if (day === null) {
                day = 1;
            }
        }

        if (pmHour && hours < 12) {
            hours += 12;
        }

        if (UTC) {
            if (hoursOffset) {
                hours += -hoursOffset;
            }

            if (minutesOffset) {
                minutes += -minutesOffset;
            }

            value = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
        } else {
            value = new Date(year, month, day, hours, minutes, seconds, milliseconds);
            adjustDST(value, hours);
        }

        if (year < 100) {
            value.setFullYear(year);
        }

        if (value.getDate() !== day && UTC === undefined) {
            return null;
        }

        return value;
    }

    function parseMicrosoftFormatOffset(offset) {
        var sign = offset.substr(0, 1) === "-" ? -1 : 1;

        offset = offset.substring(1);
        offset = (parseInt(offset.substr(0, 2), 10) * 60) + parseInt(offset.substring(2), 10);

        return sign * offset;
    }

    kendo.parseDate = function(value, formats, culture) {
        if (objectToString.call(value) === "[object Date]") {
            return value;
        }

        var idx = 0;
        var date = null;
        var length, patterns;
        var tzoffset;
        var sign;

        if (value && value.indexOf("/D") === 0) {
            date = dateRegExp.exec(value);
            if (date) {
                date = date[1];
                tzoffset = offsetRegExp.exec(date.substring(1));

                date = new Date(parseInt(date, 10));

                if (tzoffset) {
                    tzoffset = parseMicrosoftFormatOffset(tzoffset[0]);
                    date = kendo.timezone.apply(date, 0);
                    date = kendo.timezone.convert(date, 0, -1 * tzoffset);
                }

                return date;
            }
        }

        culture = kendo.getCulture(culture);

        if (!formats) {
            formats = [];
            patterns = culture.calendar.patterns;
            length = formatsSequence.length;

            for (; idx < length; idx++) {
                formats[idx] = patterns[formatsSequence[idx]];
            }

            idx = 0;

            formats = [
                "yyyy/MM/dd HH:mm:ss",
                "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd",
                "ddd MMM dd yyyy HH:mm:ss",
                "yyyy-MM-ddTHH:mm:ss.fffffffzzz",
                "yyyy-MM-ddTHH:mm:ss.fffzzz",
                "yyyy-MM-ddTHH:mm:sszzz",
                "yyyy-MM-ddTHH:mmzzz",
                "yyyy-MM-ddTHH:mmzz",
                "yyyy-MM-ddTHH:mm:ss",
                "yyyy-MM-ddTHH:mm",
                "yyyy-MM-dd HH:mm:ss",
                "yyyy-MM-dd HH:mm",
                "yyyy-MM-dd",
                "HH:mm:ss",
                "HH:mm"
            ].concat(formats);
        }

        formats = isArray(formats) ? formats: [formats];
        length = formats.length;

        for (; idx < length; idx++) {
            date = parseExact(value, formats[idx], culture);
            if (date) {
                return date;
            }
        }

        return date;
    };

    kendo.parseInt = function(value, culture) {
        var result = kendo.parseFloat(value, culture);
        if (result) {
            result = result | 0;
        }
        return result;
    };

    kendo.parseFloat = function(value, culture, format) {
        if (!value && value !== 0) {
           return null;
        }

        if (typeof value === NUMBER) {
           return value;
        }

        value = value.toString();
        culture = kendo.getCulture(culture);

        var number = culture.numberFormat,
            percent = number.percent,
            currency = number.currency,
            symbol = currency.symbol,
            percentSymbol = percent.symbol,
            negative = value.indexOf("-"),
            parts, isPercent;

        //handle exponential number
        if (exponentRegExp.test(value)) {
            value = parseFloat(value.replace(number["."], "."));
            if (isNaN(value)) {
                value = null;
            }
            return value;
        }

        if (negative > 0) {
            return null;
        } else {
            negative = negative > -1;
        }

        if (value.indexOf(symbol) > -1 || (format && format.toLowerCase().indexOf("c") > -1)) {
            number = currency;
            parts = number.pattern[0].replace("$", symbol).split("n");
            if (value.indexOf(parts[0]) > -1 && value.indexOf(parts[1]) > -1) {
                value = value.replace(parts[0], "").replace(parts[1], "");
                negative = true;
            }
        } else if (value.indexOf(percentSymbol) > -1) {
            isPercent = true;
            number = percent;
            symbol = percentSymbol;
        }

        value = value.replace("-", "")
                     .replace(symbol, "")
                     .replace(nonBreakingSpaceRegExp, " ")
                     .split(number[","].replace(nonBreakingSpaceRegExp, " ")).join("")
                     .replace(number["."], ".");

        value = parseFloat(value);

        if (isNaN(value)) {
            value = null;
        } else if (negative) {
            value *= -1;
        }

        if (value && isPercent) {
            value /= 100;
        }

        return value;
    };

    if (globalize) {
        kendo.parseDate = function (value, format, culture) {
            if (objectToString.call(value) === "[object Date]") {
                return value;
            }

            return globalize.parseDate(value, format, culture);
        };

        kendo.parseFloat = function (value, culture) {
            if (typeof value === NUMBER) {
                return value;
            }

            if (value === undefined || value === null) {
               return null;
            }

            if ($.isPlainObject(culture)) {
                culture = culture.name;
            }

            value = globalize.parseFloat(value, culture);

            return isNaN(value) ? null : value;
        };
    }
})();

    function getShadows(element) {
        var shadow = element.css(kendo.support.transitions.css + "box-shadow") || element.css("box-shadow"),
            radius = shadow ? shadow.match(boxShadowRegExp) || [ 0, 0, 0, 0, 0 ] : [ 0, 0, 0, 0, 0 ],
            blur = math.max((+radius[3]), +(radius[4] || 0));

        return {
            left: (-radius[1]) + blur,
            right: (+radius[1]) + blur,
            bottom: (+radius[2]) + blur
        };
    }

    function wrap(element, autosize) {
        var browser = support.browser,
            percentage,
            isRtl = element.css("direction") == "rtl";

        if (!element.parent().hasClass("k-animation-container")) {
            var shadows = getShadows(element),
                width = element[0].style.width,
                height = element[0].style.height,
                percentWidth = percentRegExp.test(width),
                percentHeight = percentRegExp.test(height);

            if (browser.opera) { // Box shadow can't be retrieved in Opera
                shadows.left = shadows.right = shadows.bottom = 5;
            }

            percentage = percentWidth || percentHeight;

            if (!percentWidth && (!autosize || (autosize && width))) { width = element.outerWidth(); }
            if (!percentHeight && (!autosize || (autosize && height))) { height = element.outerHeight(); }

            element.wrap(
                         $("<div/>")
                         .addClass("k-animation-container")
                         .css({
                             width: width,
                             height: height,
                             marginLeft: shadows.left * (isRtl ? 1 : -1),
                             paddingLeft: shadows.left,
                             paddingRight: shadows.right,
                             paddingBottom: shadows.bottom
                         }));

            if (percentage) {
                element.css({
                    width: "100%",
                    height: "100%",
                    boxSizing: "border-box",
                    mozBoxSizing: "border-box",
                    webkitBoxSizing: "border-box"
                });
            }
        } else {
            var wrapper = element.parent(".k-animation-container"),
                wrapperStyle = wrapper[0].style;

            if (wrapper.is(":hidden")) {
                wrapper.show();
            }

            percentage = percentRegExp.test(wrapperStyle.width) || percentRegExp.test(wrapperStyle.height);

            if (!percentage) {
                wrapper.css({
                    width: element.outerWidth(),
                    height: element.outerHeight(),
                    boxSizing: "content-box",
                    mozBoxSizing: "content-box",
                    webkitBoxSizing: "content-box"
                });
            }
        }

        if (browser.msie && math.floor(browser.version) <= 7) {
            element.css({ zoom: 1 });
            element.children(".k-menu").width(element.width());
        }

        return element.parent();
    }

    function deepExtend(destination) {
        var i = 1,
            length = arguments.length;

        for (i = 1; i < length; i++) {
            deepExtendOne(destination, arguments[i]);
        }

        return destination;
    }

    function deepExtendOne(destination, source) {
        var ObservableArray = kendo.data.ObservableArray,
            DataSource = kendo.data.DataSource,
            HierarchicalDataSource = kendo.data.HierarchicalDataSource,
            property,
            propValue,
            propType,
            destProp;

        for (property in source) {
            propValue = source[property];
            propType = typeof propValue;
            if (propType === OBJECT && propValue !== null &&
                propValue.constructor !== Array && propValue.constructor !== ObservableArray &&
                propValue.constructor !== DataSource && propValue.constructor !== HierarchicalDataSource) {
                if (propValue instanceof Date) {
                    destination[property] = new Date(propValue.getTime());
                } else if (isFunction(propValue.clone)) {
                    destination[property] = propValue.clone();
                } else {
                    destProp = destination[property];
                    if (typeof (destProp) === OBJECT) {
                        destination[property] = destProp || {};
                    } else {
                        destination[property] = {};
                    }
                    deepExtendOne(destination[property], propValue);
                }
            } else if (propType !== UNDEFINED) {
                destination[property] = propValue;
            }
        }

        return destination;
    }

    function testRx(agent, rxs, dflt) {
        for (var rx in rxs) {
            if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {
                return rx;
            }
        }
        return dflt !== undefined ? dflt : agent;
    }

    function toHyphens(str) {
        return str.replace(/([a-z][A-Z])/g, function (g) {
            return g.charAt(0) + '-' + g.charAt(1).toLowerCase();
        });
    }

    function toCamelCase(str) {
        return str.replace(/\-(\w)/g, function (strMatch, g1) {
            return g1.toUpperCase();
        });
    }

    function getComputedStyles(element, properties) {
        var styles = {}, computedStyle;

        if (document.defaultView && document.defaultView.getComputedStyle) {
            computedStyle = document.defaultView.getComputedStyle(element, "");

            if (properties) {
                $.each(properties, function(idx, value) {
                    styles[value] = computedStyle.getPropertyValue(value);
                });
            }
        } else {
            computedStyle = element.currentStyle;

            if (properties) {
                $.each(properties, function(idx, value) {
                    styles[value] = computedStyle[toCamelCase(value)];
                });
            }
        }

        if (!kendo.size(styles)) {
            styles = computedStyle;
        }

        return styles;
    }

    (function() {
        support.scrollbar = function() {
            var div = document.createElement("div"),
                result;

            div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both";
            div.innerHTML = "&nbsp;";
            document.body.appendChild(div);

            result = div.offsetWidth - div.scrollWidth;

            document.body.removeChild(div);
            return result;
        };

        support.isRtl = function(element) {
            return $(element).closest(".k-rtl").length > 0;
        };

        var table = document.createElement("table");

        // Internet Explorer does not support setting the innerHTML of TBODY and TABLE elements
        try {
            table.innerHTML = "<tr><td></td></tr>";

            support.tbodyInnerHtml = true;
        } catch (e) {
            support.tbodyInnerHtml = false;
        }

        support.touch = "ontouchstart" in window;
        support.msPointers = window.MSPointerEvent;
        support.pointers = window.PointerEvent;

        var transitions = support.transitions = false,
            transforms = support.transforms = false,
            elementProto = "HTMLElement" in window ? HTMLElement.prototype : [];

        support.hasHW3D = ("WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix()) || "MozPerspective" in document.documentElement.style || "msPerspective" in document.documentElement.style;

        each([ "Moz", "webkit", "O", "ms" ], function () {
            var prefix = this.toString(),
                hasTransitions = typeof table.style[prefix + "Transition"] === STRING;

            if (hasTransitions || typeof table.style[prefix + "Transform"] === STRING) {
                var lowPrefix = prefix.toLowerCase();

                transforms = {
                    css: (lowPrefix != "ms") ? "-" + lowPrefix + "-" : "",
                    prefix: prefix,
                    event: (lowPrefix === "o" || lowPrefix === "webkit") ? lowPrefix : ""
                };

                if (hasTransitions) {
                    transitions = transforms;
                    transitions.event = transitions.event ? transitions.event + "TransitionEnd" : "transitionend";
                }

                return false;
            }
        });

        table = null;

        support.transforms = transforms;
        support.transitions = transitions;

        support.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;

        try {
            support.screenWidth = window.outerWidth || window.screen ? window.screen.availWidth : window.innerWidth;
            support.screenHeight = window.outerHeight || window.screen ? window.screen.availHeight : window.innerHeight;
        } catch(e) {
            //window.outerWidth throws error when in IE showModalDialog.
            support.screenWidth = window.screen.availWidth;
            support.screenHeight = window.screen.availHeight;
        }

        support.detectOS = function (ua) {
            var os = false, minorVersion, match = [],
                notAndroidPhone = !/mobile safari/i.test(ua),
                agentRxs = {
                    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
                    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.(\d+(\.\d+)?)/,
                    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
                    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
                    meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
                    webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
                    blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
                    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
                    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
                    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
                    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
                    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
                    ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
                },
                osRxs = {
                    ios: /^i(phone|pad|pod)$/i,
                    android: /^android|fire$/i,
                    blackberry: /^blackberry|playbook/i,
                    windows: /windows/,
                    wp: /wp/,
                    flat: /sailfish|ffos|tizen/i,
                    meego: /meego/
                },
                formFactorRxs = {
                    tablet: /playbook|ipad|fire/i
                },
                browserRxs = {
                    omini: /Opera\sMini/i,
                    omobile: /Opera\sMobi/i,
                    firefox: /Firefox|Fennec/i,
                    mobilesafari: /version\/.*safari/i,
                    chrome: /chrome|crios/i,
                    webkit: /webkit/i,
                    ie: /MSIE|Windows\sPhone/i
                };

            for (var agent in agentRxs) {
                if (agentRxs.hasOwnProperty(agent)) {
                    match = ua.match(agentRxs[agent]);
                    if (match) {
                        if (agent == "windows" && "plugins" in navigator) { return false; } // Break if not Metro/Mobile Windows

                        os = {};
                        os.device = agent;
                        os.tablet = testRx(agent, formFactorRxs, false);
                        os.browser = testRx(ua, browserRxs, "default");
                        os.name = testRx(agent, osRxs);
                        os[os.name] = true;
                        os.majorVersion = match[2];
                        os.minorVersion = match[3].replace("_", ".");
                        minorVersion = os.minorVersion.replace(".", "").substr(0, 2);
                        os.flatVersion = os.majorVersion + minorVersion + (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join("0"));
                        os.cordova = typeof window.PhoneGap !== UNDEFINED || typeof window.cordova !== UNDEFINED; // Use file protocol to detect appModes.
                        os.appMode = window.navigator.standalone || (/file|local|wmapp/).test(window.location.protocol) || os.cordova; // Use file protocol to detect appModes.

                        if (os.android && (support.devicePixelRatio < 1.5 && os.flatVersion < 400 || notAndroidPhone) && (support.screenWidth > 800 || support.screenHeight > 800)) {
                            os.tablet = agent;
                        }

                        break;
                    }
                }
            }
            return os;
        };

        var mobileOS = support.mobileOS = support.detectOS(navigator.userAgent);

        support.wpDevicePixelRatio = mobileOS.wp ? screen.width / 320 : 0;
        support.kineticScrollNeeded = mobileOS && (support.touch || support.msPointers || support.pointers);

        support.hasNativeScrolling = false;

        if (mobileOS.ios || (mobileOS.android && mobileOS.majorVersion > 2) || mobileOS.wp) {
            support.hasNativeScrolling = mobileOS;
        }

        support.mouseAndTouchPresent = support.touch && !(support.mobileOS.ios || support.mobileOS.android);

        support.detectBrowser = function(ua) {
            var browser = false, match = [],
                browserRxs = {
                    webkit: /(chrome)[ \/]([\w.]+)/i,
                    safari: /(webkit)[ \/]([\w.]+)/i,
                    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
                    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
                    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
                };

            for (var agent in browserRxs) {
                if (browserRxs.hasOwnProperty(agent)) {
                    match = ua.match(browserRxs[agent]);
                    if (match) {
                        browser = {};
                        browser[agent] = true;
                        browser[match[1].toLowerCase()] = true;
                        browser.version = parseInt(document.documentMode || match[2], 10);

                        break;
                    }
                }
            }

            return browser;
        };

        support.browser = support.detectBrowser(navigator.userAgent);

        support.zoomLevel = function() {
            try {
                return support.touch ? (document.documentElement.clientWidth / window.innerWidth) :
                       support.browser.msie && support.browser.version >= 10 ? ((top || window).document.documentElement.offsetWidth / (top || window).innerWidth) : 1;
            } catch(e) {
                return 1;
            }
        };

        support.cssBorderSpacing = typeof document.documentElement.style.borderSpacing != "undefined" && !(support.browser.msie && support.browser.version < 8);

        (function(browser) {
            // add browser-specific CSS class
            var cssClass = "",
                docElement = $(document.documentElement),
                majorVersion = parseInt(browser.version, 10);

            if (browser.msie) {
                cssClass = "ie";
            } else if (browser.mozilla) {
                cssClass = "ff";
            } else if (browser.safari) {
                cssClass = "safari";
            } else if (browser.webkit) {
                cssClass = "webkit";
            } else if (browser.opera) {
                cssClass = "opera";
            }

            if (cssClass) {
                cssClass = "k-" + cssClass + " k-" + cssClass + majorVersion;
            }
            if (support.mobileOS) {
                cssClass += " k-mobile";
            }

            docElement.addClass(cssClass);
        })(support.browser);

        support.eventCapture = document.documentElement.addEventListener;

        var input = document.createElement("input");

        support.placeholder = "placeholder" in input;
        support.propertyChangeEvent = "onpropertychange" in input;

        support.input = (function() {
            var types = ["number", "date", "time", "month", "week", "datetime", "datetime-local"];
            var length = types.length;
            var value = "test";
            var result = {};
            var idx = 0;
            var type;

            for (;idx < length; idx++) {
                type = types[idx];
                input.setAttribute("type", type);
                input.value = value;

                result[type.replace("-", "")] = input.type !== "text" && input.value !== value;
            }

            return result;
        })();

        input.style.cssText = "float:left;";

        support.cssFloat = !!input.style.cssFloat;

        input = null;

        support.stableSort = (function() {
            // Chrome sort is not stable for more than *10* items
            // IE9+ sort is not stable for than *512* items
            var threshold = 513;

            var sorted = [{
                index: 0,
                field: "b"
            }];

            for (var i = 1; i < threshold; i++) {
                sorted.push({
                    index: i,
                    field: "a"
                });
            }

            sorted.sort(function(a, b) {
                return a.field > b.field ? 1 : (a.field < b.field ? -1 : 0);
            });

            return sorted[0].index === 1;
        })();

        support.matchesSelector = elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector ||
                                  elementProto.msMatchesSelector || elementProto.oMatchesSelector || elementProto.matchesSelector ||
          function( selector ) {
              var nodeList = document.querySelectorAll ? ( this.parentNode || document ).querySelectorAll( selector ) || [] : $(selector),
                  i = nodeList.length;

              while (i--) {
                  if (nodeList[i] == this) {
                      return true;
                  }
              }

              return false;
          };

        support.pushState = window.history && window.history.pushState;

        var documentMode = document.documentMode;

        support.hashChange = ("onhashchange" in window) && !(support.browser.msie && (!documentMode || documentMode <= 8)); // old IE detection
    })();


    function size(obj) {
        var result = 0, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key) && key != "toJSON") { // Ignore fake IE7 toJSON.
                result++;
            }
        }

        return result;
    }

    function getOffset(element, type, positioned) {
        if (!type) {
            type = "offset";
        }

        var result = element[type](),
            mobileOS = support.mobileOS;

        // IE10 touch zoom is living in a separate viewport
        if (support.browser.msie && (support.pointers || support.msPointers) && !positioned) {
            result.top -= (window.pageYOffset - document.documentElement.scrollTop);
            result.left -= (window.pageXOffset - document.documentElement.scrollLeft);
        }

        return result;
    }

    var directions = {
        left: { reverse: "right" },
        right: { reverse: "left" },
        down: { reverse: "up" },
        up: { reverse: "down" },
        top: { reverse: "bottom" },
        bottom: { reverse: "top" },
        "in": { reverse: "out" },
        out: { reverse: "in" }
    };

    function parseEffects(input) {
        var effects = {};

        each((typeof input === "string" ? input.split(" ") : input), function(idx) {
            effects[idx] = this;
        });

        return effects;
    }

    function fx(element) {
        return new kendo.effects.Element(element);
    }

    var effects = {};

    $.extend(effects, {
        enabled: true,
        Element: function(element) {
            this.element = $(element);
        },

        promise: function(element, options) {
            if (!element.is(":visible")) {
                element.css({ display: element.data("olddisplay") || "block" }).css("display");
            }

            if (options.hide) {
                element.data("olddisplay", element.css("display")).hide();
            }

            if (options.init) {
                options.init();
            }

            if (options.completeCallback) {
                options.completeCallback(element); // call the external complete callback with the element
            }

            element.dequeue();
        },

        disable: function() {
            this.enabled = false;
            this.promise = this.promiseShim;
        },

        enable: function() {
            this.enabled = true;
            this.promise = this.animatedPromise;
        }
    });

    effects.promiseShim = effects.promise;

    function prepareAnimationOptions(options, duration, reverse, complete) {
        if (typeof options === STRING) {
            // options is the list of effect names separated by space e.g. animate(element, "fadeIn slideDown")

            // only callback is provided e.g. animate(element, options, function() {});
            if (isFunction(duration)) {
                complete = duration;
                duration = 400;
                reverse = false;
            }

            if (isFunction(reverse)) {
                complete = reverse;
                reverse = false;
            }

            if (typeof duration === BOOLEAN){
                reverse = duration;
                duration = 400;
            }

            options = {
                effects: options,
                duration: duration,
                reverse: reverse,
                complete: complete
            };
        }

        return extend({
            //default options
            effects: {},
            duration: 400, //jQuery default duration
            reverse: false,
            init: noop,
            teardown: noop,
            hide: false
        }, options, { completeCallback: options.complete, complete: noop }); // Move external complete callback, so deferred.resolve can be always executed.

    }

    function animate(element, options, duration, reverse, complete) {
        var idx = 0,
            length = element.length,
            instance;

        for (; idx < length; idx ++) {
            instance = $(element[idx]);
            instance.queue(function() {
                effects.promise(instance, prepareAnimationOptions(options, duration, reverse, complete));
            });
        }

        return element;
    }

    function toggleClass(element, classes, options, add) {
        if (classes) {
            classes = classes.split(" ");

            each(classes, function(idx, value) {
                element.toggleClass(value, add);
            });
        }

        return element;
    }

    if (!("kendoAnimate" in $.fn)) {
        extend($.fn, {
            kendoStop: function(clearQueue, gotoEnd) {
                return this.stop(clearQueue, gotoEnd);
            },

            kendoAnimate: function(options, duration, reverse, complete) {
                return animate(this, options, duration, reverse, complete);
            },

            kendoAddClass: function(classes, options){
                return kendo.toggleClass(this, classes, options, true);
            },

            kendoRemoveClass: function(classes, options){
                return kendo.toggleClass(this, classes, options, false);
            },
            kendoToggleClass: function(classes, options, toggle){
                return kendo.toggleClass(this, classes, options, toggle);
            }
        });
    }

    var ampRegExp = /&/g,
        ltRegExp = /</g,
        quoteRegExp = /"/g,
        aposRegExp = /'/g,
        gtRegExp = />/g;
    function htmlEncode(value) {
        return ("" + value).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
    }

    var eventTarget = function (e) {
        return e.target;
    };

    if (support.touch) {

        eventTarget = function(e) {
            var touches = "originalEvent" in e ? e.originalEvent.changedTouches : "changedTouches" in e ? e.changedTouches : null;

            return touches ? document.elementFromPoint(touches[0].clientX, touches[0].clientY) : e.target;
        };

        each(["swipe", "swipeLeft", "swipeRight", "swipeUp", "swipeDown", "doubleTap", "tap"], function(m, value) {
            $.fn[value] = function(callback) {
                return this.bind(value, callback);
            };
        });
    }

    if (support.touch) {
        if (!support.mobileOS) {
            support.mousedown = "mousedown touchstart";
            support.mouseup = "mouseup touchend";
            support.mousemove = "mousemove touchmove";
            support.mousecancel = "mouseleave touchcancel";
            support.click = "click";
            support.resize = "resize";
        } else {
            support.mousedown = "touchstart";
            support.mouseup = "touchend";
            support.mousemove = "touchmove";
            support.mousecancel = "touchcancel";
            support.click = "touchend";
            support.resize = "orientationchange";
        }
    } else if (support.pointers) {
        support.mousemove = "pointermove";
        support.mousedown = "pointerdown";
        support.mouseup = "pointerup";
        support.mousecancel = "pointercancel";
        support.click = "pointerup";
        support.resize = "orientationchange resize";
    } else if (support.msPointers) {
        support.mousemove = "MSPointerMove";
        support.mousedown = "MSPointerDown";
        support.mouseup = "MSPointerUp";
        support.mousecancel = "MSPointerCancel";
        support.click = "MSPointerUp";
        support.resize = "orientationchange resize";
    } else {
        support.mousemove = "mousemove";
        support.mousedown = "mousedown";
        support.mouseup = "mouseup";
        support.mousecancel = "mouseleave";
        support.click = "click";
        support.resize = "resize";
    }

    var wrapExpression = function(members, paramName) {
        var result = paramName || "d",
            index,
            idx,
            length,
            member,
            count = 1;

        for (idx = 0, length = members.length; idx < length; idx++) {
            member = members[idx];
            if (member !== "") {
                index = member.indexOf("[");

                if (index !== 0) {
                    if (index == -1) {
                        member = "." + member;
                    } else {
                        count++;
                        member = "." + member.substring(0, index) + " || {})" + member.substring(index);
                    }
                }

                count++;
                result += member + ((idx < length - 1) ? " || {})" : ")");
            }
        }
        return new Array(count).join("(") + result;
    },
    localUrlRe = /^([a-z]+:)?\/\//i;

    extend(kendo, {
        ui: kendo.ui || {},
        fx: kendo.fx || fx,
        effects: kendo.effects || effects,
        mobile: kendo.mobile || { },
        data: kendo.data || {},
        dataviz: kendo.dataviz || {ui: { roles: {}}},
        keys: {
            INSERT: 45,
            DELETE: 46,
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            END: 35,
            HOME: 36,
            SPACEBAR: 32,
            PAGEUP: 33,
            PAGEDOWN: 34,
            F2: 113,
            F10: 121,
            F12: 123,
            NUMPAD_PLUS: 107,
            NUMPAD_MINUS: 109,
            NUMPAD_DOT: 110
        },
        support: kendo.support || support,
        animate: kendo.animate || animate,
        ns: "",
        attr: function(value) {
            return "data-" + kendo.ns + value;
        },
        getShadows: getShadows,
        wrap: wrap,
        deepExtend: deepExtend,
        getComputedStyles: getComputedStyles,
        size: size,
        toCamelCase: toCamelCase,
        toHyphens: toHyphens,
        getOffset: kendo.getOffset || getOffset,
        parseEffects: kendo.parseEffects || parseEffects,
        toggleClass: kendo.toggleClass || toggleClass,
        directions: kendo.directions || directions,
        Observable: Observable,
        Class: Class,
        Template: Template,
        template: proxy(Template.compile, Template),
        render: proxy(Template.render, Template),
        stringify: proxy(JSON.stringify, JSON),
        eventTarget: eventTarget,
        htmlEncode: htmlEncode,
        isLocalUrl: function(url) {
            return url && !localUrlRe.test(url);
        },

        expr: function(expression, safe, paramName) {
            expression = expression || "";

            if (typeof safe == STRING) {
                paramName = safe;
                safe = false;
            }

            paramName = paramName || "d";

            if (expression && expression.charAt(0) !== "[") {
                expression = "." + expression;
            }

            if (safe) {
                expression = wrapExpression(expression.split("."), paramName);
            } else {
                expression = paramName + expression;
            }

            return expression;
        },

        getter: function(expression, safe) {
            return getterCache[expression] = getterCache[expression] || new Function("d", "return " + kendo.expr(expression, safe));
        },

        setter: function(expression) {
            return setterCache[expression] = setterCache[expression] || new Function("d,value", kendo.expr(expression) + "=value");
        },

        accessor: function(expression) {
            return {
                get: kendo.getter(expression),
                set: kendo.setter(expression)
            };
        },

        guid: function() {
            var id = "", i, random;

            for (i = 0; i < 32; i++) {
                random = math.random() * 16 | 0;

                if (i == 8 || i == 12 || i == 16 || i == 20) {
                    id += "-";
                }
                id += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
            }

            return id;
        },

        roleSelector: function(role) {
            return role.replace(/(\S+)/g, "[" + kendo.attr("role") + "=$1],").slice(0, -1);
        },

        triggeredByInput: function(e) {
            return (/^(label|input|textarea|select)$/i).test(e.target.tagName);
        },

        logToConsole: function(message) {
            var console = window.console;

            if (typeof(console) != "undefined" && console.log) {
                console.log(message);
            }
        }
    });

    var Widget = Observable.extend( {
        init: function(element, options) {
            var that = this;

            that.element = kendo.jQuery(element).handler(that);

            Observable.fn.init.call(that);

            options = that.options = extend(true, {}, that.options, options);

            if (!that.element.attr(kendo.attr("role"))) {
                that.element.attr(kendo.attr("role"), (options.name || "").toLowerCase());
            }

            that.element.data("kendo" + options.prefix + options.name, that);

            that.bind(that.events, options);
        },

        events: [],

        options: {
            prefix: ""
        },

        _hasBindingTarget: function() {
            return !!this.element[0].kendoBindingTarget;
        },

        _tabindex: function(target) {
            target = target || this.wrapper;

            var element = this.element,
                TABINDEX = "tabindex",
                tabindex = target.attr(TABINDEX) || element.attr(TABINDEX);

            element.removeAttr(TABINDEX);

            target.attr(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
        },

        setOptions: function(options) {
            this._setEvents(options);
            $.extend(this.options, options);
        },

        _setEvents: function(options) {
            var that = this,
                idx = 0,
                length = that.events.length,
                e;

            for (; idx < length; idx ++) {
                e = that.events[idx];
                if (that.options[e] && options[e]) {
                    that.unbind(e, that.options[e]);
                }
            }

            that.bind(that.events, options);
        },

        resize: function(force) {
            var size = this.getSize(),
                currentSize = this._size;

            if (force || !currentSize || size.width !== currentSize.width || size.height !== currentSize.height) {
                this._resize(size);
                this.trigger("resize", size);
                this._size = size;
            }
        },

        getSize: function() {
            return kendo.dimensions(this.element);
        },

        size: function(size) {
            if (!size) {
                return this.getSize();
            } else {
                this.setSize(size);
            }
        },

        setSize: $.noop,
        _resize: $.noop,

        destroy: function() {
            var that = this;

            that.element.removeData("kendo" + that.options.prefix + that.options.name);
            that.element.removeData("handler");
            that.unbind();
        }
    });

    kendo.dimensions = function(element, dimensions) {
        var domElement = element[0];

        if (dimensions) {
            element.css(dimensions);
        }

        return { width: domElement.offsetWidth, height: domElement.offsetHeight };
    };

    kendo.notify = noop;

    var templateRegExp = /template$/i,
        jsonRegExp = /^\s*(?:\{(?:.|\r\n|\n)*\}|\[(?:.|\r\n|\n)*\])\s*$/,
        jsonFormatRegExp = /^\{(\d+)(:[^\}]+)?\}|^\[[A-Za-z_]*\]$/,
        dashRegExp = /([A-Z])/g;

    function parseOption(element, option) {
        var value;

        if (option.indexOf("data") === 0) {
            option = option.substring(4);
            option = option.charAt(0).toLowerCase() + option.substring(1);
        }

        option = option.replace(dashRegExp, "-$1");
        value = element.getAttribute("data-" + kendo.ns + option);

        if (value === null) {
            value = undefined;
        } else if (value === "null") {
            value = null;
        } else if (value === "true") {
            value = true;
        } else if (value === "false") {
            value = false;
        } else if (numberRegExp.test(value)) {
            value = parseFloat(value);
        } else if (jsonRegExp.test(value) && !jsonFormatRegExp.test(value)) {
            value = new Function("return (" + value + ")")();
        }

        return value;
    }

    function parseOptions(element, options) {
        var result = {},
            option,
            value;

        for (option in options) {
            value = parseOption(element, option);

            if (value !== undefined) {

                if (templateRegExp.test(option)) {
                    value = kendo.template($("#" + value).html());
                }

                result[option] = value;
            }
        }

        return result;
    }

    kendo.initWidget = function(element, options, roles) {
        var result,
            option,
            widget,
            idx,
            length,
            role,
            value,
            dataSource;

        // Preserve backwards compatibility with (element, options, namespace) signature, where namespace was kendo.ui
        if (!roles) {
            roles = kendo.ui.roles;
        } else if (roles.roles) {
            roles = roles.roles;
        }

        element = element.nodeType ? element : element[0];

        role = element.getAttribute("data-" + kendo.ns + "role");

        if (!role) {
            return;
        }

        if (role.indexOf(".") === -1) {
            widget = roles[role];
        } else { // full namespace path - like kendo.ui.Widget
            widget = kendo.getter(role)(window);
        }

        if (!widget) {
            return;
        }

        dataSource = parseOption(element, "dataSource");

        options = $.extend({}, parseOptions(element, widget.fn.options), options);

        if (dataSource) {
            if (typeof dataSource === STRING) {
                options.dataSource = kendo.getter(dataSource)(window);
            } else {
                options.dataSource = dataSource;
            }
        }

        for (idx = 0, length = widget.fn.events.length; idx < length; idx++) {
            option = widget.fn.events[idx];

            value = parseOption(element, option);

            if (value !== undefined) {
                options[option] = kendo.getter(value)(window);
            }
        }

        result = $(element).data("kendo" + widget.fn.options.prefix + widget.fn.options.name);

        if (!result) {
            result = new widget(element, options);
        } else {
            result.setOptions(options);
        }

        return result;
    };

    kendo.rolesFromNamespaces = function(namespaces) {
        var roles = [],
            idx,
            length;

        if (!namespaces[0]) {
            namespaces = [kendo.ui, kendo.dataviz.ui];
        }

        for (idx = 0, length = namespaces.length; idx < length; idx ++) {
            roles[idx] = namespaces[idx].roles;
        }

        return extend.apply(null, [{}].concat(roles.reverse()));
    };

    kendo.init = function(element) {
        var roles = kendo.rolesFromNamespaces(slice.call(arguments, 1));

        $(element).find("[data-" + kendo.ns + "role]").addBack().each(function(){
            kendo.initWidget(this, {}, roles);
        });
    };

    kendo.destroy = function(element) {
        $(element).find("[data-" + kendo.ns + "role]").addBack().each(function(){
            var widget = kendo.widgetInstance($(this));

            if (widget) {
                widget.destroy();
            }
        });
    };

    function containmentComparer(a, b) {
        return $.contains(a, b) ? -1 : 1;
    }

    function resizableWidget() {
        var widget = $(this);
        return ($.inArray(widget.attr("data-role"), ["slider", "rangeslider"]) > 0) || widget.is(":visible");
    }

    kendo.resize = function(element) {
        var widgets = $(element).find("[data-" + kendo.ns + "role]").addBack().filter(resizableWidget);

        if (!widgets.length) {
            return;
        }

        // sort widgets based on their parent-child relation
        var widgetsArray = $.makeArray(widgets);
        widgetsArray.sort(containmentComparer);

        // resize widgets
        $.each(widgetsArray, function () {
            var widget = kendo.widgetInstance($(this));
            if (widget) {
                widget.resize();
            }
        });
    };

    kendo.parseOptions = parseOptions;

    extend(kendo.ui, {
        Widget: Widget,
        roles: {},
        progress: function(container, toggle) {
            var mask = container.find(".k-loading-mask"),
                support = kendo.support,
                browser = support.browser,
                isRtl, leftRight, webkitCorrection, containerScrollLeft;

            if (toggle) {
                if (!mask.length) {
                    isRtl = support.isRtl(container);
                    leftRight = isRtl ? "right" : "left";
                    containerScrollLeft = container.scrollLeft();
                    webkitCorrection = browser.webkit ? (!isRtl ? 0 : container[0].scrollWidth - container.width() - 2 * containerScrollLeft) : 0;

                    mask = $("<div class='k-loading-mask'><span class='k-loading-text'>Loading...</span><div class='k-loading-image'/><div class='k-loading-color'/></div>")
                        .width("100%").height("100%")
                        .css("top", container.scrollTop())
                        .css(leftRight, Math.abs(containerScrollLeft) + webkitCorrection)
                        .prependTo(container);
                }
            } else if (mask) {
                mask.remove();
            }
        },
        plugin: function(widget, register, prefix) {
            var name = widget.fn.options.name,
                getter;

            register = register || kendo.ui;
            prefix = prefix || "";

            register[name] = widget;

            register.roles[name.toLowerCase()] = widget;

            getter = "getKendo" + prefix + name;
            name = "kendo" + prefix + name;

            $.fn[name] = function(options) {
                var value = this,
                    args;

                if (typeof options === STRING) {
                    args = slice.call(arguments, 1);

                    this.each(function(){
                        var widget = $.data(this, name),
                            method,
                            result;

                        if (!widget) {
                            throw new Error(kendo.format("Cannot call method '{0}' of {1} before it is initialized", options, name));
                        }

                        method = widget[options];

                        if (typeof method !== FUNCTION) {
                            throw new Error(kendo.format("Cannot find method '{0}' of {1}", options, name));
                        }

                        result = method.apply(widget, args);

                        if (result !== undefined) {
                            value = result;
                            return false;
                        }
                    });
                } else {
                    this.each(function() {
                        new widget(this, options);
                    });
                }

                return value;
            };

            $.fn[getter] = function() {
                return this.data(name);
            };
        }
    });

    var ContainerNullObject = { bind: function () { return this; }, nullObject: true };

    var MobileWidget = Widget.extend({
        init: function(element, options) {
            Widget.fn.init.call(this, element, options);
            this.element.autoApplyNS();
            this.wrapper = this.element;
            this.element.addClass("km-widget");
        },

        destroy: function() {
            Widget.fn.destroy.call(this);
            this.element.kendoDestroy();
        },

        options: {
            prefix: "Mobile"
        },

        events: [],

        view: function() {
            var viewElement = this.element.closest(kendo.roleSelector("view splitview modalview drawer"));
            return kendo.widgetInstance(viewElement, kendo.mobile.ui) || ContainerNullObject;
        },

        viewHasNativeScrolling: function() {
            var view = this.view();
            return view && view.options.useNativeScrolling;
        },

        container: function() {
            var element = this.element.closest(kendo.roleSelector("view layout modalview drawer"));
            return kendo.widgetInstance(element, kendo.mobile.ui) || ContainerNullObject;
        }
    });

    extend(kendo.mobile, {
        init: function(element) {
            kendo.init(element, kendo.mobile.ui, kendo.ui, kendo.dataviz.ui);
        },

        appLevelNativeScrolling: function() {
            return kendo.mobile.application && kendo.mobile.application.options && kendo.mobile.application.options.useNativeScrolling;
        },

        ui: {
            Widget: MobileWidget,
            roles: {},
            plugin: function(widget) {
                kendo.ui.plugin(widget, kendo.mobile.ui, "Mobile");
            }
        }
    });

    kendo.touchScroller = function(elements, options) {
        // return the first touch scroller
        return $(elements).map(function(idx, element) {
            element = $(element);
            if (support.kineticScrollNeeded && kendo.mobile.ui.Scroller && !element.data("kendoMobileScroller")) {
                element.kendoMobileScroller(options);
                return element.data("kendoMobileScroller");
            } else {
                return false;
            }
        })[0];
    };

    kendo.preventDefault = function(e) {
        e.preventDefault();
    };

    kendo.widgetInstance = function(element, suites) {
        var role = element.data(kendo.ns + "role"),
            widgets = [], i, length;

        if (role) {
            // HACK!!! mobile view scroller widgets are instantiated on data-role="content" elements. We need to discover them when resizing.
            if (role === "content") {
                role = "scroller";
            }

            if (suites) {
                if (suites[0]) {
                    for (i = 0, length = suites.length; i < length; i ++) {
                        widgets.push(suites[i].roles[role]);
                    }
                } else {
                    widgets.push(suites.roles[role]);
                }
            }
            else {
                widgets = [ kendo.ui.roles[role], kendo.dataviz.ui.roles[role],  kendo.mobile.ui.roles[role] ];
            }

            if (role.indexOf(".") >= 0) {
                widgets = [ kendo.getter(role)(window) ];
            }

            for (i = 0, length = widgets.length; i < length; i ++) {
                var widget = widgets[i];
                if (widget) {
                    var instance = element.data("kendo" + widget.fn.options.prefix + widget.fn.options.name);
                    if (instance) {
                        return instance;
                    }
                }
            }
        }
    };

    kendo.onResize = function(callback) {
        var handler = callback;
        if (support.mobileOS.android) {
            handler = function() { setTimeout(callback, 600); };
        }

        $(window).on(support.resize, handler);
        return handler;
    };

    kendo.unbindResize = function(callback) {
        $(window).off(support.resize, callback);
    };

    kendo.attrValue = function(element, key) {
        return element.data(kendo.ns + key);
    };

    kendo.days = {
        Sunday: 0,
        Monday: 1,
        Tuesday: 2,
        Wednesday: 3,
        Thursday: 4,
        Friday: 5,
        Saturday: 6
    };

    function focusable(element, isTabIndexNotNaN) {
        var nodeName = element.nodeName.toLowerCase();

        return (/input|select|textarea|button|object/.test(nodeName) ?
                !element.disabled :
                "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN
               ) &&
            visible(element);
    }

    function visible(element) {
        return !$(element).parents().addBack().filter(function() {
            return $.css(this,"visibility") === "hidden" || $.expr.filters.hidden(this);
        }).length;
    }

    $.extend($.expr[ ":" ], {
        kendoFocusable: function(element) {
            var idx = $.attr(element, "tabindex");
            return focusable(element, !isNaN(idx) && idx > -1);
        }
    });

    var MOUSE_EVENTS = ["mousedown", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "mouseup", "click"];
    var EXCLUDE_BUST_CLICK_SELECTOR = "label, input, [data-rel=external]";

    var MouseEventNormalizer = {
        setupMouseMute: function() {
            var idx = 0,
                length = MOUSE_EVENTS.length,
                element = document.documentElement;

            if (MouseEventNormalizer.mouseTrap || !support.eventCapture) {
                return;
            }

            MouseEventNormalizer.mouseTrap = true;

            MouseEventNormalizer.bustClick = false;
            MouseEventNormalizer.captureMouse = false;

            var handler = function(e) {
                if (MouseEventNormalizer.captureMouse) {
                    if (e.type === "click") {
                        if (MouseEventNormalizer.bustClick && !$(e.target).is(EXCLUDE_BUST_CLICK_SELECTOR)) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    } else {
                        e.stopPropagation();
                    }
                }
            };

            for (; idx < length; idx++) {
                element.addEventListener(MOUSE_EVENTS[idx], handler, true);
            }
        },

        muteMouse: function(e) {
            MouseEventNormalizer.captureMouse = true;
            if (e.data.bustClick) {
                MouseEventNormalizer.bustClick = true;
            }
            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);
        },

        unMuteMouse: function() {
            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);
            MouseEventNormalizer.mouseTrapTimeoutID = setTimeout(function() {
                MouseEventNormalizer.captureMouse = false;
                MouseEventNormalizer.bustClick = false;
            }, 400);
        }
    };

    var eventMap = {
        down: "touchstart mousedown",
        move: "mousemove touchmove",
        up: "mouseup touchend touchcancel",
        cancel: "mouseleave touchcancel"
    };

    if (support.touch && (support.mobileOS.ios || support.mobileOS.android)) {
        eventMap = {
            down: "touchstart",
            move: "touchmove",
            up: "touchend touchcancel",
            cancel: "touchcancel"
        };
    } else if (support.pointers) {
        eventMap = {
            down: "pointerdown",
            move: "pointermove",
            up: "pointerup",
            cancel: "pointercancel pointerleave"
        };
    } else if (support.msPointers) {
        eventMap = {
            down: "MSPointerDown",
            move: "MSPointerMove",
            up: "MSPointerUp",
            cancel: "MSPointerCancel MSPointerLeave"
        };
    }

    if (support.msPointers && !("onmspointerenter" in window)) { // IE10
        // Create MSPointerEnter/MSPointerLeave events using mouseover/out and event-time checks
        $.each({
            MSPointerEnter: "MSPointerOver",
            MSPointerLeave: "MSPointerOut"
        }, function( orig, fix ) {
            $.event.special[ orig ] = {
                delegateType: fix,
                bindType: fix,

                handle: function( event ) {
                    var ret,
                        target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;

                    // For mousenter/leave call the handler if related is outside the target.
                    // NB: No relatedTarget if the mouse left/entered the browser window
                    if ( !related || (related !== target && !$.contains( target, related )) ) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply( this, arguments );
                        event.type = fix;
                    }
                    return ret;
                }
            };
        });
    }


    var getEventMap = function(e) { return (eventMap[e] || e); },
        eventRegEx = /([^ ]+)/g;

    kendo.applyEventMap = function(events, ns) {
        events = events.replace(eventRegEx, getEventMap);

        if (ns) {
            events = events.replace(eventRegEx, "$1." + ns);
        }

        return events;
    };

    var on = $.fn.on;

    function kendoJQuery(selector, context) {
        return new kendoJQuery.fn.init(selector, context);
    }

    extend(true, kendoJQuery, $);

    kendoJQuery.fn = kendoJQuery.prototype = new $();

    kendoJQuery.fn.constructor = kendoJQuery;

    kendoJQuery.fn.init = function(selector, context) {
        if (context && context instanceof $ && !(context instanceof kendoJQuery)) {
            context = kendoJQuery(context);
        }

        return $.fn.init.call(this, selector, context, rootjQuery);
    };

    kendoJQuery.fn.init.prototype = kendoJQuery.fn;

    var rootjQuery = kendoJQuery(document);

    extend(kendoJQuery.fn, {
        handler: function(handler) {
            this.data("handler", handler);
            return this;
        },

        autoApplyNS: function(ns) {
            this.data("kendoNS", ns || kendo.guid());
            return this;
        },

        on: function() {
            var that = this,
                ns = that.data("kendoNS");

            // support for event map signature
            if (arguments.length === 1) {
                return on.call(that, arguments[0]);
            }

            var context = that,
                args = slice.call(arguments);

            if (typeof args[args.length -1] === UNDEFINED) {
                args.pop();
            }

            var callback =  args[args.length - 1],
                events = kendo.applyEventMap(args[0], ns);

            // setup mouse trap
            if (support.mouseAndTouchPresent && events.search(/mouse|click/) > -1 && this[0] !== document.documentElement) {
                MouseEventNormalizer.setupMouseMute();

                var selector = args.length === 2 ? null : args[1],
                    bustClick = events.indexOf("click") > -1 && events.indexOf("touchend") > -1;

                on.call(this,
                    {
                        touchstart: MouseEventNormalizer.muteMouse,
                        touchend: MouseEventNormalizer.unMuteMouse
                    },
                    selector,
                    {
                        bustClick: bustClick
                    });
            }

            if (typeof callback === STRING) {
                context = that.data("handler");
                callback = context[callback];

                args[args.length - 1] = function(e) {
                    callback.call(context, e);
                };
            }

            args[0] = events;

            on.apply(that, args);

            return that;
        },

        kendoDestroy: function(ns) {
            ns = ns || this.data("kendoNS");

            if (ns) {
                this.off("." + ns);
            }

            return this;
        }
    });

    kendo.jQuery = kendoJQuery;
    kendo.eventMap = eventMap;

    kendo.timezone = (function(){
        var months =  { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };
        var days = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };

        function ruleToDate(year, rule) {
            var date;
            var targetDay;
            var ourDay;
            var month = rule[3];
            var on = rule[4];
            var time = rule[5];
            var cache = rule[8];

            if (!cache) {
                rule[8] = cache = {};
            }

            if (cache[year]) {
                return cache[year];
            }

            if (!isNaN(on)) {
                date = new Date(Date.UTC(year, months[month], on, time[0], time[1], time[2], 0));
            } else if (on.indexOf("last") === 0) {
                date = new Date(Date.UTC(year, months[month] + 1, 1, time[0] - 24, time[1], time[2], 0));

                targetDay = days[on.substr(4, 3)];
                ourDay = date.getUTCDay();

                date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));
            } else if (on.indexOf(">=") >= 0) {
                date = new Date(Date.UTC(year, months[month], on.substr(5), time[0], time[1], time[2], 0));

                targetDay = days[on.substr(0, 3)];
                ourDay = date.getUTCDay();

                date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));
            }

            return cache[year] = date;
        }

        function findRule(utcTime, rules, zone) {
            rules = rules[zone];

            if (!rules) {
                var time = zone.split(":");
                var offset = 0;

                if (time.length > 1) {
                    offset = time[0] * 60 + Number(time[1]);
                }

                return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];
            }

            var year = new Date(utcTime).getUTCFullYear();

            rules = jQuery.grep(rules, function(rule) {
                var from = rule[0];
                var to = rule[1];

                return from <= year && (to >= year || (from == year && to == "only") || to == "max");
            });

            rules.push(utcTime);

            rules.sort(function(a, b) {
                if (typeof a != "number") {
                    a = Number(ruleToDate(year, a));
                }

                if (typeof b != "number") {
                    b = Number(ruleToDate(year, b));
                }

                return a - b;
            });

            var rule = rules[jQuery.inArray(utcTime, rules) - 1] || rules[rules.length - 1];

            return isNaN(rule) ? rule : null;
        }

        function findZone(utcTime, zones, timezone) {
            var zoneRules = zones[timezone];

            if (typeof zoneRules === "string") {
                zoneRules = zones[zoneRules];
            }

            if (!zoneRules) {
                throw new Error('Timezone "' + timezone + '" is either incorrect, or kendo.timezones.min.js is not included.');
            }

            for (var idx = zoneRules.length - 1; idx >= 0; idx--) {
                var until = zoneRules[idx][3];

                if (until && utcTime > until) {
                    break;
                }
            }

            var zone = zoneRules[idx + 1];

            if (!zone) {
                throw new Error('Timezone "' + timezone + '" not found on ' + utcTime + ".");
            }

            return zone;
        }

        function zoneAndRule(utcTime, zones, rules, timezone) {
            if (typeof utcTime != NUMBER) {
                utcTime = Date.UTC(utcTime.getFullYear(), utcTime.getMonth(),
                    utcTime.getDate(), utcTime.getHours(), utcTime.getMinutes(),
                    utcTime.getSeconds(), utcTime.getMilliseconds());
            }

            var zone = findZone(utcTime, zones, timezone);

            return {
                zone: zone,
                rule: findRule(utcTime, rules, zone[1])
            };
        }

        function offset(utcTime, timezone) {
            if (timezone == "Etc/UTC" || timezone == "Etc/GMT") {
                return 0;
            }

            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);
            var zone = info.zone;
            var rule = info.rule;

            return rule? zone[0] - rule[6] : zone[0];
        }

        function abbr(utcTime, timezone) {
            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);
            var zone = info.zone;
            var rule = info.rule;

            var base = zone[2];

            if (base.indexOf("/") >= 0) {
                return base.split("/")[rule && +rule[6] ? 1 : 0];
            } else if (base.indexOf("%s") >= 0) {
                return base.replace("%s", (!rule || rule[7] == "-") ? '' : rule[7]);
            }

            return base;
        }

        function convert(date, fromOffset, toOffset) {
            if (typeof fromOffset == STRING) {
                fromOffset = this.offset(date, fromOffset);
            }

            if (typeof toOffset == STRING) {
                toOffset = this.offset(date, toOffset);
            }

            var fromLocalOffset = date.getTimezoneOffset();

            date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);

            var toLocalOffset = date.getTimezoneOffset();

            return new Date(date.getTime() + (toLocalOffset - fromLocalOffset) * 60000);
        }

        function apply(date, timezone) {
           return this.convert(date, date.getTimezoneOffset(), timezone);
        }

        function remove(date, timezone) {
           return this.convert(date, timezone, date.getTimezoneOffset());
        }

        function toLocalDate(time) {
            return this.apply(new Date(time), "Etc/UTC");
        }

        return {
           zones: {},
           rules: {},
           offset: offset,
           convert: convert,
           apply: apply,
           remove: remove,
           abbr: abbr,
           toLocalDate: toLocalDate
        };
    })();

    kendo.date = (function(){
        var MS_PER_MINUTE = 60000,
            MS_PER_DAY = 86400000;

        function adjustDST(date, hours) {
            if (hours === 0 && date.getHours() === 23) {
                date.setHours(date.getHours() + 2);
                return true;
            }

            return false;
        }

        function setDayOfWeek(date, day, dir) {
            var hours = date.getHours();

            dir = dir || 1;
            day = ((day - date.getDay()) + (7 * dir)) % 7;

            date.setDate(date.getDate() + day);
            adjustDST(date, hours);
        }

        function dayOfWeek(date, day, dir) {
            date = new Date(date);
            setDayOfWeek(date, day, dir);
            return date;
        }

        function firstDayOfMonth(date) {
            return new Date(
                date.getFullYear(),
                date.getMonth(),
                1
            );
        }

        function lastDayOfMonth(date) {
            var last = new Date(date.getFullYear(), date.getMonth() + 1, 0),
                first = firstDayOfMonth(date),
                timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());

            if (timeOffset) {
                last.setHours(first.getHours() + (timeOffset / 60));
            }

            return last;
        }

        function getDate(date) {
            date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
            adjustDST(date, 0);
            return date;
        }

        function toUtcTime(date) {
            return Date.UTC(date.getFullYear(), date.getMonth(),
                        date.getDate(), date.getHours(), date.getMinutes(),
                        date.getSeconds(), date.getMilliseconds());
        }

        function getMilliseconds(date) {
            return date.getTime() - getDate(date);
        }

        function isInTimeRange(value, min, max) {
            var msMin = getMilliseconds(min),
                msMax = getMilliseconds(max),
                msValue;

            if (!value || msMin == msMax) {
                return true;
            }

            if (min >= max) {
                max += MS_PER_DAY;
            }

            msValue = getMilliseconds(value);

            if (msMin > msValue) {
                msValue += MS_PER_DAY;
            }

            if (msMax < msMin) {
                msMax += MS_PER_DAY;
            }

            return msValue >= msMin && msValue <= msMax;
        }

        function isInDateRange(value, min, max) {
            var msMin = min.getTime(),
                msMax = max.getTime(),
                msValue;

            if (msMin >= msMax) {
                msMax += MS_PER_DAY;
            }

            msValue = value.getTime();

            return msValue >= msMin && msValue <= msMax;
        }

        function addDays(date, offset) {
            var hours = date.getHours();
                date = new Date(date);

            setTime(date, offset * MS_PER_DAY);
            adjustDST(date, hours);
            return date;
        }

        function setTime(date, milliseconds, ignoreDST) {
            var offset = date.getTimezoneOffset();
            var difference;

            date.setTime(date.getTime() + milliseconds);

            if (!ignoreDST) {
                difference = date.getTimezoneOffset() - offset;
                date.setTime(date.getTime() + difference * MS_PER_MINUTE);
            }
        }

        function today() {
            return getDate(new Date());
        }

        function isToday(date) {
           return getDate(date).getTime() == today().getTime();
        }

        function toInvariantTime(date) {
            var staticDate = new Date(1980, 1, 1, 0, 0, 0);

            if (date) {
                staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
            }

            return staticDate;
        }

        return {
            adjustDST: adjustDST,
            dayOfWeek: dayOfWeek,
            setDayOfWeek: setDayOfWeek,
            getDate: getDate,
            isInDateRange: isInDateRange,
            isInTimeRange: isInTimeRange,
            isToday: isToday,
            nextDay: function(date) {
                return addDays(date, 1);
            },
            previousDay: function(date) {
                return addDays(date, -1);
            },
            toUtcTime: toUtcTime,
            MS_PER_DAY: MS_PER_DAY,
            MS_PER_HOUR: 60 * MS_PER_MINUTE,
            MS_PER_MINUTE: MS_PER_MINUTE,
            setTime: setTime,
            addDays: addDays,
            today: today,
            toInvariantTime: toInvariantTime,
            firstDayOfMonth: firstDayOfMonth,
            lastDayOfMonth: lastDayOfMonth,
            getMilliseconds: getMilliseconds
            //TODO methods: combine date portion and time portion from arguments - date1, date 2
        };
    })();


    kendo.stripWhitespace = function(element) {
        if (document.createNodeIterator) {
            var iterator = document.createNodeIterator(element, NodeFilter.SHOW_TEXT, function(node) {
                    return node.parentNode == element ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                }, false);

            while (iterator.nextNode()) {
                if (iterator.referenceNode && !iterator.referenceNode.textContent.trim()) {
                    iterator.referenceNode.parentNode.removeChild(iterator.referenceNode);
                }
            }
        } else { // IE7/8 support
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];

                if (child.nodeType == 3 && !/\S/.test(child.nodeValue)) {
                    element.removeChild(child);
                    i--;
                }

                if (child.nodeType == 1) {
                    kendo.stripWhitespace(child);
                }
            }
        }
    };

    var animationFrame  = window.requestAnimationFrame       ||
                          window.webkitRequestAnimationFrame ||
                          window.mozRequestAnimationFrame    ||
                          window.oRequestAnimationFrame      ||
                          window.msRequestAnimationFrame     ||
                          function(callback){ setTimeout(callback, 1000 / 60); };

    kendo.animationFrame = function(callback) {
        animationFrame.call(window, callback);
    };

    var animationQueue = [];

    kendo.queueAnimation = function(callback) {
        animationQueue[animationQueue.length] = callback;
        if (animationQueue.length === 1) {
            kendo.runNextAnimation();
        }
    };

    kendo.runNextAnimation = function() {
        kendo.animationFrame(function() {
            if (animationQueue[0]) {
                animationQueue.shift()();
                if (animationQueue[0]) {
                    kendo.runNextAnimation();
                }
            }
        });
    };

    kendo.parseQueryStringParams = function(url) {
        var queryString = url.split('?')[1] || "",
            params = {},
            paramParts = queryString.split(/&|=/),
            length = paramParts.length,
            idx = 0;

        for (; idx < length; idx += 2) {
            if(paramParts[idx] !== "") {
                params[decodeURIComponent(paramParts[idx])] = decodeURIComponent(paramParts[idx + 1]);
            }
        }

        return params;
    };

    kendo.elementUnderCursor = function(e) {
        return document.elementFromPoint(e.x.client, e.y.client);
    };

    kendo.wheelDeltaY = function(jQueryEvent) {
        var e = jQueryEvent.originalEvent,
            deltaY = e.wheelDeltaY,
            delta;

            if (e.wheelDelta) { // Webkit and IE
                if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)
                    delta = e.wheelDelta;
                }
            } else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera
                delta = (-e.detail) * 10;
            }

        return delta;
    };

    kendo.caret = function (element, start, end) {
        var rangeElement;
        var isPosition = start !== undefined;

        if (end === undefined) {
            end = start;
        }

        if (element[0]) {
            element = element[0];
        }

        if (isPosition && element.disabled) {
            return;
        }

        try {
            if (element.selectionStart !== undefined) {
                if (isPosition) {
                    element.focus();
                    element.setSelectionRange(start, end);
                } else {
                    start = [element.selectionStart, element.selectionEnd];
                }
            } else if (document.selection) {
                if ($(element).is(":visible")) {
                    element.focus();
                }

                rangeElement = element.createTextRange();

                if (isPosition) {
                    rangeElement.collapse(true);
                    rangeElement.moveStart("character", start);
                    rangeElement.moveEnd("character", end - start);
                    rangeElement.select();
                } else {
                    var rangeDuplicated = rangeElement.duplicate(),
                        selectionStart, selectionEnd;

                        rangeElement.moveToBookmark(document.selection.createRange().getBookmark());
                        rangeDuplicated.setEndPoint('EndToStart', rangeElement);
                        selectionStart = rangeDuplicated.text.length;
                        selectionEnd = selectionStart + rangeElement.text.length;

                    start = [selectionStart, selectionEnd];
                }
            }
        } catch(e) {
            /* element is not focused or it is not in the DOM */
            start = [];
        }

        return start;
    };

})(jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
define('core/rfclass',['kendo/kendo.core', 'vendor/lodash'], function (kCore, _) {
  var staticClassList = {};

  function RFClass() {
    var self = this,
        pubs = [],
        subscribers = {};

    self.pro = {
      /**
       * The event emitter
       * @type {kendo.Observable}
       */
      ee: new kendo.Observable (),
      bind: function (name, callback) {
        if (!subscribers.hasOwnProperty(name)) {
          subscribers[name] = [];
        }
        subscribers[name].push(callback);
      },
      unbindAll: function () {
        subscribers = {};
      },
      trigger: function (name, params) {
        if(name === "change") {
          self.trigger("update");
        }
        if (subscribers.hasOwnProperty(name)) {
          var len = subscribers[name].length;
          for (var i = 0; i < len; i++) {
            // TODO: jugad implemented need to find better solution (achievement unlocked: Total Jugad)
            if (subscribers[name]) {
              subscribers[name][i](params);
            }
          }
        }
        if(name === "submit") {
          self.trigger("apply");
        }
      },
      isSubscribed: function(eventName) {
        return !!(subscribers[eventName] && subscribers[eventName].length);
      },
      aspect: {
        items: [],
        revoke: function(name) {
          self.pro.aspect.items = _.without(self.pro.aspect.items, name);
        },
        provide: function (name) {
          if(_.indexOf(self.pro.aspect.items, name) === -1) {
            self.pro.aspect.items.push(name);
          }
        },
        require: function (items) {
          var errMsg = [];
          for (var key in items) {
            if(items.hasOwnProperty(key)) {
              if(_.indexOf(self.pro.aspect.items, key) === -1) {
                errMsg.push(items[key]);
              }
            }
          }
          return errMsg;
        }
      },
      handleWarning: function (msg) {
        console.warn("Got an error: ", msg);
      }
    };
    self._rawId = "";
    self._raw = {
      className: "RFClass",
      _registerPublic: function (base, pub) {
        var errorFunc = function (key) {
          return function () {
            console.warn("Note: Trying to call base '" + key + "' which doesn't exist");
            return null;
          };
        };

        for (var key in pub) {
          if (pub.hasOwnProperty(key)) {
            // Check if there's already a parent method.
            if (self.hasOwnProperty(key)) {
              base[key] = self[key];
            }
            else {
              // Otherwise just in case someone tries to access the base function, don't die
              // with an error
              base [key] = errorFunc(key);
            }

            self[key] = pub[key];
          }
        }
      },
      _registerClassName: function (name) {
        if (staticClassList.hasOwnProperty(name)) {
          staticClassList[name]++;
        }
        else {
          staticClassList[name] = 0;
        }
        self._raw.className = name;
        self._rawId = name + "_" + staticClassList[name];
      },
      _dispose: function () {
        for (var i = 0; i < pubs.length; i++) {
          for (var key in pubs[i]) {
            if (pubs[i].hasOwnProperty(key)) {
              if (typeof(pubs[i][key]) === "object") {
                pubs[i][key] = null;
              }
            }
          }
          pubs[i] = null;
        }
        pubs = null;
      },
      _registerProtected: function (base, items) {
        base = base ? base : {};
        for (var key in items) {
          if (items.hasOwnProperty(key)) {
            if (self.pro.hasOwnProperty(key)) {
              base[key] = self.pro[key];
            }
            self.pro[key] = items[key];
          }
        }
      },
      registerPublicExtensions: function (extension) {
        var pubFunctions = extension.call(self, self.pro);
        self._raw._registerPublic({}, pubFunctions);
      },
      registerProtectedExtensions: function (extension) {
        var proFunctions = extension.call(self, self.pro);
        self._raw._registerProtected({}, proFunctions);
      }
    };

    var base = {};
    self._raw._registerPublic(base, {
      /**
       * Bind a handler to the event
       * 
       * @method bind
       * @param  {string} eventName The name of the event to bind to
       * @param {function} handler A function to handle the the event
       * @param {boolean} one If set to true, it gets triggered only once
       */
        bind: function(eventName, handler, one) {
          self.pro.ee.bind(eventName, handler, one);
        },

        one: function(eventNames, handlers) {
          return self.pro.ee.one(eventName, handlers);
        },

        /**
         * Trigger an event and start any handlers attached to the event
         *
         * @method trigger
         * @param  {string} eventName The name of the event to trigger
         * @param {object} e An object containing extra data that's passed to the handler of the event
         */
        trigger: function(eventName, e) {
            return self.pro.ee.trigger(eventName, e);
        },

        /**
         * Bind a handler to the event.
         *
         * * If `eventName` is not set, all events are unbound
         * * If `handler` is not set, all handlers for the event name are removed
         * 
         * @method unbind
         * @param  {string} eventName The name of the event to unbind
         * @param {function} handler The function to unbind
         */
        unbind: function(eventName, handler) {
          return self.pro.ee.unbind(eventName, handler);
        }
    });

  }

  return RFClass;
});

define('generated/templates',["vendor/lodash"], function(_)  {

  var JST = {};

  JST["bread_crumb"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfBreadCrumb">\n    <ul>\n        <li data-index="0"><a>' +((__t = ( startString )) == null ? '' : __t) +'</a> </li>\n        '; for(var i=-1; ++i<drillLabelList.length;) { ;__p += '\n            <li data-index="' +((__t = ( i+1 )) == null ? '' : __t) +'">\n                <span class="rfIcon rfBCRight"></span> <a>' +((__t = ( drillLabelList[i] )) == null ? '' : __t) +'</a>\n            </li>\n        '; } ;__p += '\n\n    </ul>\n</div>';}return __p};

  JST["browser_error"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="notSupportedMessage">\n    <h3>Sorry, your browser cannot display this dashboard.</h3>\n</div>';}return __p};

  JST["chart_base"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) { if(legendVisible) { ;__p += '\n<div class="rfLegendContainer">\n    <ul class="rfLegendContainerList '; if(displayType === 'pie'){ ;__p += ' rfPieLegend '; } ;__p += '">\n    '; for(var i=0; i<series.length; i++) {         var item = series[i],             cls = item.seriesColor !== 'auto' ? '' : 'chart-color-' + (i + 1),             style =item.seriesColor !== 'auto' ? 'background: ' + item.seriesColor : ''; ;__p += '\n        <li class="rfLegendKey ' +((__t = ( (item.seriesHiddenFlag === true) ? 'disabled' : '' )) == null ? '' : __t) +'" data-key="' +((__t = (item.key)) == null ? '' : __t) +'">\n            <span class="legendColor ' +((__t = ( cls )) == null ? '' : __t) +'" style="' +((__t = ( style )) == null ? '' : __t) +'"></span>\n            <span class="legendCaption">' +((__t = ( item.seriesName )) == null ? '' : __t) +'</span>\n        </li>\n    '; } ;__p += '\n    </ul>\n</div>\n'; } ;__p += '\n<div class="chartCore">\n\n</div>\n';}return __p};

  JST["component_chromeless"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="rfWrapper rfChromeless">\n  <div class="rfCore">\n\n  </div>\n  <div class="rfLock">\n    <div class="rfLoadingText"></div>\n    <div class="rfSpinner"></div>\n  </div>\n  <div class="rfError">\n  \t<div class="rfErrorMessageText"></div>\n  </div>\n</div>\n';}return __p};

  JST["component_wrapper"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfWrapper rfChromed">\n    '; if (showCaption && !error) { ;__p += '\n        <div class="rfCaption">\n            <span class="rfCaptionIconContainer"></span>\n            <span class="rfCaptionText">' +((__t = ( captionText )) == null ? '' : __t) +'</span>\n            '; if(typeof formComponent === 'undefined' || !formComponent) { ;__p += '\n                '; if (!mobile) { ;__p += '\n                    <span class="rfIcon rfMaximizeIcon"></span>\n                '; } ;__p += '\n            '; } ;__p += '\n        </div>\n    '; } ;__p += '\n    <div class="rfHeader">\n    </div>\n    <div class="rfCore">\n\n    </div>\n    <div class="rfLock">\n      <div class="rfLoadingText"></div>\n      <div class="rfSpinner"></div>\n    </div>\n    <div class="rfFooter">\n        <div class="componentKPI">\n        </div>\n    </div>\n    <div class="rfError">\n        <div class="rfErrorMessageText"></div>\n    </div>\n</div>\n';}return __p};

  JST["dashboard_embedded"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfDashboardCore rfEmbedded">\n\n</div>\n<div class="rfDashboardHidden" style="display: none;">\n\n</div>\n<div class="rfDashboardNinja">\n\n</div>\n<div class="rfDashboardModals">\n</div>\n\n'; if(!tabbed) { ;__p += '\n<div class="rfNotification"></div>\n'; } ;}return __p};

  JST["dashboard_standalone"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) { if(title){ ;__p += '\n\t<div class="rfDashboardHeader">\n\t  <div class="rfHeaderContainer">\n\t  \t<h1 class="dbTitle">' +((__t = ( title )) == null ? '' : __t) +'</h1>\n\t  </div>\n\t</div>\n'; } ;__p += '\n<div class="rfDashboardCore rfStandalone">\n\n</div>\n<div class="rfDashboardHidden" style="display: none;">\n\n</div>\n<div class="rfDashboardNinja">\n\n</div>\n<div class="rfDashboardModals">\n</div>\n\n<div class="rfNotification"></div>\n\n<div class="rfThemeModal">\n\t\n</div>\n';}return __p};

  JST["date_picker"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="rfDatePicker">\n</div>\n';}return __p};

  JST["error_list"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) { if (!(media === 'xs')) { ;__p += '\n\t<span class="rfIcon rfErrorIcon"></span>\n'; } ;__p += '\n<ul class="errorList">\n'; for (var i = 0; i < message.length; i++) { ;__p += '\n\t<li>' +((__t = ( message[i].msg )) == null ? '' : __t) +'.</li>\n'; } ;__p += '\n</ul>\n';}return __p};

  JST["form_base"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="formContainer">\n  <div class="formItems">\n\n  </div>\n  <div class="dashed-divider"></div>\n  <div class="form-btn">\n    <button id="submit" data-role="button" class="k-button" role="button" aria-disabled="false" tabindex="0">Opdater</button>\n  </div>\n</div>\n';}return __p};

  JST["form_item"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="form-item">\n    <label for=\'' +((__t = ( id )) == null ? '' : __t) +'\' class=" control-label">' +((__t = ( label )) == null ? '' : __t) +'</label>\n    '; if(type == "checkbox") { ;__p += '\n        <input type="checkbox" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="rfformItem checkBox" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n        ' +((__t = ( options.value === true ? 'checked' : '' )) == null ? '' : __t) +'>\n    '; } ;__p += '\n    <div class="form-item-main">\n        '; if(type == "text") { ;__p += '\n        <input type="text" class="form-control rfformItem textItem" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' value="' +((__t = ( value )) == null ? '' : __t) +'">\n        '; } ;__p += '\n        \n        '; if(type == "select" || type == 'multiSelect') { ;__p += '\n        <select id="' +((__t = ( id )) == null ? '' : __t) +'" ' +((__t = ( (multiple === true) ? 'multiple="multiple"' : '' )) == null ? '' : __t) +' class="form-control" data-key="' +((__t = ( id )) == null ? '' : __t) +'">\n            '; for (var i = 0; i < list.length; i ++) { ;__p += '\n            <option ' +((__t = ( (i === options.defaultSelectedIndex) ? 'selected' : '' )) == null ? '' : __t) +' \n                ' +((__t = ( (multiple === true && isOptionSelected[i] === true) ? 'selected' : '' )) == null ? '' : __t) +'\n                data-index="' +((__t = ( i )) == null ? '' : __t) +'">' +((__t = ( list[i] )) == null ? '' : __t) +'</option>\n                '; } ;__p += '\n            </select>\n        '; } ;__p += '\n        \n        '; if(type == "date") { ;__p += '\n            <div class="short-box" style="display: inline-block;">\n                '; if(touch === true) { ;__p += '\n                    <input type="date" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem datepickerItem" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                    value="' +((__t = ( options.defaultDate )) == null ? '' : __t) +'" />\n                '; } else { ;__p += '\n                    <input type="text" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem datepickerItem" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                    value="' +((__t = ( options.defaultDate )) == null ? '' : __t) +'" />\n                '; } ;__p += '\n            </div>\n        '; } ;__p += '\n        \n        '; if(type == "dateRange") { ;__p += '\n            <div class="short-box datepickerRange" style="display: inline-block;">\n            '; if(touch === true) { ;__p += '\n                <input type="date" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem datepickerItem rangeStart" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                value="' +((__t = ( options.defaultStartDate )) == null ? '' : __t) +'">\n            '; } else { ;__p += '\n                <input type="text" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem datepickerItem rangeStart" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                value="' +((__t = ( options.defaultStartDate )) == null ? '' : __t) +'">\n            '; } ;__p += '\n            </div>    \n             <span class="to"></span>\n            <div class="short-box datepickerRange" style="display: inline-block;">\n            '; if(touch === true) { ;__p += '\n                <input type="date" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem datepickerItem rangeEnd" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                value="' +((__t = ( options.defaultEndDate )) == null ? '' : __t) +'">    \n            '; } else { ;__p += '\n                <input type="text" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem datepickerItem rangeEnd" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                value="' +((__t = ( options.defaultEndDate )) == null ? '' : __t) +'">    \n            '; } ;__p += '\n            </div>\n        '; } ;__p += '\n        \n        '; if(type == "numericRange") { ;__p += '\n        <span class="rfNumericRangeText-' +((__t = ( id )) == null ? '' : __t) +'"></span>\n        <br />\n        <div id="rfRangeSlider-' +((__t = ( id )) == null ? '' : __t) +'">\n          '; if(touch === true) { ;__p += '\n            <div class="" style="width: 40%; display: inline-block;">\n                <input type="number" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem numberRangeItem rangeStart" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                value="' +((__t = ( options.values[0] )) == null ? '' : __t) +'">\n            </div>\n          <span class="to"></span>\n            <div class="" style="width: 40%; display: inline-block;">\n                <input type="number" id=\'' +((__t = ( id )) == null ? '' : __t) +'\' class="form-control rfformItem numberRangeItem rangeEnd" data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\' \n                value="' +((__t = ( options.values[1] )) == null ? '' : __t) +'">\n            </div>\n          '; } else { ;__p += '\n            <input id=\'' +((__t = ( id )) == null ? '' : __t) +'\' data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\'/>\n            <input id=\'' +((__t = ( id )) == null ? '' : __t) +'\' data-key=\'' +((__t = ( id )) == null ? '' : __t) +'\'/>\n          '; } ;__p += '\n        </div>\n        '; } ;__p += '\n    </div>\n</div>\n';}return __p};

  JST["icon"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<span class="icon">\n    <svg xmlns="http://www.w3.org/2000/svg" style="overflow: hidden; position: relative;" width="' +((__t = ( width )) == null ? '' : __t) +'" height="' +((__t = ( height )) == null ? '' : __t) +'">\n        '; if(name === 'maximize') { ;__p += '\n            <path transform="scale(0.4)" d="M22.646,19.307c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127l3.535-3.537L22.646,19.307zM13.688,20.369c-3.582-0.008-6.478-2.904-6.484-6.484c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486C20.165,17.465,17.267,20.361,13.688,20.369zM15.687,9.051h-4v2.833H8.854v4.001h2.833v2.833h4v-2.834h2.832v-3.999h-2.833V9.051z" stroke="#fff" fill="#000"\n            stroke-width="0.5px">\n            </path>\n        '; } ;__p += '\n        '; if(name === 'close') { ;__p += '\n            <path transform="scale(0.8) translate(-7,-4)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" fill="#fff">\n            </path>\n        '; } ;__p += '\n    </svg>\n</span>';}return __p};

  JST["kpi_basic"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<p>\n    The KPI\'s caption is <b>' +((__t = ( kpiCaption )) == null ? '' : __t) +'</b> and value is <span class="rfKPIValue"></span>\n</p>\n<p>\n    The dimensions are <span class="rfKpiDimensions"></span>\n</p>';}return __p};

  JST["kpigroup"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfKPIGroupContainer">\n    '; for(var i=-1; ++i<numKPIs;) { ;__p += '\n        <div class="rfMiniKPIContainer" id="' +((__t = ( keys[i] )) == null ? '' : __t) +'">\n            <div class="rfMiniKPIContainerBorderContainer">\n            </div>\n        </div>\n    '; } ;__p += '\n</div>';}return __p};

  JST["kpitable"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfKPITableContainer">\n    <table class="rfTable">\n        '; for(var i=-1; ++i<numKPIs;) { ;__p += ' \n            <tr id="' +((__t = ( keys[i] )) == null ? '' : __t) +'">\n                <td class="rfKPITableCaption rfKPICaption">' +((__t = ( kpis[i].caption )) == null ? '' : __t) +'</td>\n                <td class="rfKPITableValue rfKPIValue">' +((__t = ( kpis[i].value )) == null ? '' : __t) +'</td>\n            </tr>\n        '; } ;__p += '\n    </table>\n</div>';}return __p};

  JST["logging_base"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="loggingBase">\n  <ul class="loggingItems"></ul>\n  <div class="logContent"></div>\n</div>';}return __p};

  JST["logging_links"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<li id="' +((__t = ( logID )) == null ? '' : __t) +'">\n\t<span class=\'url\'></span>\n\t<span class=\'status\'></span>\n</li>';}return __p};

  JST["logging_table"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div id="' +((__t = ( logID )) == null ? '' : __t) +'" style="display:none;">\n  <table class="rfTable" style="width: auto;">\n    <thead>\n      <tr>\n        <th>Timestamp</th>\n        <th>Message</th>\n      </tr>      \n    </thead>\n    <tbody>\n      '; for(var i=0; i<logs.length; i++){ ;__p += '\n        <tr>\n          <td>' +((__t = ( new Date() )) == null ? '' : __t) +'</td>\n          <td>\n            ' +((__t = ( logs[i].message )) == null ? '' : __t) +'\n            <p>' +((__t = ( logs[i].log )) == null ? '' : __t) +'</p>\n          </td>\n        </tr>\n      '; } ;__p += '\n    </tbody>\n  </table>\n</div>\n';}return __p};

  JST["logs"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="devTools">\n    <div class="devToolsInner">\n        <div id="tabstrip">\n            <ul>\n                <li class="k-state-active">Logs</li>\n            </ul>\n            <div class="rfLogs">\n                <div class="toolbar">\n                    <input type="checkbox" id="all" checked>All</input>\n                    <input type="checkbox" id="log" checked>Logs</input>\n                    <input type="checkbox" id="warn" checked>Warnings</input>\n                    <input type="checkbox" id="error" checked>Errors</input>\n                    <input type="checkbox" id="server" checked>Server</input>\n                    <input type="checkbox" id="client" checked>Client</input>\n                </div>\n                <ul class="rfLogList">\n                    \n                </ul>\n            </div>\n        </div>\n    </div>  \n</div>';}return __p};

  JST["mini_kpi"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfMiniKPI">\n\t'; for (var key in kpis) { ;__p += '\n\t\t<div class="' +((__t = ( key )) == null ? '' : __t) +'">\n\t\t\t<div class="rfMiniKPICaption">\n\t\t\t\t' +((__t = ( kpis[key].caption )) == null ? '' : __t) +'\n\t\t\t</div>\n\t\t\t<div class="rfMiniKPIValue">\n\t\t\t\t' +((__t = ( kpis[key].value )) == null ? '' : __t) +'\n\t\t\t</div>\n\t\t</div>\n\t'; } ;__p += '\n</div>\n';}return __p};

  JST["minikpi"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="rfMiniKPICore">\n    <div class="rfMiniKPIBorderContainer">\n    </div>        \n    <div class="rfMiniKPICaption rfKPICaption">\n        ' +((__t = ( caption )) == null ? '' : __t) +'\n    </div>\n    <div class="rfMiniKPIValue rfKPIValue">\n        ' +((__t = ( value )) == null ? '' : __t) +'\n    </div>\n</div>';}return __p};

  JST["notification_errors"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="rfNotificationErrors">\n    <p>' +((__t = ( msg )) == null ? '' : __t) +'</p>\n</div>';}return __p};

  JST["rfmodal"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div class="rfModalBody">\n</div>\n';}return __p};

  JST["tabbeddashboard_standalone"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) { if(title){ ;__p += '\n\t<div class="rfDashboardHeader">\n\t  <div class="rfHeaderContainer">\n\t  \t<h1 class="dbTitle">' +((__t = ( title )) == null ? '' : __t) +'</h1>\n\t  </div>\n\t</div>\n'; } ;__p += '\n'; if (mobile) { ;__p += '\n    <div id="rfTabMobile" class="k-content">\n        <div id="mobile-tabstrip" data-role="tabstrip">\n        </div>\n        <div id="content-container">\n        </div>\n    </div>\n'; } else { ;__p += '\n    <div id="rfTabCore">\n        <ul class="tabLinks"></ul>\n    </div>\n'; } ;__p += '\n\n<div class="rfNotification"></div>\n<!-- \n<div class="rfServerLogBtnWrapper">\n  <button class="rfServerLogButton">Server Log</button>\n</div> -->';}return __p};

  JST["table_base"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class=\'rfTableContainer\'>\n    <div class="rfTableHeader">\n        <table class=\'rfTable\'>\n            <thead>\n            <tr>\n                '; for (var key in columns) { var item = columns[key]; ;__p += '\n                '; var thStyleClass = item.textAlign ? 'rfTh-' + item.textAlign : null ;__p += '\n                <th data-id=\'' +((__t = ( key )) == null ? '' : __t) +'\' class=\'' +((__t = ( thStyleClass )) == null ? '' : __t) +'\'>\n                    <p>\n                        ' +((__t = ( item.name )) == null ? '' : __t) +' '; if(item.subCaptionUnits){ ;__p += '(' +((__t = (  item.subCaptionUnits )) == null ? '' : __t) +')'; } ;__p += '\n                    </p>\n                </th>\n                '; } ;__p += '\n            </tr>\n            </thead>\n        </table>\n    </div>\n    <div class="rfTableBody">\n    </div>\n\n</div>\n    <div class=\'rfPaginationContainer\'>\n    </div>\n';}return __p};

  JST["table_body"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<table class="rfTable">\n    <tbody>\n    '; for (var i = 0; i < data.length; i++) { var row = data[i]; var tCol = 0; ;__p += '\n\n    <tr>\n        ';        for (var key in row) {        var item = row[key];        var sClass = styleClass[key]['style'];        var style = "";        if(cellStyle[key] && typeof cellStyle[key][i]["cellBackgroundColor"] !== "undefined" && typeof cellStyle[key][i]["cellTextColor"] !== "undefined") {            style = "background-color:"+cellStyle[key][i]["cellBackgroundColor"]+"; color:"+cellStyle[key][i]["cellTextColor"]+";";        }        ;__p += '\n        <td class="' +((__t = ( sClass )) == null ? '' : __t) +'" data-id="' +((__t = ( key )) == null ? '' : __t) +'" id="rfTableCell-' +((__t = ( key )) == null ? '' : __t) +'-' +((__t = ( i )) == null ? '' : __t) +'" style="' +((__t = ( style )) == null ? '' : __t) +'">\n            <p>'; if(columns[key].dataType === 'icon') { ;__p += '\n                <span class="rfIcon rfi-' +((__t = (item)) == null ? '' : __t) +'"></span>\n                '; } else { ;__p +=((__t = ( item )) == null ? '' : __t); } ;__p += '</p>\n        </td>\n        '; } ;__p += '\n    </tr>\n    '; } ;__p += '\n    </tbody>\n</table>\n\n';}return __p};

  JST["table_paginator"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class=\'rfPaginationCore\'>\n\t'; if(!media) { ;__p += '\n\t\t<p class="paginationInfo">\n\t\t\tPage ' +((__t = ( activePage+1 )) == null ? '' : __t) +' of ' +((__t = ( totalPages )) == null ? '' : __t) +'\n\t\t</p>\n\t\t<ul class="rfpagination">\n\t\t  <li class="rfPrevButton '; if(activePage === 0){ ;__p += ' disabled'; } ;__p += '"><a href="#"><span class="pagePrevArrow">&#866;</span> Prev</a></li>\n\t\t\t\t'; for(var i=startPage; i<=lastPage; i++){ ;__p += '\n\t\t\t\t\t<li class="rfPageNumber'; if(activePage === i){ ;__p += ' active'; } ;__p += '" data-page-number="' +((__t = ( i )) == null ? '' : __t) +'"><a href="#">' +((__t = ( (i+1) )) == null ? '' : __t) +'</a></li>\n\t\t\t\t'; } ;__p += '\n\t\t\t\t<li class="rfNextButton '; if(activePage === totalPages-1){ ;__p += ' disabled'; } ;__p += '"><a href="#">Next <span class="pageNextArrow">&#866;</span></a></li>\n\t\t</ul>\n\t'; } else { ;__p += '\n\t\t<div class="rfMobilePagination">\n\t\t  <span class="rfPrevButton '; if(activePage === 0){ ;__p += ' disabled'; } ;__p += ' rfMobileButton"><span class="rfIcon rfLeftArrowLarge"></span></span>\n\t\t  <span class="paginationInfo">\n\t\t\t\tPage ' +((__t = ( activePage+1 )) == null ? '' : __t) +' of ' +((__t = ( totalPages )) == null ? '' : __t) +'\n\t\t\t</span>\n\t\t\t<span class="rfNextButton '; if(activePage === totalPages-1){ ;__p += ' disabled'; } ;__p += ' rfMobileButton"><span class="rfIcon rfRightArrowLarge"></span></span>\n\t\t</div>\n\t'; } ;__p += '\n</div>';}return __p};

  JST["theme_builder"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape;with (obj) {__p += '<div id="themeWindow">\n\t<div class="themepanelbarContainer">\n\t\t<ul id="themepanelbar">\n    \t</ul>\n\t</div>\n\t<div class="themeFooter">\n\t\t<button class="doneBtn">Done</button>\n\t\t<input type="text" style="display:none;" value="custom_theme" id="rfThemeFileName" class="k-textbox" />\n\t\t<a class="getCSSBtn" style="display:none;" download="custom_theme.css">Get CSS</a>\n\t\t<button class="updateBtn">Update</button>\n\t</div>\n</div>';}return __p};

  JST["theme_table"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<table class=\'itemTable\'>\n'; for (var i = 0; i<items.length; i++) { ;__p += '\n\t<tr>\n\t\t<td>\n\t\t\t<input data-id=\'' +((__t = ( items[i].key )) == null ? '' : __t) +'\' class=\'picker\' />\n\t\t</td>\n\t\t<td>\n\t\t\t<span class=\'themeItem\'>' +((__t = ( items[i].desc )) == null ? '' : __t) +'</span>\n\t\t</td>\n\t\t<td>\n\t\t\t<span data-id=\'' +((__t = ( items[i].key )) == null ? '' : __t) +'\' data-value=\'' +((__t = ( DefaultTheme[items[i].key] )) == null ? '' : __t) +'\' class=\'rfIcon rfRefreshIcon resetTheme\'></span>\n\t\t</td>\n\t</tr>\n'; } ;__p += '\n</table>';}return __p};

  JST["tooltip"] = function(obj) {obj || (obj = {});var __t, __p = '', __e = _.escape, __j = Array.prototype.join;function print() { __p += __j.call(arguments, '') }with (obj) {__p += '<div class="rfTooltip">\n    <span class="rfTooltipMainLabel"></span>\n    <div class="rfTooltipValueRow">\n        <span class="rfTooltipLabel">\n        </span>\n        <span class="rfTooltipValue">\n        </span>\n    </div>\n    '; if(popupType === 'top') { ;__p += '\n        <span class="downArrow"></span>\n        <span class="downArrowBorder"></span>\n    '; } else if(popupType === 'left') { ;__p += '\n        <span class="leftArrow"></span>\n        <span class="leftArrowBorder"></span>\n    '; } ;__p += '\n</div>';}return __p};

  return JST;

});
define('utils/positionutils',[

],
    function () {
      var posUtils = {
        unitsToPixels: function (u, width) {
          return u / 12 * width;
        },
        unitsToPc: function (u) {
          return u * 100 / 12;
        },
        unitsToPcString: function (u) {
          return posUtils.unitsToPc(u) + "%";
        }
      };
      return posUtils;
    });
define('utils/layoutmanager',[

],
    function () {
      var layoutManager = function (_options) {
        var self = this,
            options = _options || {},
            matrix = [],
            maxX = options.maxX || 12,
            maxY = 0,
            PAGE_SIZE = 12,
            minY = 0;

        /**
         * clears the matrix which holds the layout bitmap
         */
        var clearMatrix = function () {
          matrix = [];
        };

        /**
         * Appends amount of rows specified by num
         * @param {Number} num
         */
        var addMoreRows = function (num) {
          for (var j = 0; j < num; j++) {
            var tArr = [];

            for (var i = 0; i < maxX; i++) {
              tArr.push(0);
            }

            matrix.push(tArr);
          }

          maxY += num;
        };

        /**
         * Fills the layout bitmap at the specifed position with the specified dimension
         */
        var fillSpace = function (row, col, width, height) {
          for (var j = row; j < row + height; j++) {
            for (var i = col; i < col + width; i++) {
              matrix[j][i] = 1;
            }
          }
        };

        // Add two rows initially
        addMoreRows(PAGE_SIZE);


        /**
         * Finds and returns the empty spot in grid with the specified dimensions
         */
        self.findEmptySpot = function (w, h) {
          var result;
          if(!w && !h){
            throw 'Dimensions is not provided. Cannot find empty spot.';
          }
          for (var j = minY; j < maxY; j++) {
            var tStr = matrix[j].join('');
            var r = '';

            for (var t = 0; t < w; t++) {
              r += '0';
            }

            result = tStr.indexOf(r);

            if (result >= 0) {
              var spaceFound = true;

              for (var i = j + 1, k = 1; i < maxY && k < h; i++, k++) {

                var tStr2 = matrix[i].slice(result, result + w).join('');

                if (tStr2 !== r) {
                  spaceFound = false;
                  break;
                }
              }

              if (spaceFound && k === h) {
                minY = j;
                fillSpace(j, result, w, h);

                return {
                  row: j,
                  col: result
                };

              } else {

                addMoreRows(PAGE_SIZE);
                return self.findEmptySpot(w, h);
              }
            }
          }

          addMoreRows(PAGE_SIZE);
          return self.findEmptySpot(w, h);
        };

        /**
         * Clears the layout
         */
        self.clearLayout = function () {
          clearMatrix();
        };
      };

      return layoutManager;
    });
define('utils/media',[

],
    function () {
      return {
        fastMediaSelect: function (mediaName, object) {
          if (typeof(object) === 'undefined') {
            return object;
          }
          if (object === null) {
            return object;
          }
          switch (mediaName) {
            case "xs":
              if (object.hasOwnProperty("xs")) {
                return object["xs"];
              }
              if (object.hasOwnProperty("sm")) {
                return object["sm"];
              }
              if (object.hasOwnProperty("md")) {
                return object["md"];
              }
              if (object.hasOwnProperty("lg")) {
                return object["lg"];
              }
              return object;
            case "sm":
              if (object.hasOwnProperty("sm")) {
                return object["sm"];
              }
              if (object.hasOwnProperty("xs")) {
                return object["xs"];
              }
              if (object.hasOwnProperty("md")) {
                return object["md"];
              }
              if (object.hasOwnProperty("lg")) {
                return object["lg"];
              }
              return object;
            case "md":
              if (object.hasOwnProperty("md")) {
                return object["md"];
              }
              if (object.hasOwnProperty("lg")) {
                return object["lg"];
              }
              if (object.hasOwnProperty("sm")) {
                return object["sm"];
              }
              if (object.hasOwnProperty("xs")) {
                return object["xs"];
              }
              return object;
            case "lg":
              if (object.hasOwnProperty("lg")) {
                return object["lg"];
              }
              if (object.hasOwnProperty("md")) {
                return object["md"];
              }
              if (object.hasOwnProperty("sm")) {
                return object["sm"];
              }
              if (object.hasOwnProperty("xs")) {
                return object["xs"];
              }
              return object;
          }
          return object;
        },
        isMediaObject: function (obj) {
          if (obj === null || typeof(obj) === "undefined") {
            return false;
          }

          if (obj.hasOwnProperty('xs') || obj.hasOwnProperty('sm') || obj.hasOwnProperty('md') || obj.hasOwnProperty('lg')) {
            for (var key in obj) {
              if(obj.hasOwnProperty(key)){
                if (key === "xs" || key === "sm" || key === "md" || key === "lg") {
                  continue;
                }
                return false;
              }
            }
            return true;
          }
          return false;
        },
        getCurrentMedia: function () {
          return window.rf.globals.media;
        },
        calculateMedia: function(currentWidth) {
          if (currentWidth < 480) {
            return "xs";
          } else if (currentWidth < 600) {
            return "sm";
          } else if (currentWidth < 978) {
            return "md";
          } else {
            return "lg";
          }
        },
        applyMediaToNode: function(core, media) {
          core.removeClass('rf-lg');
          core.removeClass('rf-md');
          core.removeClass('rf-sm');
          core.removeClass('rf-xs');

          core.addClass("rf-" + media);
        }
      };
    });

define('helpers/mediahelper',[], function () {
  var MediaHelper = function (defaultMedia) {
    var self = this,
        currentMedia = "md",
        mediaIndex = 2;


    var getIndex = function (name) {
      switch (name) {
        case "xs":
          return 0;
        case "sm":
          return 1;
        case "md":
          return 2;
        case "lg":
          return 3;
      }
      throw "Unknown index for media" + name;
    };

    var getMediaName = function (index) {
      switch (index) {
        case 0:
          return "xs";
        case 1:
          return "sm";
        case 2:
          return "md";
        case 3:
          return "lg";
      }
      throw "Unknown media for index" + index;
    };

    var checkMediaName = function (index) {
      switch(name) {
        case "xs":
        case "sm":
        case "md":
        case "lg":
          return true;
      }
      return false;
    };

    var selectItem = function (items, defVal) {
      var i;
      // Pre-process operators
      var object = items;

      for(var key in items) {
        if(items.hasOwnProperty(key)) {
          if(key.search(/\+/) !== -1) {
            var splitItems = key.split("+");
            for(i = 0; i < splitItems.length; i++) {
              object[splitItems[i]] = items[key];
            } 
          }
        }
      }
      if (object.hasOwnProperty(currentMedia)) {
        return object[currentMedia];
      } else {
        if(defVal !== "") {
          return defVal;
        }

        for (i = mediaIndex; i >= 0; i--) {
          if (object.hasOwnProperty(getMediaName(i))) {
            return object[getMediaName(i)];
          }
        }
        for (i = mediaIndex; i <= 4; i++) {
          if (object.hasOwnProperty(getMediaName(i))) {
            return object[getMediaName(i)];
          }
        }

      }
    };

    var newSelect = function (items) {

    };

    self.setMedia = function (name) {
      currentMedia = name;
      mediaIndex = getIndex(name);
      window.rf.globals.media = name;
    };

    self.getCurrentMedia = function () {
      return currentMedia;
    };

    self.mediaSelect = function (obj, defVal) {
      return selectItem(obj, defVal);
    };

    self.mediaExec = function (obj, data) {
      var func = selectItem(obj);

      func(data);
    };

    /**
     * Smaller than or equal to specified media
     * @param  {[type]} media [description]
     * @return {[type]}       [description]
     */
    self.smeq = function (media) {
      return mediaIndex <= getIndex(media);
    };

    self.screenSelect = function (obj) {
      return self.mediaSelect({
        "sm+xs": obj.small,
        "md+lg": obj.large
      });
    };

    if (defaultMedia) {
      self.setMedia(defaultMedia);
    }
  };

  return MediaHelper;
});
define('constants/componentconstants',[], function () {

  var spinner = {
    options: {
      lines: 12,
      length: 6,
      width: 4,
      radius: 12,
      corners: 1,
      rotate: 0,
      direction: 1,
      color: '#000',
      speed: 1,
      trail: 60,
      shadow: false,
      hwaccel: false,
      className: 'spinner',
      zIndex: 2e9,
      top: 'auto',
      left: 'auto'
    }
  };

  var dashboard_constants = {
    resizeDelay: 150,
    dimension: {
      w: 4,
      h: 4
    }
  };

  var component = {
    xPadding: 20,
    yPadding: 20
  };

  var chart_profiles = {
    'chart': {
      drawAxesFlag: true,
      paddingLeft: 10,
      paddingTop: 15,
      paddingBottom: 25,
      paddingRight: 10,
      xAxisItemPadding: 0.2,
      seriesInterColumnPadding: 0.15,
      prettifyDomain: true,
      stickLineChartToSides: false,
      drawYAxisNameFlag: true,
      yAxisNameWidth: 20,
      showGridLineFlag: true,
      wrapLabelsFlag: true,
      circleRadius: 4,
      dualStageAnimate: false,
      yAxisLabelSize: 16,
      yAxisLabelHeight: 10
    },
    'spark': {
      drawAxesFlag: false,
      paddingLeft: 20,
      paddingTop: 0,
      paddingBottom: 0,
      paddingRight: 20,
      xAxisItemPadding: 0,
      seriesInterColumnPadding: 0.1,
      prettifyDomain: true,
      stickLineChartToSides: true,
      drawYAxisNameFlag: false,
      yAxisNameWidth: 0,
      showGridLineFlag: true,
      wrapLabelsFlag: false,
      circleRadius: 3,
      dualStageAnimate: true
    }
  };

  var chart = {
    animationDuration: 1000
  };

  var gauge = {
    startAngle: -1.7 * Math.PI / 2,
    endAngle: 1.7 * Math.PI / 2,
    fontSize: 40,
    arcWidth: 0.1,
    xPadding: 0.1,
    animationDuration: 1000
  };

  var pieChart = {
    innerRadiusDistance: 50,
    profile: {
      labelHeight: 18
    },
    animationDuration : 1000,
    padding: 20
  };

  var tooltip_profile = {
    opacity: 0.9,
    tooltipOffsetX: 40,
    tooltipOffsetY: 40,
    tooltipHeight: 20,
    tooltipBackground: '#fff',
    tooltipPaddingX: 20
  };

  var wrapGenius = {
    LINE_HEIGHT: 14,
    FONT_SIZE: 12,
    THETA: 45,
    MAX_HEIGHT_PERCENT: 0.25,
    PADDING: 5
  };

  return {
    'spinner': spinner,
    'component': component,
    'dashboard': dashboard_constants,
    'chart_profiles': chart_profiles,
    'chart': chart,
    'pieChart': pieChart,
    'gauge': gauge,
    'tooltip': tooltip_profile,
    'wrapGenius': wrapGenius
  };

});

// UAParser.js v0.6.16
// Lightweight JavaScript-based User-Agent string parser
// https://github.com/faisalman/ua-parser-js
//
// Copyright © 2012-2013 Faisalman <fyzlman@gmail.com>
// Dual licensed under GPLv2 & MIT

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        MAJOR       = 'major',
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv';


    ///////////
    // Helper
    //////////


    var util = {
        has : function (str1, str2) {
          if (typeof str1 === "string") {
            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
          }
        },
        lowerize : function (str) {
            return str.toLowerCase();
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function () {

            // loop through all regexes maps
            for (var result, i = 0, j, k, p, q, matches, match, args = arguments; i < args.length; i += 2) {

                var regex = args[i],       // even sequence (0,2,4,..)
                    props = args[i + 1];   // odd sequence (1,3,5,..)

                // construct object barebones
                if (typeof(result) === UNDEF_TYPE) {
                    result = {};
                    for (p in props) {
                        q = props[p];
                        if (typeof(q) === OBJ_TYPE) {
                            result[q[0]] = undefined;
                        } else {
                            result[q] = undefined;
                        }
                    }
                }

                // try matching uastring with regexes
                for (j = k = 0; j < regex.length; j++) {
                    matches = regex[j].exec(this.getUA());
                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof(q) === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof(q[1]) == FUNC_TYPE) {
                                        // assign modified match
                                        result[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        result[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof(q[1]) === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                result[q] = match ? match : undefined;
                            }
                        }
                        break;
                    }
                }

                if(!!matches) break; // break the loop immediately if match found
            }
            return result;
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof(map[i]) === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            oldsafari : {
                major : {
                    '1' : ['/8', '/1', '/3'],
                    '2' : '/4',
                    '?' : '/'
                },
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            }
        },

        device : {
            sprint : {
                model : {
                    'Evo Shift 4G' : '7373KT'
                },
                vendor : {
                    'HTC'       : 'APA',
                    'Sprint'    : 'Sprint'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            // Presto based
            /(opera\smini)\/((\d+)?[\w\.-]+)/i,                                 // Opera Mini
            /(opera\s[mobiletab]+).+version\/((\d+)?[\w\.-]+)/i,                // Opera Mobi/Tablet
            /(opera).+version\/((\d+)?[\w\.]+)/i,                               // Opera > 9.80
            /(opera)[\/\s]+((\d+)?[\w\.]+)/i                                    // Opera < 9.80

            ], [NAME, VERSION, MAJOR], [

            /\s(opr)\/((\d+)?[\w\.]+)/i                                         // Opera Webkit
            ], [[NAME, 'Opera'], VERSION, MAJOR], [

            // Mixed
            /(kindle)\/((\d+)?[\w\.]+)/i,                                       // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?((\d+)?[\w\.]+)*/i,
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

            // Trident based
            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?((\d+)?[\w\.]*)/i,
                                                                                // Avant/IEMobile/SlimBrowser/Baidu
            /(?:ms|\()(ie)\s((\d+)?[\w\.]+)/i,                                  // Internet Explorer

            // Webkit/KHTML based
            /(rekonq)((?:\/)[\w\.]+)*/i,                                        // Rekonq
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron)\/((\d+)?[\w\.-]+)/i
                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron
            ], [NAME, VERSION, MAJOR], [

            /(trident).+rv[:\s]((\d+)?[\w\.]+).+like\sgecko/i                   // IE11
            ], [[NAME, 'IE'], VERSION, MAJOR], [

            /(yabrowser)\/((\d+)?[\w\.]+)/i                                     // Yandex
            ], [[NAME, 'Yandex'], VERSION, MAJOR], [

            /(comodo_dragon)\/((\d+)?[\w\.]+)/i                                 // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION, MAJOR], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?((\d+)?[\w\.]+)/i
                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION, MAJOR], [

            /(dolfin)\/((\d+)?[\w\.]+)/i                                        // Dolphin
            ], [[NAME, 'Dolphin'], VERSION, MAJOR], [

            /((?:android.+)crmo|crios)\/((\d+)?[\w\.]+)/i                       // Chrome for Android/iOS
            ], [[NAME, 'Chrome'], VERSION, MAJOR], [

            /version\/((\d+)?[\w\.]+).+?mobile\/\w+\s(safari)/i                 // Mobile Safari
            ], [VERSION, MAJOR, [NAME, 'Mobile Safari']], [

            /version\/((\d+)?[\w\.]+).+?(mobile\s?safari|safari)/i              // Safari & Safari Mobile
            ], [VERSION, MAJOR, NAME], [

            /webkit.+?(mobile\s?safari|safari)((\/[\w\.]+))/i                   // Safari < 3.0
            ], [NAME, [MAJOR, mapper.str, maps.browser.oldsafari.major], [VERSION, mapper.str, maps.browser.oldsafari.version]], [

            /(konqueror)\/((\d+)?[\w\.]+)/i,                                    // Konqueror
            /(webkit|khtml)\/((\d+)?[\w\.]+)/i
            ], [NAME, VERSION, MAJOR], [

            // Gecko based
            /(navigator|netscape)\/((\d+)?[\w\.-]+)/i                           // Netscape
            ], [[NAME, 'Netscape'], VERSION, MAJOR], [
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?((\d+)?[\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/((\d+)?[\w\.-]+)/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(mozilla)\/((\d+)?[\w\.]+).+rv\:.+gecko\/\d+/i,                    // Mozilla

            // Other
            /(uc\s?browser|polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|qqbrowser)[\/\s]?((\d+)?[\w\.]+)/i,
                                                                                // UCBrowser/Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/QQBrowser
            /(links)\s\(((\d+)?[\w\.]+)/i,                                      // Links
            /(gobrowser)\/?((\d+)?[\w\.]+)*/i,                                  // GoBrowser
            /(ice\s?browser)\/v?((\d+)?[\w\._]+)/i,                             // ICE Browser
            /(mosaic)[\/\s]((\d+)?[\w\.]+)/i                                    // Mosaic
            ], [NAME, VERSION, MAJOR], [

            /(apple(?:coremedia|))\/((\d+)[\w\._]+)/i,                          // Generic Apple CoreMedia
            /(coremedia) v((\d+)[\w\._]+)/i
            ], [NAME, VERSION, MAJOR], [

            /(aqualung|lyssna|bsplayer)\/([\w\.-]+)/i                           // Aqualung/Lyssna/BSPlayer
            ], [NAME, VERSION], [

            /(ares|ossproxy)\s((\d+)[\w\.-]+)/i                                 // Ares/OSSProxy
            ], [NAME, VERSION, MAJOR], [

            /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\/((\d+)[\w\.-]+)/i,
                                                                                // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC
                                                                                // NSPlayer/PSP-InternetRadioPlayer/Videos
            /(clementine|music player daemon)\s((\d+)[\w\.-]+)/i,               // Clementine/MPD
            /(lg player|nexplayer)\s((\d+)[\d\.]+)/i,
            /player\/(nexplayer|lg player)\s((\d+)[\w\.-]+)/i                   // NexPlayer/LG Player
            ], [NAME, VERSION, MAJOR], [
            /(nexplayer)\s((\d+)[\w\.-]+)/i                                     // Nexplayer
            ], [NAME, VERSION, MAJOR], [

            /(flrp)\/((\d+)[\w\.-]+)/i                                            // Flip Player
            ], [[NAME, 'Flip Player'], VERSION, MAJOR], [

            /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i
                                                                                // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit
            ], [NAME], [

            /(gstreamer) souphttpsrc (?:\([^\)]+\)){0,1} libsoup\/((\d+)[\w\.-]+)/i
                                                                                // Gstreamer
            ], [NAME, VERSION, MAJOR], [

            /(htc streaming player)\s[\w_]+\s\/\s((\d+)[\d\.]+)/i,              // HTC Streaming Player
            /(java|python-urllib|python-requests|wget|libcurl)\/((\d+)[\w\.-_]+)/i,
                                                                                // Java/urllib/requests/wget/cURL
            /(lavf)((\d+)[\d\.]+)/i                                             // Lavf (FFMPEG)
            ], [NAME, VERSION, MAJOR], [

            /(htc_one_s)\/((\d+)[\d\.]+)/i,                                     // HTC One S
            ], [[NAME, /_/g, ' '], VERSION, MAJOR], [

            /(mplayer)(?:\s|\/)(?:(?:sherpya-){0,1}svn)(?:-|\s)(r\d+(?:-\d+[\w\.-]+){0,1})/i,
                                                                                // MPlayer SVN
            ], [NAME, VERSION], [

            /(mplayer)(?:\s|\/)((\d+)[\w\.-]+)/i,                               // MPlayer
            /(mplayer) unknown-((\d+)[\w\.\-]+)/i                               // MPlayer UNKNOWN
            ], [NAME, VERSION, MAJOR], [

            /(mplayer)/i,                                                       // MPlayer (no other info)
            /(yourmuze)/i,                                                      // YourMuze
            /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime
            ], [NAME], [

            /(nero (?:home|scout))\/((\d+)[\w\.-]+)/i                           // Nero Home/Nero Scout
            ], [NAME, VERSION, MAJOR], [

            /(nokia\d+)\/((\d+)[\w\.-]+)/i                                      // Nokia
            ], [NAME, VERSION, MAJOR], [

            /\s(songbird)\/((\d+)[\w\.-]+)/i                                    // Songbird/Philips-Songbird
            ], [NAME, VERSION, MAJOR], [

            /(winamp)3 version ((\d+)[\w\.-]+)/i,                               // Winamp
            /(winamp)\s((\d+)[\w\.-]+)/i,
            /(winamp)mpeg\/((\d+)[\w\.-]+)/i
            ], [NAME, VERSION, MAJOR], [

            /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)
                                                                                // inlight radio
            ], [NAME], [

            /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\/((\d+)[\w\.-]+)/i
                                                                                // QuickTime/RealMedia/RadioApp/RadioClientApplication/
                                                                                // SoundTap/Totem/Stagefright/Streamium
            ], [NAME, VERSION, MAJOR], [

            /(smp)((\d+)[\d\.]+)/i                                              // SMP
            ], [NAME, VERSION, MAJOR], [

            /(vlc) media player - version ((\d+)[\w\.]+)/i,                     // VLC Videolan
            /(vlc)\/((\d+)[\w\.-]+)/i,
            /(xbmc|gvfs|xine|xmms|irapp)\/((\d+)[\w\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp
            /(foobar2000)\/((\d+)[\d\.]+)/i,                                    // Foobar2000
            /(itunes)\/((\d+)[\d\.]+)/i                                         // iTunes
            ], [NAME, VERSION, MAJOR], [

            /(wmplayer)\/((\d+)[\w\.-]+)/i,                                     // Windows Media Player
            /(windows-media-player)\/((\d+)[\w\.-]+)/i
            ], [[NAME, /-/g, ' '], VERSION, MAJOR], [

            /windows\/((\d+)[\w\.-]+) upnp\/[\d\.]+ dlnadoc\/[\d\.]+ (home media server)/i,
                                                                                // Windows Media Server
            ], [VERSION, MAJOR, [NAME, 'Windows']], [

            /(com\.riseupradioalarm)\/((\d+)[\d\.]*)/i                          // RiseUP Radio Alarm
            ], [NAME, VERSION, MAJOR], [

            /(rad.io)\s((\d+)[\d\.]+)/i,                                        // Rad.io
            /(radio.(?:de|at|fr))\s((\d+)[\d\.]+)/i
            ], [[NAME, 'rad.io'], VERSION, MAJOR]

        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32
            ], [[ARCHITECTURE, 'ia32']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /(ia64(?=;)|68k(?=\))|arm(?=v\d+;)|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                // IA64, 68K, ARM, IRIX, MIPS, SPARC, PA-RISC
            ], [ARCHITECTURE, util.lowerize]
        ],

        device : [[

            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [

            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            /(apple\s{0,1}tv)/i                                                 // Apple TV
            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

            /(hp).+(touchpad)/i,                                                // HP TouchPad
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola)[\s_-]?([\w-]+)*/i,
                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Huawei/Meizu/Motorola
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i                                                    // Asus
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /\((bb10);\s(\w+)/i                                                 // BlackBerry 10
            ], [[VENDOR, 'BlackBerry'], MODEL, [TYPE, MOBILE]], [
                                                                                // Asus Tablets
            /android.+((transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7))/i
            ], [[VENDOR, 'Asus'], MODEL, [TYPE, TABLET]], [

            /(sony)\s(tablet\s[ps])/i                                           // Sony Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

            /((playstation)\s[3portablevi]+)/i                                  // Playstation
            ], [[VENDOR, 'Sony'], MODEL, [TYPE, CONSOLE]], [

            /(sprint\s(\w+))/i                                                  // Sprint Phones
            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
            /(zte)-(\w+)*/i,                                                    // ZTE
            /(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i
                                                                                // Alcatel/GeeksPhone/Huawei/Lenovo/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

                                                                                // Motorola
            /\s((milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?))[\w\s]+build\//i,
            /(mot)[\s-]?(\w+)*/i
            ], [[VENDOR, 'Motorola'], MODEL, [TYPE, MOBILE]], [
            /android.+\s((mz60\d|xoom[\s2]{0,2}))\sbuild\//i
            ], [[VENDOR, 'Motorola'], MODEL, [TYPE, TABLET]], [

            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n8000|sgh-t8[56]9|nexus 10))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus))/i,
            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,
            /sec-((sgh\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [
            /(sie)-(\w+)*/i                                                     // Siemens
            ], [[VENDOR, 'Siemens'], MODEL, [TYPE, MOBILE]], [

            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
            /(nokia)[\s_-]?([\w-]+)*/i
            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

            /android\s3\.[\s\w-;]{10}((a\d{3}))/i                               // Acer
            ], [[VENDOR, 'Acer'], MODEL, [TYPE, TABLET]], [

            /android\s3\.[\s\w-;]{10}(lg?)-([06cv9]{3,4})/i                     // LG
            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
            /((nexus\s[45]))/i,
            /(lg)[e;\s-\/]+(\w+)*/i
            ], [[VENDOR, 'LG'], MODEL, [TYPE, MOBILE]], [
                
             /android.+((ideatab[a-z0-9\-\s]+))/i                               // Lenovo
            ], [[VENDOR, 'Lenovo'], MODEL, [TYPE, TABLET]], [
                
            /(lg) netcast\.tv/i                                                 // LG SmartTV
            ], [VENDOR, [TYPE, SMARTTV]], [

            /(mobile|tablet);.+rv\:.+gecko\//i                                  // Unidentifiable
            ], [TYPE, VENDOR, MODEL]
        ],

        engine : [[

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows based
            /microsoft\s(windows)\s(vista|xp)/i,                                // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*|windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // Mobile/Embedded OS
            /\((bb)(10);/i                                                      // BlackBerry 10
            ], [[NAME, 'BlackBerry'], VERSION], [
            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
            /(tizen)\/([\w\.]+)/i,                                              // Tizen
            /(android|webos|palm\os|qnx|bada|rim\stablet\sos|meego)[\/\s-]?([\w\.]+)*/i
                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo
            ], [NAME, VERSION], [
            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
            ], [[NAME, 'Symbian'], VERSION],[
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS'], VERSION], [

            // Console
            /(nintendo|playstation)\s([wids3portablevu]+)/i,                    // Nintendo/Playstation

            // GNU/Linux based
            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk)[\/\s-]?([\w\.-]+)*/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk
            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
            /(gnu)\s?([\w\.]+)*/i                                               // GNU
            ], [NAME, VERSION], [

            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Solaris
            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
            ], [[NAME, 'Solaris'], VERSION], [

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            ], [NAME, VERSION],[

            /(ip[honead]+)(?:.*os\s*([\w]+)*\slike\smac|;\sopera)/i             // iOS
            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [

            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i                                    // Mac OS
            ], [NAME, [VERSION, /_/g, '.']], [

            // Other
            /(haiku)\s(\w+)/i,                                                  // Haiku
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
            /(macintosh|mac(?=_powerpc)|plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos)/i,
                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS
            /(unix)\s?([\w\.]+)*/i                                              // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////


    var UAParser = function (uastring) {

        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);

        if (!(this instanceof UAParser)) {
            return new UAParser(uastring).getResult();
        }
        this.getBrowser = function () {
            return mapper.rgx.apply(this, regexes.browser);
        };
        this.getCPU = function () {
            return mapper.rgx.apply(this, regexes.cpu);
        };
        this.getDevice = function () {
            return mapper.rgx.apply(this, regexes.device);
        };
        this.getEngine = function () {
            return mapper.rgx.apply(this, regexes.engine);
        };
        this.getOS = function () {
            return mapper.rgx.apply(this, regexes.os);
        };
        this.getResult = function() {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return ua;
        };
        this.setUA = function (uastring) {
            ua = uastring;
            return this;
        };
        this.setUA(ua);
    };


    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof(module) !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // browser env
        // Stop putting it on window
        // window.UAParser = UAParser;
        // requirejs env (optional)
        if (typeof(define) === FUNC_TYPE && define.amd) {
            define('vendor/ua-parser',[],function () {
                return UAParser;
            });
        }
        // jQuery specific (optional)
        if (typeof(window.jQuery) !== UNDEF_TYPE) {
            var $ = window.jQuery;
            var parser = new UAParser();
            $.ua = parser.getResult();
            $.ua.get = function() {
                return parser.getUA();
            };
            $.ua.set = function (uastring) {
                parser.setUA(uastring);
                var result = parser.getResult();
                for (var prop in result) {
                    $.ua[prop] = result[prop];
                }
            };
        }
    }

})(this);
define('utils/browserutils',[
  'vendor/ua-parser'
],
    function (UAParser) {
      var browserUtils = {
        getBrowser: function() {
          var parser = new UAParser(),
              engine = parser.getEngine();

          return engine;
        },
        getDevice: function() {
          var parser = new UAParser(),
              device = parser.getDevice();

          return device;
        },
        isIE: function() {
          var browser = browserUtils.getBrowser();

          return browser.name === 'Trident';
        },
        isBrowserSupported: function() {
          var parser = new UAParser(),
              result = parser.getResult(),
              browser = result.browser,
              device = result.device;

          if(device.type === 'mobile' || device.type === 'tablet') {
            if(browser.name === 'Chrome' && browser.major < 18) {
                return false;
            } else if(browser.name === 'Mobile Safari' && browser.major < 5) {
                return false;
            } else if(browser.name === 'IEMobile' && browser.major < 10) {
                return false;
            } else {
                return true;
            }
          } else {
            if(browser.name === 'Chrome' && browser.major < 22) {
                return false;
            } else if(browser.name === 'Firefox' && browser.major < 17) {
                return false;
            } else if(browser.name === 'IE' && browser.major < 9) {
                return false;
            } else if(browser.name === 'Safari' && browser.major < 6) {
                return false;
            } else {
                return true;
            }
          }

          return true;
        }
      };
      return browserUtils;
    });
define('utils/componentutils',[

],
    function () {
      var componentUtils = {
        idGen: function() {
          var _id = 'rfc';
          for(var i=-1; ++i<6;) {
            _id += Math.floor(Math.random() * 10);
          }
          return _id;
        }
      };
      return componentUtils;
    });
define('core/dashboard',[
  "core/rfclass",
  "generated/templates",
  "utils/positionutils",
  "utils/layoutmanager",
  "utils/media",
  "helpers/mediahelper",
  "constants/componentconstants",
  "utils/browserutils",
  "utils/componentutils",
  'vendor/lodash'
  // "helpers/logginghelper",
  // "themebuilder/main"
], function (RFClass, JST, positionUtils, LayoutManager, mediaUtils, MediaHelper, ComponentConstants, browserUtils, componentUtils, _) {

  function Dashboard(_id) {
    RFClass.call(this);

    rf.globals.dbRegistry.registerDashboard('default', this);

    var self = this,
        base = {},
        Public = {},
        raw = self._raw,
        title = "",
        Protected,
        pro = self.pro,
        _bp = {},
        id = _id || componentUtils.idGen();

    var components = [],
        componentContainers = [],
        $containerDiv,
        $coreDiv,
        $hiddenDiv,
        $ninjaDiv,
        automaticLayoutManagement = true,
        currentWidth = 0,
        resizeWatchDelay = ComponentConstants.dashboard.resizeDelay,
        newLocation = [],
        forceSmallScreenMode = false,
        forceBigScreenMode = false,
        isEmbedded = false,
        disableResizeWatcher = false,
        logs = null,
        logger = null,
        MINIKPI_MAX = 6,
        forceResizeFlag = false;

    // Register this dashboard as soon as it is created
    rf.globals.dbRegistry.registerDashboard(id, this);

    Public = {
      setDashboardTitle: function (dashboardTitle) {
        title = dashboardTitle;
      },
      renderTo: function ($jqDiv) {
        var newMedia;
        rf.globals.dbRegistry.setCurrentDashboard(id);
        $containerDiv = $jqDiv;
        $containerDiv.css({
          'margin': '0 auto'
        });
        if(!browserUtils.isBrowserSupported()) {
          $containerDiv.html(JST.browser_error({}));
          return;
        }
        init();
        renderShell();
        newMedia = mediaUtils.calculateMedia($coreDiv.width());
        mediaUtils.applyMediaToNode($jqDiv, newMedia);
        pro.media.setMedia(newMedia);
        renderCore();
        currentWidth = $coreDiv.width();
        resize();
        resizeWatcher();
        pro.addServerLogButtonListener();
      },
      embedTo: function(divID, opts) {
        // TODO: Extract common functionality between renderTo and embedTo
        disableResizeWatcher = false;
        var $jqDiv = $('#' + divID),
            newMedia;

        isEmbedded = true;
        rf.globals.dbRegistry.setCurrentDashboard(id);
        opts = opts || {};
        forceBigScreenMode = !!opts.forceBigScreenMode;
        forceSmallScreenMode = !!opts.forceSmallScreenMode;
        $containerDiv = $jqDiv;
        if(!browserUtils.isBrowserSupported()) {
          $containerDiv.html(JST.browser_error({}));
          return;
        }
        pro.setEmbeddedWidthHeight();
        init();
        renderShell();
        newMedia = mediaUtils.calculateMedia($coreDiv.width());
        mediaUtils.applyMediaToNode($jqDiv, newMedia);
        pro.media.setMedia(newMedia);
        renderCore();
        currentWidth = $coreDiv.width();
        resize();
        resizeWatcher();
        pro.addServerLogButtonListener();
      },
      addComponent: function (component) {
        components.push(component);
        component.pro.linkToDashboard(self);
        self.trigger("componentAdd");
      },

      // TODO: Move these functions to pro
      /**
       * Creates a temporary div, appends it to the dashboard and returns the reference. Meant to be used as canaries
       */
      _makeTempDiv: function() {
        var $tempDiv = $('<div/>');
        $hiddenDiv.append($tempDiv);
        return $tempDiv;
      },
      /**
       * Returns the dashboards ninja div
       */
      _getNinjaDiv: function() {
        return $ninjaDiv;
      },
      /**
       * Returns the dashboards Modal div
       */
      _getModalDiv: function() {
        return $containerDiv.find('.rfDashboardModals');
      },
      /**
       * Removes a component from the dashboard
       * @param  {Component} c The component which needs to be removed from the dashboard
       */
      removeComponent: function(c) {
        var id = c.getID();
        _.remove(components, function(item) {return item.getID() === id;});
        self.trigger("componentRemove");
        redraw();
      },
      setWidth: function(_width) {
        pro.embeddedWidth = _width;

        if($containerDiv){
          $containerDiv.width(pro.embeddedWidth);
        }
      },
      setInterval: function(cb, delay) {
        var interval = setInterval(function () {
          if(!disableResizeWatcher) {
            cb();
          } else {
            clearInterval(interval);
          }
        }, delay);
      },
      setHeight: function(_height) {
        pro.embeddedHeight = _height;

        if($containerDiv){
          $containerDiv.height(pro.embeddedHeight);
        }
      },
      setMaxHeight: function(_height) {
        $containerDiv.css({
          'max-height': _height
        });
      }
    };

    Protected = {
      media: new MediaHelper(),

      embeddedWidth: null,

      embeddedHeight: null,

      logger: logger,

      $serverLogButton: null,

      isTabbed: false,

      getMediaHelper: function () {
        return pro.media;
      },

      getDashboardTitle: function () {
        return title;
      },

      getID: function () {
        return id;
      },

      setResizeWatcher: function () {
        if (disableResizeWatcher) {
          disableResizeWatcher = false;
          resizeWatcher();
        }
      },

      setLogs: function(request, logs) {
        pro.logger.append(request, logs);
      },

      _serializeComponents: function () {
        var obj = {
          components: []
        };
        for (var i = -1; ++i < components.length;) {
          var component = components[i];
          obj.components.push(component.pro._serializeComponent());
        }

        return obj;
      },
      _buildFromObject: function (dbObj) {
        var components = dbObj.components;

        for (var i = -1; ++i < components.length;) {
          var component = components[i];
          var cObj = createComponentByName(component.type);
          cObj.pro._buildFromObject(component);

          self.addComponent(cObj);
        }
      },
      getComponentByID: function (id) {
        return _.find(components, function (val) { return val.getID() === id;});
      },

      setEmbeddedWidthHeight: function() {

        if(pro.embeddedWidth){
          pro.$containerDiv.width(pro.embeddedWidth);
        }

        if(pro.embeddedHeight){
          pro.$containerDiv.height(pro.embeddedHeight);
        }
      },

      addServerLogButtonListener: function() {
        pro.$serverLogButton.on('click', function() {
          pro.logger.toggle();
        });
      },

      dispose: function () {
        disableResizeWatcher = true;
        // var componentLength = components.length;
        // while(componentLength--) {
        //   self.removeComponent(components[0]);
        // }
      },

      // Locks all the components in the dashboard.
      lock: function() {
        for(var i=0; i<components.length; i++) {
          components[i].lock();
        }
      },

      forceResize: function (_width) {
        $containerDiv.css({
          "width" : _width
        });
        forceResizeFlag = true;
        resize();
      }
    };

    var init = function () {
      self.trigger("dashboardOnInitialize");
      for (var i = 0; i < components.length; i++) {
        components[i].pro.init();
      }
    };

    var applyMedia = function () {
      var newMedia = mediaUtils.calculateMedia(currentWidth);
      var dbTarget = $containerDiv;
      if(forceSmallScreenMode) {
        newMedia = 'xs';
      } else if(forceBigScreenMode) {
        newMedia = 'lg';
      }
      if (newMedia !== pro.media.getCurrentMedia()) {
        mediaUtils.applyMediaToNode(dbTarget, newMedia);
        pro.media.setMedia(newMedia);
        redraw();
        return true;
      }
      return false;
    };

    var renderShell = function() {
      if(!isEmbedded) {
        $containerDiv.html(JST.dashboard_standalone({
          title: title
        }));
      } else {
        $containerDiv.html(JST.dashboard_embedded({
          tabbed: pro.isTabbed
        }));
      }

      $coreDiv = $containerDiv.find(".rfDashboardCore");
      $hiddenDiv = $containerDiv.find(".rfDashboardHidden");
      $ninjaDiv = $containerDiv.find(".rfDashboardNinja");
      pro.$serverLogButton = $containerDiv.find(".rfServerLogButton");
    };

    var renderCore = function() {
      var layoutManager = new LayoutManager();

      componentContainers = [];

      components = _.sortBy(components, function(component) {
          return component.pro.pb.getValue('core.index');
      });
      
      // Iterate over the containers
      for (var i = 0; i < components.length; i++) {
        if(!components[i].pro.pb.getValue('core.isHidden')) {
          var component = components[i];
          var componentDiv = $("<div/>", {
                'class': 'rfComponentContainer'
              }),location = component.pro.pb.getObjectAtPath('core.location'),
              cssObj = null,
              currentMedia = pro.media.getCurrentMedia(),
              kpis = component.pro.pb.getObjectAtPath('kpis'),
              numKPIs = _.keys(kpis).length,
              className = component._raw.className;
          /**
           * When the media size is xs or sm get the overriden dimensions for that particular component and apply them
           */
          if(currentMedia === 'xs' || currentMedia === 'sm') {
            location = _.cloneDeep(component.pro.overriddenDimensions[currentMedia]);
          }
          if(className !== 'KPIComponent' && className !== 'KPIGroupComponent' && className !== 'KPITableComponent') {
            if(currentMedia === 'xs' && _.keys(kpis).length) {
                var numPossibleKPIs = numKPIs < MINIKPI_MAX ? numKPIs : MINIKPI_MAX,
                    extraHeight = (numPossibleKPIs / 2) * 3;
                location.h += extraHeight;
            }
          } else if(className === 'KPITableComponent') {
            if(currentMedia === 'xs' && _.keys(kpis).length) {
              location.h = 4 + numKPIs;   
            }
          }
          if (!(_.isNumber(location.w) && !_.isNaN(location.w)) ||
              !(_.isNumber(location.h) && !_.isNaN(location.h)) ||
              location.h === 0 ||
              location.w === 0) {
            location.w = component.pro.overriddenDimensions[currentMedia].w;
            location.h = component.pro.overriddenDimensions[currentMedia].h;
          }
          /**
           * If automaticLayoutManagement is true, use Ameen's awesome layoutmanager to create the locations
           */
          if (automaticLayoutManagement) {
            var layout = layoutManager.findEmptySpot(location.w, location.h);
            location.x = layout.col;
            location.y = layout.row;
          }

          newLocation[i] = location;

          cssObj = {
            left: positionUtils.unitsToPcString(location.x),
            width: positionUtils.unitsToPcString(location.w)
          };
          componentDiv.css(cssObj);
          $coreDiv.append(componentDiv);

          // push the component into the comoponent conatiner array so it can be used later
          componentContainers.push(componentDiv);

          // Render the component
          component.pro.setTargetContainer(componentDiv);
          component.pro.render();
        }
      }
      _.defer (function () {
        rf.hooks.trigger("_internalDashboardRendered", {
          db: self,
          coreDiv: $containerDiv
        });
        self.trigger("renderFinished");
      });
    };

    var render = function () {
      renderShell();
      renderCore();
    };

    var resizeWatcher = function () {
      if(!disableResizeWatcher) {
        var newWidth = $coreDiv.width();
        if (newWidth !== currentWidth) {
          currentWidth = newWidth;
          resize();
          currentWidth = $coreDiv.width();
        }
        _.defer(function () {
            _.delay(resizeWatcher, resizeWatchDelay);
        });
      }
    };

    var redraw = function () {
      // TODO: This is a temporary hack implmented to cleanup till charts get a dispose function
      $('.rfTooltip').remove();
      rf.globals.dbRegistry.setCurrentDashboard(id);
      render();
      resize();
    };

    var resize = function () {
      if(disableResizeWatcher && !forceResizeFlag) {
        return;
      }
      var dbWidth = $coreDiv.width(), maxHeight = 0, cssObj = {};

      // Check if there has been a new media applied, if then, don't
      // bother resizing.
      if (applyMedia()) {
        return;
      }

      for (var i = 0; i < components.length; i++) {
        if(!components[i].pro.pb.getValue('core.isHidden')) {
          var cobj = components[i],
              cContainer = componentContainers[i],
              location = newLocation[i];
          cssObj = {
            top: positionUtils.unitsToPixels(location.y, dbWidth),
            height: positionUtils.unitsToPixels(location.h, dbWidth)
          };
          cContainer.css(cssObj);
          cobj.pro.resize(cContainer.width(), cContainer.height());
          maxHeight = _.max([maxHeight, cssObj.top + cssObj.height]);
          $coreDiv.height(maxHeight);
        }
      }
      _.defer(function () {
        self.trigger("resizeFinished");
      });
      // ThemeBuilder.init();
    };

    var createComponentByName = function (name) {
    
    };

    raw._registerClassName("Dashboard");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    
  }

  return Dashboard;
});

/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.data.odata',[ "./kendo.core" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        extend = $.extend,
        odataFilters = {
            eq: "eq",
            neq: "ne",
            gt: "gt",
            gte: "ge",
            lt: "lt",
            lte: "le",
            contains : "substringof",
            doesnotcontain: "substringof",
            endswith: "endswith",
            startswith: "startswith"
        },
        mappers = {
            pageSize: $.noop,
            page: $.noop,
            filter: function(params, filter) {
                if (filter) {
                    params.$filter = toOdataFilter(filter);
                }
            },
            sort: function(params, orderby) {
                var expr = $.map(orderby, function(value) {
                    var order = value.field.replace(/\./g, "/");

                    if (value.dir === "desc") {
                        order += " desc";
                    }

                    return order;
                }).join(",");

                if (expr) {
                    params.$orderby = expr;
                }
            },
            skip: function(params, skip) {
                if (skip) {
                    params.$skip = skip;
                }
            },
            take: function(params, take) {
                if (take) {
                    params.$top = take;
                }
            }
        },
        defaultDataType = {
            read: {
                dataType: "jsonp"
            }
        };

    function toOdataFilter(filter) {
        var result = [],
            logic = filter.logic || "and",
            idx,
            length,
            field,
            type,
            format,
            operator,
            value,
            ignoreCase,
            filters = filter.filters;

        for (idx = 0, length = filters.length; idx < length; idx++) {
            filter = filters[idx];
            field = filter.field;
            value = filter.value;
            operator = filter.operator;

            if (filter.filters) {
                filter = toOdataFilter(filter);
            } else {
                ignoreCase = filter.ignoreCase;
                field = field.replace(/\./g, "/");
                filter = odataFilters[operator];

                if (filter && value !== undefined) {
                    type = $.type(value);
                    if (type === "string") {
                        format = "'{1}'";
                        value = value.replace(/'/g, "''");

                        if (ignoreCase === true) {
                            field = "tolower(" + field + ")";
                        }

                    } else if (type === "date") {
                        format = "datetime'{1:yyyy-MM-ddTHH:mm:ss}'";
                    } else {
                        format = "{1}";
                    }

                    if (filter.length > 3) {
                        if (filter !== "substringof") {
                            format = "{0}({2}," + format + ")";
                        } else {
                            format = "{0}(" + format + ",{2})";
                            if (operator === "doesnotcontain") {
                                format += " eq false";
                            }
                        }
                    } else {
                        format = "{2} {0} " + format;
                    }

                    filter = kendo.format(format, filter, value, field);
                }
            }

            result.push(filter);
        }

        filter = result.join(" " + logic + " ");

        if (result.length > 1) {
            filter = "(" + filter + ")";
        }

        return filter;
    }

    extend(true, kendo.data, {
        schemas: {
            odata: {
                type: "json",
                data: function(data) {
                    return data.d.results || [data.d];
                },
                total: "d.__count"
            }
        },
        transports: {
            odata: {
                read: {
                    cache: true, // to prevent jQuery from adding cache buster
                    dataType: "jsonp",
                    jsonp: "$callback"
                },
                update: {
                    cache: true,
                    dataType: "json",
                    contentType: "application/json", // to inform the server the the request body is JSON encoded
                    type: "PUT" // can be PUT or MERGE
                },
                create: {
                    cache: true,
                    dataType: "json",
                    contentType: "application/json",
                    type: "POST" // must be POST to create new entity
                },
                destroy: {
                    cache: true,
                    dataType: "json",
                    type: "DELETE"
                },
                parameterMap: function(options, type) {
                    var params,
                        value,
                        option,
                        dataType;

                    options = options || {};
                    type = type || "read";
                    dataType = (this.options || defaultDataType)[type];
                    dataType = dataType ? dataType.dataType : "json";

                    if (type === "read") {
                        params = {
                            $inlinecount: "allpages"
                        };

                        if (dataType != "json") {
                            params.$format = "json";
                        }

                        for (option in options) {
                            if (mappers[option]) {
                                mappers[option](params, options[option]);
                            } else {
                                params[option] = options[option];
                            }
                        }
                    } else {
                        if (dataType !== "json") {
                            throw new Error("Only json dataType can be used for " + type + " operation.");
                        }

                        if (type !== "destroy") {
                            for (option in options) {
                                value = options[option];
                                if (typeof value === "number") {
                                    options[option] = value + "";
                                }
                            }

                            params = kendo.stringify(options);
                        }
                    }

                    return params;
                }
            }
        }
    });
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.data.xml',[ "./kendo.core" ], f);
})(function(){

/*jshint  eqnull: true, boss: true */
(function($, undefined) {
    var kendo = window.kendo,
        isArray = $.isArray,
        isPlainObject = $.isPlainObject,
        map = $.map,
        each = $.each,
        extend = $.extend,
        getter = kendo.getter,
        Class = kendo.Class;

    var XmlDataReader = Class.extend({
        init: function(options) {
            var that = this,
                total = options.total,
                model = options.model,
                parse = options.parse,
                errors = options.errors,
                serialize = options.serialize,
                data = options.data;

            if (model) {
                if (isPlainObject(model)) {
                    var base = options.modelBase || kendo.data.Model;

                    if (model.fields) {
                        each(model.fields, function(field, value) {
                            if (isPlainObject(value) && value.field) {
                                value = extend(value, { field: that.getter(value.field) });
                            } else {
                                value = { field: that.getter(value) };
                            }
                            model.fields[field] = value;
                        });
                    }

                    var id = model.id;
                    if (id) {
                        var idField = {};

                        idField[that.xpathToMember(id, true)] = { field : that.getter(id) };
                        model.fields = extend(idField, model.fields);
                        model.id = that.xpathToMember(id);
                    }
                    model = base.define(model);
                }

                that.model = model;
            }

            if (total) {
                if (typeof total == "string") {
                    total = that.getter(total);
                    that.total = function(data) {
                        return parseInt(total(data), 10);
                    };
                } else if (typeof total == "function"){
                    that.total = total;
                }
            }

            if (errors) {
                if (typeof errors == "string") {
                    errors = that.getter(errors);
                    that.errors = function(data) {
                        return errors(data) || null;
                    };
                } else if (typeof errors == "function"){
                    that.errors = errors;
                }
            }

            if (data) {
                if (typeof data == "string") {
                    data = that.xpathToMember(data);
                    that.data = function(value) {
                        var result = that.evaluate(value, data),
                            modelInstance;

                        result = isArray(result) ? result : [result];

                        if (that.model && model.fields) {
                            modelInstance = new that.model();

                            return map(result, function(value) {
                                if (value) {
                                    var record = {}, field;

                                    for (field in model.fields) {
                                        record[field] = modelInstance._parse(field, model.fields[field].field(value));
                                    }

                                    return record;
                                }
                            });
                        }

                        return result;
                    };
                } else if (typeof data == "function") {
                    that.data = data;
                }
            }

            if (typeof parse == "function") {
                var xmlParse = that.parse;

                that.parse = function(data) {
                    var xml = parse.call(that, data);
                    return xmlParse.call(that, xml);
                };
            }

            if (typeof serialize == "function") {
                that.serialize = serialize;
            }
        },
        total: function(result) {
            return this.data(result).length;
        },
        errors: function(data) {
            return data ? data.errors : null;
        },
        serialize: function(data) {
            return data;
        },
        parseDOM: function(element) {
            var result = {},
                parsedNode,
                node,
                nodeType,
                nodeName,
                member,
                attribute,
                attributes = element.attributes,
                attributeCount = attributes.length,
                idx;

            for (idx = 0; idx < attributeCount; idx++) {
                attribute = attributes[idx];
                result["@" + attribute.nodeName] = attribute.nodeValue;
            }

            for (node = element.firstChild; node; node = node.nextSibling) {
                nodeType = node.nodeType;

                if (nodeType === 3 || nodeType === 4) {
                    // text nodes or CDATA are stored as #text field
                    result["#text"] = node.nodeValue;
                } else if (nodeType === 1) {
                    // elements are stored as fields
                    parsedNode = this.parseDOM(node);

                    nodeName = node.nodeName;

                    member = result[nodeName];

                    if (isArray(member)) {
                        // elements of same nodeName are stored as array
                        member.push(parsedNode);
                    } else if (member !== undefined) {
                        member = [member, parsedNode];
                    } else {
                        member = parsedNode;
                    }

                    result[nodeName] = member;
                }
            }
            return result;
        },

        evaluate: function(value, expression) {
            var members = expression.split("."),
                member,
                result,
                length,
                intermediateResult,
                idx;

            while (member = members.shift()) {
                value = value[member];

                if (isArray(value)) {
                    result = [];
                    expression = members.join(".");

                    for (idx = 0, length = value.length; idx < length; idx++) {
                        intermediateResult = this.evaluate(value[idx], expression);

                        intermediateResult = isArray(intermediateResult) ? intermediateResult : [intermediateResult];

                        result.push.apply(result, intermediateResult);
                    }

                    return result;
                }
            }

            return value;
        },

        parse: function(xml) {
            var documentElement,
                tree,
                result = {};

            documentElement = xml.documentElement || $.parseXML(xml).documentElement;

            tree = this.parseDOM(documentElement);

            result[documentElement.nodeName] = tree;

            return result;
        },

        xpathToMember: function(member, raw) {
            if (!member) {
                return "";
            }

            member = member.replace(/^\//, "") // remove the first "/"
                           .replace(/\//g, "."); // replace all "/" with "."

            if (member.indexOf("@") >= 0) {
                // replace @attribute with '["@attribute"]'
                return member.replace(/\.?(@.*)/, raw? '$1':'["$1"]');
            }

            if (member.indexOf("text()") >= 0) {
                // replace ".text()" with '["#text"]'
                return member.replace(/(\.?text\(\))/, raw? '#text':'["#text"]');
            }

            return member;
        },
        getter: function(member) {
            return getter(this.xpathToMember(member), true);
        }
    });

    $.extend(true, kendo.data, {
        XmlDataReader: XmlDataReader,
        readers: {
            xml: XmlDataReader
        }
    });
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.data',[ "./kendo.core", "./kendo.data.odata", "./kendo.data.xml" ], f);
})(function(){

/*jshint eqnull: true, loopfunc: true, evil: true */
(function($, undefined) {
    var extend = $.extend,
        proxy = $.proxy,
        isPlainObject = $.isPlainObject,
        isEmptyObject = $.isEmptyObject,
        isArray = $.isArray,
        grep = $.grep,
        ajax = $.ajax,
        map,
        each = $.each,
        noop = $.noop,
        kendo = window.kendo,
        isFunction = kendo.isFunction,
        Observable = kendo.Observable,
        Class = kendo.Class,
        STRING = "string",
        FUNCTION = "function",
        CREATE = "create",
        READ = "read",
        UPDATE = "update",
        DESTROY = "destroy",
        CHANGE = "change",
        SYNC = "sync",
        GET = "get",
        ERROR = "error",
        REQUESTSTART = "requestStart",
        PROGRESS = "progress",
        REQUESTEND = "requestEnd",
        crud = [CREATE, READ, UPDATE, DESTROY],
        identity = function(o) { return o; },
        getter = kendo.getter,
        stringify = kendo.stringify,
        math = Math,
        push = [].push,
        join = [].join,
        pop = [].pop,
        splice = [].splice,
        shift = [].shift,
        slice = [].slice,
        unshift = [].unshift,
        toString = {}.toString,
        stableSort = kendo.support.stableSort,
        dateRegExp = /^\/Date\((.*?)\)\/$/,
        newLineRegExp = /(\r+|\n+)/g,
        quoteRegExp = /(?=['\\])/g;

    var ObservableArray = Observable.extend({
        init: function(array, type) {
            var that = this;

            that.type = type || ObservableObject;

            Observable.fn.init.call(that);

            that.length = array.length;

            that.wrapAll(array, that);
        },

        toJSON: function() {
            var idx, length = this.length, value, json = new Array(length);

            for (idx = 0; idx < length; idx++){
                value = this[idx];

                if (value instanceof ObservableObject) {
                    value = value.toJSON();
                }

                json[idx] = value;
            }

            return json;
        },

        parent: noop,

        wrapAll: function(source, target) {
            var that = this,
                idx,
                length,
                parent = function() {
                    return that;
                };

            target = target || [];

            for (idx = 0, length = source.length; idx < length; idx++) {
                target[idx] = that.wrap(source[idx], parent);
            }

            return target;
        },

        wrap: function(object, parent) {
            var that = this,
                observable;

            if (object !== null && toString.call(object) === "[object Object]") {
                observable = object instanceof that.type || object instanceof Model;

                if (!observable) {
                    object = object instanceof ObservableObject ? object.toJSON() : object;
                    object = new that.type(object);
                }

                object.parent = parent;

                object.bind(CHANGE, function(e) {
                    that.trigger(CHANGE, {
                        field: e.field,
                        node: e.node,
                        index: e.index,
                        items: e.items || [this],
                        action: e.node  ? (e.action || "itemchange") : "itemchange"
                    });
                });
            }

            return object;
        },

        push: function() {
            var index = this.length,
                items = this.wrapAll(arguments),
                result;

            result = push.apply(this, items);

            this.trigger(CHANGE, {
                action: "add",
                index: index,
                items: items
            });

            return result;
        },

        slice: slice,

        join: join,

        pop: function() {
            var length = this.length, result = pop.apply(this);

            if (length) {
                this.trigger(CHANGE, {
                    action: "remove",
                    index: length - 1,
                    items:[result]
                });
            }

            return result;
        },

        splice: function(index, howMany, item) {
            var items = this.wrapAll(slice.call(arguments, 2)),
                result, i, len;

            result = splice.apply(this, [index, howMany].concat(items));

            if (result.length) {
                this.trigger(CHANGE, {
                    action: "remove",
                    index: index,
                    items: result
                });

                for (i = 0, len = result.length; i < len; i++) {
                    if (result[i].children) {
                        result[i].unbind(CHANGE);
                    }
                }
            }

            if (item) {
                this.trigger(CHANGE, {
                    action: "add",
                    index: index,
                    items: items
                });
            }
            return result;
        },

        shift: function() {
            var length = this.length, result = shift.apply(this);

            if (length) {
                this.trigger(CHANGE, {
                    action: "remove",
                    index: 0,
                    items:[result]
                });
            }

            return result;
        },

        unshift: function() {
            var items = this.wrapAll(arguments),
                result;

            result = unshift.apply(this, items);

            this.trigger(CHANGE, {
                action: "add",
                index: 0,
                items: items
            });

            return result;
        },

        indexOf: function(item) {
            var that = this,
                idx,
                length;

            for (idx = 0, length = that.length; idx < length; idx++) {
                if (that[idx] === item) {
                    return idx;
                }
            }
            return -1;
        },

        forEach: function(callback) {
            var idx = 0,
                length = this.length;

            for (; idx < length; idx++) {
                callback(this[idx], idx, this);
            }
        },

        map: function(callback) {
            var idx = 0,
                result = [],
                length = this.length;

            for (; idx < length; idx++) {
                result[idx] = callback(this[idx], idx, this);
            }

            return result;
        },

        filter: function(callback) {
            var idx = 0,
                result = [],
                item,
                length = this.length;

            for (; idx < length; idx++) {
                item = this[idx];
                if (callback(item, idx, this)) {
                    result[result.length] = item;
                }
            }

            return result;
        },

        find: function(callback) {
            var idx = 0,
                item,
                length = this.length;

            for (; idx < length; idx++) {
                item = this[idx];
                if (callback(item, idx, this)) {
                    return item;
                }
            }
        },

        every: function(callback) {
            var idx = 0,
                item,
                length = this.length;

            for (; idx < length; idx++) {
                item = this[idx];
                if (!callback(item, idx, this)) {
                    return false;
                }
            }

            return true;
        },

        some: function(callback) {
            var idx = 0,
                item,
                length = this.length;

            for (; idx < length; idx++) {
                item = this[idx];
                if (callback(item, idx, this)) {
                    return true;
                }
            }

            return false;
        },

        // non-standard collection methods
        remove: function(item) {
            this.splice(this.indexOf(item), 1);
        },

        empty: function() {
            this.splice(0, this.length);
        }
    });

    function eventHandler(context, type, field, prefix) {
        return function(e) {
            var event = {}, key;

            for (key in e) {
                event[key] = e[key];
            }

            if (prefix) {
                event.field = field + "." + e.field;
            } else {
                event.field = field;
            }

            if (type == CHANGE && context._notifyChange) {
                context._notifyChange(event);
            }

            context.trigger(type, event);
        };
    }

    var ObservableObject = Observable.extend({
        init: function(value) {
            var that = this,
                member,
                field,
                parent = function() {
                    return that;
                };

            Observable.fn.init.call(this);

            for (field in value) {
                member = value[field];

                if (field.charAt(0) != "_") {
                    member = that.wrap(member, field, parent);
                }

                that[field] = member;
            }

            that.uid = kendo.guid();
        },

        shouldSerialize: function(field) {
            return this.hasOwnProperty(field) && field !== "_events" && typeof this[field] !== FUNCTION && field !== "uid";
        },

        forEach: function(f) {
            for (var i in this) {
                if (this.shouldSerialize(i)) {
                    f(this[i], i);
                }
            }
        },

        toJSON: function() {
            var result = {}, value, field;

            for (field in this) {
                if (this.shouldSerialize(field)) {
                    value = this[field];

                    if (value instanceof ObservableObject || value instanceof ObservableArray) {
                        value = value.toJSON();
                    }

                    result[field] = value;
                }
            }

            return result;
        },

        get: function(field) {
            var that = this, result;

            that.trigger(GET, { field: field });

            if (field === "this") {
                result = that;
            } else {
                result = kendo.getter(field, true)(that);
            }

            return result;
        },

        _set: function(field, value) {
            var that = this;
            var composite = field.indexOf(".") >= 0;

            if (composite) {
                var paths = field.split("."),
                    path = "";

                while (paths.length > 1) {
                    path += paths.shift();
                    var obj = kendo.getter(path, true)(that);
                    if (obj instanceof ObservableObject) {
                        obj.set(paths.join("."), value);
                        return composite;
                    }
                    path += ".";
                }
            }

            kendo.setter(field)(that, value);

            return composite;
        },

        set: function(field, value) {
            var that = this,
                composite = field.indexOf(".") >= 0,
                current = kendo.getter(field, true)(that);

            if (current !== value) {

                if (!that.trigger("set", { field: field, value: value })) {
                    if (!composite) {
                        value = that.wrap(value, field, function() { return that; });
                    }
                    if (!that._set(field, value) || field.indexOf("(") >= 0 || field.indexOf("[") >= 0) {
                        that.trigger(CHANGE, { field: field });
                    }
                }
            }
        },

        parent: noop,

        wrap: function(object, field, parent) {
            var that = this,
                type = toString.call(object);

            if (object != null && (type === "[object Object]" || type === "[object Array]")) {
                var isObservableArray = object instanceof ObservableArray;
                var isDataSource = object instanceof DataSource;

                if (type === "[object Object]" && !isDataSource && !isObservableArray) {
                    if (!(object instanceof ObservableObject)) {
                        object = new ObservableObject(object);
                    }

                    if (object.parent() != parent()) {
                        object.bind(GET, eventHandler(that, GET, field, true));
                        object.bind(CHANGE, eventHandler(that, CHANGE, field, true));
                    }
                } else if (type === "[object Array]" || isObservableArray || isDataSource) {
                    if (!isObservableArray && !isDataSource) {
                        object = new ObservableArray(object);
                    }

                    if (object.parent() != parent()) {
                        object.bind(CHANGE, eventHandler(that, CHANGE, field, false));
                    }
                }

                object.parent = parent;
            }

            return object;
        }
    });

    function equal(x, y) {
        if (x === y) {
            return true;
        }

        var xtype = $.type(x), ytype = $.type(y), field;

        if (xtype !== ytype) {
            return false;
        }

        if (xtype === "date") {
            return x.getTime() === y.getTime();
        }

        if (xtype !== "object" && xtype !== "array") {
            return false;
        }

        for (field in x) {
            if (!equal(x[field], y[field])) {
                return false;
            }
        }

        return true;
    }

    var parsers = {
        "number": function(value) {
            return kendo.parseFloat(value);
        },

        "date": function(value) {
            return kendo.parseDate(value);
        },

        "boolean": function(value) {
            if (typeof value === STRING) {
                return value.toLowerCase() === "true";
            }
            return value != null ? !!value : value;
        },

        "string": function(value) {
            return value != null ? (value + "") : value;
        },

        "default": function(value) {
            return value;
        }
    };

    var defaultValues = {
        "string": "",
        "number": 0,
        "date": new Date(),
        "boolean": false,
        "default": ""
    };

    function getFieldByName(obj, name) {
        var field,
            fieldName;

        for (fieldName in obj) {
            field = obj[fieldName];
            if (isPlainObject(field) && field.field && field.field === name) {
                return field;
            } else if (field === name) {
                return field;
            }
        }
        return null;
    }

    var Model = ObservableObject.extend({
        init: function(data) {
            var that = this;

            if (!data || $.isEmptyObject(data)) {
                data = $.extend({}, that.defaults, data);
            }

            ObservableObject.fn.init.call(that, data);

            that.dirty = false;

            if (that.idField) {
                that.id = that.get(that.idField);

                if (that.id === undefined) {
                    that.id = that._defaultId;
                }
            }
        },

        shouldSerialize: function(field) {
            return ObservableObject.fn.shouldSerialize.call(this, field) && field !== "uid" && !(this.idField !== "id" && field === "id") && field !== "dirty" && field !== "_accessors";
        },

        _parse: function(field, value) {
            var that = this,
                fieldName = field,
                fields = (that.fields || {}),
                parse;

            field = fields[field];
            if (!field) {
                field = getFieldByName(fields, fieldName);
            }
            if (field) {
                parse = field.parse;
                if (!parse && field.type) {
                    parse = parsers[field.type.toLowerCase()];
                }
            }

            return parse ? parse(value) : value;
        },

        _notifyChange: function(e) {
            var action = e.action;

            if (action == "add" || action == "remove") {
                this.dirty = true;
            }
        },

        editable: function(field) {
            field = (this.fields || {})[field];
            return field ? field.editable !== false : true;
        },

        set: function(field, value, initiator) {
            var that = this;

            if (that.editable(field)) {
                value = that._parse(field, value);

                if (!equal(value, that.get(field))) {
                    that.dirty = true;
                    ObservableObject.fn.set.call(that, field, value, initiator);
                }
            }
        },

        accept: function(data) {
            var that = this,
                parent = function() { return that; },
                field;

            for (field in data) {
                var value = data[field];

                if (field.charAt(0) != "_") {
                    value = that.wrap(data[field], field, parent);
                }

                that._set(field, value);
            }

            if (that.idField) {
                that.id = that.get(that.idField);
            }

            that.dirty = false;
        },

        isNew: function() {
            return this.id === this._defaultId;
        }
    });

    Model.define = function(base, options) {
        if (options === undefined) {
            options = base;
            base = Model;
        }

        var model,
            proto = extend({ defaults: {} }, options),
            name,
            field,
            type,
            value,
            idx,
            length,
            fields = {},
            originalName,
            id = proto.id;

        if (id) {
            proto.idField = id;
        }

        if (proto.id) {
            delete proto.id;
        }

        if (id) {
            proto.defaults[id] = proto._defaultId = "";
        }

        if (toString.call(proto.fields) === "[object Array]") {
            for (idx = 0, length = proto.fields.length; idx < length; idx++) {
                field = proto.fields[idx];
                if (typeof field === STRING) {
                    fields[field] = {};
                } else if (field.field) {
                    fields[field.field] = field;
                }
            }
            proto.fields = fields;
        }

        for (name in proto.fields) {
            field = proto.fields[name];
            type = field.type || "default";
            value = null;
            originalName = name;

            name = typeof (field.field) === STRING ? field.field : name;

            if (!field.nullable) {
                value = proto.defaults[originalName !== name ? originalName : name] = field.defaultValue !== undefined ? field.defaultValue : defaultValues[type.toLowerCase()];
            }

            if (options.id === name) {
                proto._defaultId = value;
            }

            proto.defaults[originalName !== name ? originalName : name] = value;

            field.parse = field.parse || parsers[type];
        }

        model = base.extend(proto);
        model.define = function(options) {
            return Model.define(model, options);
        };

        if (proto.fields) {
            model.fields = proto.fields;
            model.idField = proto.idField;
        }

        return model;
    };

    var Comparer = {
        selector: function(field) {
            return isFunction(field) ? field : getter(field);
        },

        compare: function(field) {
            var selector = this.selector(field);
            return function (a, b) {
                a = selector(a);
                b = selector(b);

                if (a == null && b == null) {
                    return 0;
                }

                if (a == null) {
                    return -1;
                }

                if (b == null) {
                    return 1;
                }

                if (a.localeCompare) {
                    return a.localeCompare(b);
                }

                return a > b ? 1 : (a < b ? -1 : 0);
            };
        },

        create: function(sort) {
            var compare = sort.compare || this.compare(sort.field);

            if (sort.dir == "desc") {
                return function(a, b) {
                    return compare(b, a, true);
                };
            }

            return compare;
        },

        combine: function(comparers) {
            return function(a, b) {
                var result = comparers[0](a, b),
                    idx,
                    length;

                for (idx = 1, length = comparers.length; idx < length; idx ++) {
                    result = result || comparers[idx](a, b);
                }

                return result;
            };
        }
    };

    var StableComparer = extend({}, Comparer, {
        asc: function(field) {
            var selector = this.selector(field);
            return function (a, b) {
                var valueA = selector(a);
                var valueB = selector(b);

                if (valueA && valueA.getTime && valueB && valueB.getTime) {
                    valueA = valueA.getTime();
                    valueB = valueB.getTime();
                }

                if (valueA === valueB) {
                    return a.__position - b.__position;
                }

                if (valueA == null) {
                    return -1;
                }

                if (valueB == null) {
                    return 1;
                }

                if (valueA.localeCompare) {
                    return valueA.localeCompare(valueB);
                }

                return valueA > valueB ? 1 : -1;
            };
        },

        desc: function(field) {
            var selector = this.selector(field);
            return function (a, b) {
                var valueA = selector(a);
                var valueB = selector(b);

                if (valueA && valueA.getTime && valueB && valueB.getTime) {
                    valueA = valueA.getTime();
                    valueB = valueB.getTime();
                }

                if (valueA === valueB) {
                    return a.__position - b.__position;
                }

                if (valueA == null) {
                    return 1;
                }

                if (valueB == null) {
                    return -1;
                }

                if (valueB.localeCompare) {
                    return valueB.localeCompare(valueA);
                }

                return valueA < valueB ? 1 : -1;
            };
        },
        create: function(sort) {
           return this[sort.dir](sort.field);
        }
    });

    map = function (array, callback) {
        var idx, length = array.length, result = new Array(length);

        for (idx = 0; idx < length; idx++) {
            result[idx] = callback(array[idx], idx, array);
        }

        return result;
    };

    var operators = (function(){

        function quote(value) {
            return value.replace(quoteRegExp, "\\").replace(newLineRegExp, "");
        }

        function operator(op, a, b, ignore) {
            var date;

            if (b != null) {
                if (typeof b === STRING) {
                    b = quote(b);
                    date = dateRegExp.exec(b);
                    if (date) {
                        b = new Date(+date[1]);
                    } else if (ignore) {
                        b = "'" + b.toLowerCase() + "'";
                        a = "(" + a + " || '').toLowerCase()";
                    } else {
                        b = "'" + b + "'";
                    }
                }

                if (b.getTime) {
                    //b looks like a Date
                    a = "(" + a + "?" + a + ".getTime():" + a + ")";
                    b = b.getTime();
                }
            }

            return a + " " + op + " " + b;
        }

        return {
            eq: function(a, b, ignore) {
                return operator("==", a, b, ignore);
            },
            neq: function(a, b, ignore) {
                return operator("!=", a, b, ignore);
            },
            gt: function(a, b, ignore) {
                return operator(">", a, b, ignore);
            },
            gte: function(a, b, ignore) {
                return operator(">=", a, b, ignore);
            },
            lt: function(a, b, ignore) {
                return operator("<", a, b, ignore);
            },
            lte: function(a, b, ignore) {
                return operator("<=", a, b, ignore);
            },
            startswith: function(a, b, ignore) {
                if (ignore) {
                    a = "(" + a + " || '').toLowerCase()";
                    if (b) {
                        b = b.toLowerCase();
                    }
                }

                if (b) {
                    b = quote(b);
                }

                return a + ".lastIndexOf('" + b + "', 0) == 0";
            },
            endswith: function(a, b, ignore) {
                if (ignore) {
                    a = "(" + a + " || '').toLowerCase()";
                    if (b) {
                        b = b.toLowerCase();
                    }
                }

                if (b) {
                    b = quote(b);
                }

                return a + ".indexOf('" + b + "', " + a + ".length - " + (b || "").length + ") >= 0";
            },
            contains: function(a, b, ignore) {
                if (ignore) {
                    a = "(" + a + " || '').toLowerCase()";
                    if (b) {
                        b = b.toLowerCase();
                    }
                }

                if (b) {
                    b = quote(b);
                }

                return a + ".indexOf('" + b + "') >= 0";
            },
            doesnotcontain: function(a, b, ignore) {
                if (ignore) {
                    a = "(" + a + " || '').toLowerCase()";
                    if (b) {
                        b = b.toLowerCase();
                    }
                }

                if (b) {
                    b = quote(b);
                }

                return a + ".indexOf('" + b + "') == -1";
            }
        };
    })();

    function Query(data) {
        this.data = data || [];
    }

    Query.filterExpr = function(expression) {
        var expressions = [],
            logic = { and: " && ", or: " || " },
            idx,
            length,
            filter,
            expr,
            fieldFunctions = [],
            operatorFunctions = [],
            field,
            operator,
            filters = expression.filters;

        for (idx = 0, length = filters.length; idx < length; idx++) {
            filter = filters[idx];
            field = filter.field;
            operator = filter.operator;

            if (filter.filters) {
                expr = Query.filterExpr(filter);
                //Nested function fields or operators - update their index e.g. __o[0] -> __o[1]
                filter = expr.expression
                .replace(/__o\[(\d+)\]/g, function(match, index) {
                    index = +index;
                    return "__o[" + (operatorFunctions.length + index) + "]";
                })
                .replace(/__f\[(\d+)\]/g, function(match, index) {
                    index = +index;
                    return "__f[" + (fieldFunctions.length + index) + "]";
                });

                operatorFunctions.push.apply(operatorFunctions, expr.operators);
                fieldFunctions.push.apply(fieldFunctions, expr.fields);
            } else {
                if (typeof field === FUNCTION) {
                    expr = "__f[" + fieldFunctions.length +"](d)";
                    fieldFunctions.push(field);
                } else {
                    expr = kendo.expr(field);
                }

                if (typeof operator === FUNCTION) {
                    filter = "__o[" + operatorFunctions.length + "](" + expr + ", " + filter.value + ")";
                    operatorFunctions.push(operator);
                } else {
                    filter = operators[(operator || "eq").toLowerCase()](expr, filter.value, filter.ignoreCase !== undefined? filter.ignoreCase : true);
                }
            }

            expressions.push(filter);
        }

        return  { expression: "(" + expressions.join(logic[expression.logic]) + ")", fields: fieldFunctions, operators: operatorFunctions };
    };

    function normalizeSort(field, dir) {
        if (field) {
            var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,
            descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);

            return grep(descriptors, function(d) { return !!d.dir; });
        }
    }

    var operatorMap = {
        "==": "eq",
        equals: "eq",
        isequalto: "eq",
        equalto: "eq",
        equal: "eq",
        "!=": "neq",
        ne: "neq",
        notequals: "neq",
        isnotequalto: "neq",
        notequalto: "neq",
        notequal: "neq",
        "<": "lt",
        islessthan: "lt",
        lessthan: "lt",
        less: "lt",
        "<=": "lte",
        le: "lte",
        islessthanorequalto: "lte",
        lessthanequal: "lte",
        ">": "gt",
        isgreaterthan: "gt",
        greaterthan: "gt",
        greater: "gt",
        ">=": "gte",
        isgreaterthanorequalto: "gte",
        greaterthanequal: "gte",
        ge: "gte",
        notsubstringof: "doesnotcontain"
    };

    function normalizeOperator(expression) {
        var idx,
        length,
        filter,
        operator,
        filters = expression.filters;

        if (filters) {
            for (idx = 0, length = filters.length; idx < length; idx++) {
                filter = filters[idx];
                operator = filter.operator;

                if (operator && typeof operator === STRING) {
                    filter.operator = operatorMap[operator.toLowerCase()] || operator;
                }

                normalizeOperator(filter);
            }
        }
    }

    function normalizeFilter(expression) {
        if (expression && !isEmptyObject(expression)) {
            if (isArray(expression) || !expression.filters) {
                expression = {
                    logic: "and",
                    filters: isArray(expression) ? expression : [expression]
                };
            }

            normalizeOperator(expression);

            return expression;
        }
    }

    Query.normalizeFilter = normalizeFilter;

    function normalizeAggregate(expressions) {
        return isArray(expressions) ? expressions : [expressions];
    }

    function normalizeGroup(field, dir) {
        var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,
        descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);

        return map(descriptors, function(d) { return { field: d.field, dir: d.dir || "asc", aggregates: d.aggregates }; });
    }

    Query.prototype = {
        toArray: function () {
            return this.data;
        },
        range: function(index, count) {
            return new Query(this.data.slice(index, index + count));
        },
        skip: function (count) {
            return new Query(this.data.slice(count));
        },
        take: function (count) {
            return new Query(this.data.slice(0, count));
        },
        select: function (selector) {
            return new Query(map(this.data, selector));
        },
        order: function(selector, dir) {
            var sort = { dir: dir };

            if (selector) {
                if (selector.compare) {
                    sort.compare = selector.compare;
                } else {
                    sort.field = selector;
                }
            }

            return new Query(this.data.slice(0).sort(Comparer.create(sort)));
        },
        orderBy: function(selector) {
            return this.order(selector, "asc");
        },
        orderByDescending: function(selector) {
            return this.order(selector, "desc");
        },
        sort: function(field, dir, comparer) {
            var idx,
            length,
            descriptors = normalizeSort(field, dir),
            comparers = [];

            comparer = comparer || Comparer;

            if (descriptors.length) {
                for (idx = 0, length = descriptors.length; idx < length; idx++) {
                    comparers.push(comparer.create(descriptors[idx]));
                }

                return this.orderBy({ compare: comparer.combine(comparers) });
            }

            return this;
        },

        filter: function(expressions) {
            var idx,
            current,
            length,
            compiled,
            predicate,
            data = this.data,
            fields,
            operators,
            result = [],
            filter;

            expressions = normalizeFilter(expressions);

            if (!expressions || expressions.filters.length === 0) {
                return this;
            }

            compiled = Query.filterExpr(expressions);
            fields = compiled.fields;
            operators = compiled.operators;

            predicate = filter = new Function("d, __f, __o", "return " + compiled.expression);

            if (fields.length || operators.length) {
                filter = function(d) {
                    return predicate(d, fields, operators);
                };
            }

            for (idx = 0, length = data.length; idx < length; idx++) {
                current = data[idx];

                if (filter(current)) {
                    result.push(current);
                }
            }
            return new Query(result);
        },

        group: function(descriptors, allData) {
            descriptors =  normalizeGroup(descriptors || []);
            allData = allData || this.data;

            var that = this,
            result = new Query(that.data),
            descriptor;

            if (descriptors.length > 0) {
                descriptor = descriptors[0];
                result = result.groupBy(descriptor).select(function(group) {
                    var data = new Query(allData).filter([ { field: group.field, operator: "eq", value: group.value, ignoreCase: false } ]);
                    return {
                        field: group.field,
                        value: group.value,
                        items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,
                        hasSubgroups: descriptors.length > 1,
                        aggregates: data.aggregate(descriptor.aggregates)
                    };
                });
            }
            return result;
        },

        groupBy: function(descriptor) {
            if (isEmptyObject(descriptor) || !this.data.length) {
                return new Query([]);
            }

            var field = descriptor.field,
                sorted = this._sortForGrouping(field, descriptor.dir || "asc"),
                accessor = kendo.accessor(field),
                item,
                groupValue = accessor.get(sorted[0], field),
                group = {
                    field: field,
                    value: groupValue,
                    items: []
                },
                currentValue,
                idx,
                len,
                result = [group];

            for(idx = 0, len = sorted.length; idx < len; idx++) {
                item = sorted[idx];
                currentValue = accessor.get(item, field);
                if(!groupValueComparer(groupValue, currentValue)) {
                    groupValue = currentValue;
                    group = {
                        field: field,
                        value: groupValue,
                        items: []
                    };
                    result.push(group);
                }
                group.items.push(item);
            }
            return new Query(result);
        },

        _sortForGrouping: function(field, dir) {
            var idx, length,
                data = this.data;

            if (!stableSort) {
                for (idx = 0, length = data.length; idx < length; idx++) {
                    data[idx].__position = idx;
                }

                data = new Query(data).sort(field, dir, StableComparer).toArray();

                for (idx = 0, length = data.length; idx < length; idx++) {
                    delete data[idx].__position;
                }
                return data;
            }
            return this.sort(field, dir).toArray();
        },

        aggregate: function (aggregates) {
            var idx,
                len,
                result = {},
                state = {};

            if (aggregates && aggregates.length) {
                for(idx = 0, len = this.data.length; idx < len; idx++) {
                    calculateAggregate(result, aggregates, this.data[idx], idx, len, state);
                }
            }
            return result;
        }
    };

    function groupValueComparer(a, b) {
        if (a && a.getTime && b && b.getTime) {
            return a.getTime() === b.getTime();
        }
        return a === b;
    }

    function calculateAggregate(accumulator, aggregates, item, index, length, state) {
        aggregates = aggregates || [];
        var idx,
            aggr,
            functionName,
            len = aggregates.length;

        for (idx = 0; idx < len; idx++) {
            aggr = aggregates[idx];
            functionName = aggr.aggregate;
            var field = aggr.field;
            accumulator[field] = accumulator[field] || {};
            state[field] = state[field] || {};
            state[field][functionName] = state[field][functionName] || {};
            accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, kendo.accessor(field), index, length, state[field][functionName]);
        }
    }

    var functions = {
        sum: function(accumulator, item, accessor) {
            var value = accessor.get(item);

            if (!isNumber(accumulator)) {
                accumulator = value;
            } else if (isNumber(value)) {
                accumulator += value;
            }

            return accumulator;
        },
        count: function(accumulator) {
            return (accumulator || 0) + 1;
        },
        average: function(accumulator, item, accessor, index, length, state) {
            var value = accessor.get(item);

            if (state.count === undefined) {
                state.count = 0;
            }

            if (!isNumber(accumulator)) {
                accumulator = value;
            } else if (isNumber(value)) {
                accumulator += value;
            }

            if (isNumber(value)) {
                state.count++;
            }

            if(index == length - 1 && isNumber(accumulator)) {
                accumulator = accumulator / state.count;
            }
            return accumulator;
        },
        max: function(accumulator, item, accessor) {
            var value = accessor.get(item);

            if (!isNumber(accumulator)) {
                accumulator = value;
            }

            if(accumulator < value && isNumber(value)) {
                accumulator = value;
            }
            return accumulator;
        },
        min: function(accumulator, item, accessor) {
            var value = accessor.get(item);

            if (!isNumber(accumulator)) {
                accumulator = value;
            }

            if(accumulator > value && isNumber(value)) {
                accumulator = value;
            }
            return accumulator;
        }
    };

    function isNumber(val) {
        return typeof val === "number" && !isNaN(val);
    }

    function toJSON(array) {
        var idx, length = array.length, result = new Array(length);

        for (idx = 0; idx < length; idx++) {
            result[idx] = array[idx].toJSON();
        }

        return result;
    }

    Query.process = function(data, options) {
        options = options || {};

        var query = new Query(data),
            group = options.group,
            sort = normalizeGroup(group || []).concat(normalizeSort(options.sort || [])),
            total,
            filter = options.filter,
            skip = options.skip,
            take = options.take;

        if (filter) {
            query = query.filter(filter);
            total = query.toArray().length;
        }

        if (sort) {
            query = query.sort(sort);

            if (group) {
                data = query.toArray();
            }
        }

        if (skip !== undefined && take !== undefined) {
            query = query.range(skip, take);
        }

        if (group) {
            query = query.group(group, data);
        }

        return {
            total: total,
            data: query.toArray()
        };
    };

    function calculateAggregates(data, options) {
        options = options || {};

        var query = new Query(data),
            aggregates = options.aggregate,
            filter = options.filter;

        if(filter) {
            query = query.filter(filter);
        }

        return query.aggregate(aggregates);
    }

    var LocalTransport = Class.extend({
        init: function(options) {
            this.data = options.data;
        },

        read: function(options) {
            options.success(this.data);
        },
        update: function(options) {
            options.success(options.data);
        },
        create: function(options) {
            options.success(options.data);
        },
        destroy: function(options) {
            options.success(options.data);
        }
    });

    // var RemoteTrnsport = Class.extend( {
    //     init: function(options) {
    //         var that = this, parameterMap;

    //         options = that.options = extend({}, that.options, options);

    //         each(crud, function(index, type) {
    //             if (typeof options[type] === STRING) {
    //                 options[type] = {
    //                     url: options[type]
    //                 };
    //             }
    //         });

    //         that.cache = options.cache? Cache.create(options.cache) : {
    //             find: noop,
    //             add: noop
    //         };

    //         parameterMap = options.parameterMap;

    //         if (isFunction(options.push)) {
    //             that.push = options.push;
    //         }

    //         if (!that.push) {
    //             that.push = identity;
    //         }

    //         that.parameterMap = isFunction(parameterMap) ? parameterMap : function(options) {
    //             var result = {};

    //             each(options, function(option, value) {
    //                 if (option in parameterMap) {
    //                     option = parameterMap[option];
    //                     if (isPlainObject(option)) {
    //                         value = option.value(value);
    //                         option = option.key;
    //                     }
    //                 }

    //                 result[option] = value;
    //             });

    //             return result;
    //         };
    //     },

    //     options: {
    //         parameterMap: identity
    //     },

    //     create: function(options) {
    //         return ajax(this.setup(options, CREATE));
    //     },

    //     read: function(options) {
    //         var that = this,
    //             success,
    //             error,
    //             result,
    //             cache = that.cache;

    //         options = that.setup(options, READ);

    //         success = options.success || noop;
    //         error = options.error || noop;

    //         result = cache.find(options.data);

    //         if(result !== undefined) {
    //             success(result);
    //         } else {
    //             options.success = function(result) {
    //                 cache.add(options.data, result);

    //                 success(result);
    //             };

    //             $.ajax(options);
    //         }
    //     },

    //     update: function(options) {
    //         return ajax(this.setup(options, UPDATE));
    //     },

    //     destroy: function(options) {
    //         return ajax(this.setup(options, DESTROY));
    //     },

    //     setup: function(options, type) {
    //         options = options || {};

    //         var that = this,
    //             parameters,
    //             operation = that.options[type],
    //             data = isFunction(operation.data) ? operation.data(options.data) : operation.data;

    //         options = extend(true, {}, operation, options);
    //         parameters = extend(true, {}, data, options.data);

    //         options.data = that.parameterMap(parameters, type);

    //         if (isFunction(options.url)) {
    //             options.url = options.url(parameters);
    //         }

    //         return options;
    //     }
    // });

    // var Cache = Class.extend({
    //     init: function() {
    //         this._store = {};
    //     },
    //     add: function(key, data) {
    //         if(key !== undefined) {
    //             this._store[stringify(key)] = data;
    //         }
    //     },
    //     find: function(key) {
    //         return this._store[stringify(key)];
    //     },
    //     clear: function() {
    //         this._store = {};
    //     },
    //     remove: function(key) {
    //         delete this._store[stringify(key)];
    //     }
    // });

    // Cache.create = function(options) {
    //     var store = {
    //         "inmemory": function() { return new Cache(); }
    //     };

    //     if (isPlainObject(options) && isFunction(options.find)) {
    //         return options;
    //     }

    //     if (options === true) {
    //         return new Cache();
    //     }

    //     return store[options]();
    // };

    // function serializeRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {
    //     var record,
    //         getter,
    //         originalName,
    //         idx,
    //         length;

    //     for (idx = 0, length = data.length; idx < length; idx++) {
    //         record = data[idx];
    //         for (getter in getters) {
    //             originalName = fieldNames[getter];

    //             if (originalName && originalName !== getter) {
    //                 record[originalName] = getters[getter](record);
    //                 delete record[getter];
    //             }
    //         }
    //     }
    // }

    // function convertRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {
    //     var record,
    //         getter,
    //         originalName,
    //         idx,
    //         length;

    //     for (idx = 0, length = data.length; idx < length; idx++) {
    //         record = data[idx];
    //         for (getter in getters) {
    //             record[getter] = modelInstance._parse(getter, getters[getter](record));

    //             originalName = fieldNames[getter];
    //             if (originalName && originalName !== getter) {
    //                 delete record[originalName];
    //             }
    //         }
    //     }
    // }

    // function convertGroup(data, getters, modelInstance, originalFieldNames, fieldNames) {
    //     var record,
    //         idx,
    //         fieldName,
    //         length;

    //     for (idx = 0, length = data.length; idx < length; idx++) {
    //         record = data[idx];

    //         fieldName = originalFieldNames[record.field];
    //         if (fieldName && fieldName != record.field) {
    //             record.field = fieldName;
    //         }

    //         record.value = modelInstance._parse(record.field, record.value);

    //         if (record.hasSubgroups) {
    //             convertGroup(record.items, getters, modelInstance, originalFieldNames, fieldNames);
    //         } else {
    //             convertRecords(record.items, getters, modelInstance, originalFieldNames, fieldNames);
    //         }
    //     }
    // }

    // function wrapDataAccess(originalFunction, model, converter, getters, originalFieldNames, fieldNames) {
    //     return function(data) {
    //         data = originalFunction(data);

    //         if (data && !isEmptyObject(getters)) {
    //             if (toString.call(data) !== "[object Array]" && !(data instanceof ObservableArray)) {
    //                 data = [data];
    //             }

    //             converter(data, getters, new model(), originalFieldNames, fieldNames);
    //         }

    //         return data || [];
    //     };
    // }

    var DataReader = Class.extend({
        init: function(schema) {
            var that = this, member, get, model, base;

            schema = schema || {};

            for (member in schema) {
                get = schema[member];

                that[member] = typeof get === STRING ? getter(get) : get;
            }

            base = schema.modelBase || Model;

            if (isPlainObject(that.model)) {
                that.model = model = base.define(that.model);
            }

            if (that.model) {
                var dataFunction = proxy(that.data, that),
                    groupsFunction = proxy(that.groups, that),
                    serializeFunction = proxy(that.serialize, that),
                    originalFieldNames = {},
                    getters = {},
                    serializeGetters = {},
                    fieldNames = {},
                    shouldSerialize = false,
                    fieldName;

                model = that.model;

                if (model.fields) {
                    each(model.fields, function(field, value) {
                        var fromName;

                        fieldName = field;

                        if (isPlainObject(value) && value.field) {
                            fieldName = value.field;
                        } else if (typeof value === STRING) {
                            fieldName = value;
                        }

                        if (isPlainObject(value) && value.from) {
                            fromName = value.from;
                        }

                        shouldSerialize = shouldSerialize || (fromName && fromName !== field) || fieldName !== field;

                        getters[field] = getter(fromName || fieldName);
                        serializeGetters[field] = getter(field);
                        originalFieldNames[fromName || fieldName] = field;
                        fieldNames[field] = fromName || fieldName;
                    });

                    if (!schema.serialize && shouldSerialize) {
                        that.serialize = wrapDataAccess(serializeFunction, model, serializeRecords, serializeGetters, originalFieldNames, fieldNames);
                    }
                }

                that._dataAccessFunction = dataFunction;
                that.data = wrapDataAccess(dataFunction, model, convertRecords, getters, originalFieldNames, fieldNames);
                that.groups = wrapDataAccess(groupsFunction, model, convertGroup, getters, originalFieldNames, fieldNames);
            }
        },
        errors: function(data) {
            return data ? data.errors : null;
        },
        parse: identity,
        data: identity,
        total: function(data) {
            return data.length;
        },
        groups: identity,
        aggregates: function() {
            return {};
        },
        serialize: function(data) {
            return data;
        }
    });

    // function mergeGroups(target, dest, skip, take) {
    //     var group,
    //         idx = 0,
    //         items;

    //     while (dest.length && take) {
    //         group = dest[idx];
    //         items = group.items;

    //         var length = items.length;

    //         if (target && target.field === group.field && target.value === group.value) {
    //             if (target.hasSubgroups && target.items.length) {
    //                 mergeGroups(target.items[target.items.length - 1], group.items, skip, take);
    //             } else {
    //                 items = items.slice(skip, skip + take);
    //                 target.items = target.items.concat(items);
    //             }
    //             dest.splice(idx--, 1);
    //         } else if (group.hasSubgroups && items.length) {
    //             mergeGroups(group, items, skip, take);
    //         } else {
    //             items = items.slice(skip, skip + take);
    //             group.items = items;

    //             if (!group.items.length) {
    //                 dest.splice(idx--, 1);
    //             }
    //         }

    //         if (items.length === 0) {
    //             skip -= length;
    //         } else {
    //             skip = 0;
    //             take -= items.length;
    //         }

    //         if (++idx >= dest.length) {
    //             break;
    //         }
    //     }

    //     if (idx < dest.length) {
    //         dest.splice(idx, dest.length - idx);
    //     }
    // }

    // function flattenGroups(data) {
    //     var idx, length, result = [];

    //     for (idx = 0, length = data.length; idx < length; idx++) {
    //         if (data[idx].hasSubgroups) {
    //             result = result.concat(flattenGroups(data[idx].items));
    //         } else {
    //             result = result.concat(data[idx].items.slice());
    //         }
    //     }
    //     return result;
    // }

    // function wrapGroupItems(data, model) {
    //     var idx, length, group, items;
    //     if (model) {
    //         for (idx = 0, length = data.length; idx < length; idx++) {
    //             group = data[idx];
    //             items = group.items;

    //             if (group.hasSubgroups) {
    //                 wrapGroupItems(items, model);
    //             } else if (items.length && !(items[0] instanceof model)) {
    //                 items.type = model;
    //                 items.wrapAll(items, items);
    //             }
    //         }
    //     }
    // }

    function eachGroupItems(data, func) {
        var idx, length;

        for (idx = 0, length = data.length; idx < length; idx++) {
            if (data[idx].hasSubgroups) {
                if (eachGroupItems(data[idx].items, func)) {
                    return true;
                }
            } else if (func(data[idx].items, data[idx])) {
                return true;
            }
        }
    }

    function removeModel(data, model) {
        var idx, length;

        for (idx = 0, length = data.length; idx < length; idx++) {
            if (data[idx].uid == model.uid) {
                model = data[idx];
                data.splice(idx, 1);
                return model;
            }
        }
    }

    function wrapInEmptyGroup(groups, model) {
        var parent,
            group,
            idx,
            length;

        for (idx = groups.length-1, length = 0; idx >= length; idx--) {
            group = groups[idx];
            parent = {
                value: model.get(group.field),
                field: group.field,
                items: parent ? [parent] : [model],
                hasSubgroups: !!parent,
                aggregates: {}
            };
        }

        return parent;
    }

    function indexOfPristineModel(data, model) {
        if (model) {
            return indexOf(data, function(item) {
                return item[model.idField] === model.id;
            });
        }
        return -1;
    }

    function indexOfModel(data, model) {
        if (model) {
            return indexOf(data, function(item) {
                return item.uid == model.uid;
            });
        }
        return -1;
    }

    function indexOf(data, comparer) {
        var idx, length;

        for (idx = 0, length = data.length; idx < length; idx++) {
            if (comparer(data[idx])) {
                return idx;
            }
        }

        return -1;
    }

    function fieldNameFromModel(fields, name) {
        if (fields && !isEmptyObject(fields)) {
            var descriptor = fields[name];
            var fieldName;
            if (isPlainObject(descriptor)) {
                fieldName = descriptor.from || descriptor.field || name;
            } else {
                fieldName = fields[name] || name;
            }

            if (isFunction(fieldName)) {
                return name;
            }

            return fieldName;
        }
        return name;
    }

    function convertFilterDescriptorsField(descriptor, model) {
        var idx,
            length,
            target = {};

        for (var field in descriptor) {
            if (field !== "filters") {
                target[field] = descriptor[field];
            }
        }

        if (descriptor.filters) {
            target.filters = [];
            for (idx = 0, length = descriptor.filters.length; idx < length; idx++) {
                target.filters[idx] = convertFilterDescriptorsField(descriptor.filters[idx], model);
            }
        } else {
            target.field = fieldNameFromModel(model.fields, target.field);
        }
        return target;
    }

    function convertDescriptorsField(descriptors, model) {
        var idx,
            length,
            result = [],
            target,
            descriptor;

        for (idx = 0, length = descriptors.length; idx < length; idx ++) {
            target = {};

            descriptor = descriptors[idx];

            for (var field in descriptor) {
                target[field] = descriptor[field];
            }

            target.field = fieldNameFromModel(model.fields, target.field);

            if (target.aggregates && isArray(target.aggregates)) {
                target.aggregates = convertDescriptorsField(target.aggregates, model);
            }
            result.push(target);
        }
        return result;
    }

    var DataSource = Observable.extend({
        init: function(options) {
            var that = this, model, data;

            if (options) {
                data = options.data;
            }

            options = that.options = extend({}, that.options, options);

            that._map = {};
            that._prefetch = {};
            that._data = [];
            that._pristineData = [];
            that._ranges = [];
            that._view = [];
            that._pristineTotal = 0;
            that._destroyed = [];
            that._pageSize = options.pageSize;
            that._page = options.page  || (options.pageSize ? 1 : undefined);
            that._sort = normalizeSort(options.sort);
            that._filter = normalizeFilter(options.filter);
            that._group = normalizeGroup(options.group);
            that._aggregate = options.aggregate;
            that._total = options.total;

            Observable.fn.init.call(that);

            that.transport = Transport.create(options, data);

            if (isFunction(that.transport.push)) {
                that.transport.push({
                    pushCreate: proxy(that._pushCreate, that),
                    pushUpdate: proxy(that._pushUpdate, that),
                    pushDestroy: proxy(that._pushDestroy, that)
                });
            }

            that.reader = new kendo.data.readers[options.schema.type || "json" ](options.schema);

            model = that.reader.model || {};

            that._data = that._observe(that._data);

            that.bind(["push", ERROR, CHANGE, REQUESTSTART, SYNC, REQUESTEND, PROGRESS], options);
        },

        options: {
            data: [],
            schema: {
               modelBase: Model
            },
            serverSorting: false,
            serverPaging: false,
            serverFiltering: false,
            serverGrouping: false,
            serverAggregates: false,
            batch: false
        },

        _isServerGrouped: function() {
            var group = this.group() || [];

            return this.options.serverGrouping && group.length;
        },

        _pushCreate: function(result) {
            this._push(result, "pushCreate");
        },

        _pushUpdate: function(result) {
            this._push(result, "pushUpdate");
        },

        _pushDestroy: function(result) {
            this._push(result, "pushDestroy");
        },

        _push: function(result, operation) {
            var data = this._readData(result);

            if (!data) {
                data = result;
            }

            this[operation](data);
        },

        _flatData: function(data) {
            if (this._isServerGrouped()) {
                return flattenGroups(data);
            }
            return data;
        },

        parent: noop,

        get: function(id) {
            var idx, length, data = this._flatData(this._data);

            for (idx = 0, length = data.length; idx < length; idx++) {
                if (data[idx].id == id) {
                    return data[idx];
                }
            }
        },

        getByUid: function(id) {
            var idx, length, data = this._flatData(this._data);

            if (!data) {
                return;
            }

            for (idx = 0, length = data.length; idx < length; idx++) {
                if (data[idx].uid == id) {
                    return data[idx];
                }
            }
        },

        indexOf: function(model) {
            return indexOfModel(this._data, model);
        },

        at: function(index) {
            return this._data[index];
        },

        data: function(value) {
            var that = this;
            if (value !== undefined) {
                that._data = this._observe(value);

                that._pristineData = value.slice(0);

                that._ranges = [];
                that._addRange(that._data);

                that._total = that._data.length;
                that._pristineTotal = that._total;

                that._process(that._data);
            } else {
                return that._data;
            }
        },

        view: function() {
            return this._view;
        },

        add: function(model) {
            return this.insert(this._data.length, model);
        },

        _createNewModel: function(model) {
            if (this.reader.model) {
                return  new this.reader.model(model);
            }

            return new ObservableObject(model);
        },

        insert: function(index, model) {
            if (!model) {
                model = index;
                index = 0;
            }

            if (!(model instanceof Model)) {
                model = this._createNewModel(model);
            }

            if (this._isServerGrouped()) {
                this._data.splice(index, 0, wrapInEmptyGroup(this.group(), model));
            } else {
                this._data.splice(index, 0, model);
            }

            return model;
        },

        // pushCreate: function(items) {
        //     if (!isArray(items)) {
        //         items = [items];
        //     }

        //     var pushed = [];

        //     for (var idx = 0; idx < items.length; idx ++) {
        //         var item = items[idx];

        //         var result = this.add(item);

        //         pushed.push(result);

        //         var pristine = result.toJSON();

        //         if (this._isServerGrouped()) {
        //             pristine = wrapInEmptyGroup(this.group(), pristine);
        //         }

        //         this._pristineData.push(pristine);
        //     }

        //     if (pushed.length) {
        //         this.trigger("push", {
        //             type: "create",
        //             items: pushed
        //         });
        //     }
        // },

        // pushUpdate: function(items) {
        //     if (!isArray(items)) {
        //         items = [items];
        //     }

        //     var pushed = [];

        //     for (var idx = 0; idx < items.length; idx ++) {
        //         var item = items[idx];
        //         var model = this._createNewModel(item);

        //         var target = this.get(model.id);

        //         if (target) {
        //             pushed.push(target);

        //             target.accept(item);

        //             target.trigger("change");

        //             this._updatePristineForModel(target, item);
        //         } else {
        //             this.pushCreate(item);
        //         }
        //     }

        //     if (pushed.length) {
        //         this.trigger("push", {
        //             type: "update",
        //             items: pushed
        //         });
        //     }
        // },

        // pushDestroy: function(items) {
        //     if (!isArray(items)) {
        //         items = [items];
        //     }

        //     var pushed = [];
        //     var autoSync = this.options.autoSync;
        //     this.options.autoSync = false;
        //     try {
        //         for (var idx = 0; idx < items.length; idx ++) {
        //             var item = items[idx];
        //             var model = this._createNewModel(item);
        //             var found = false;

        //             this._eachItem(this._data, function(items){
        //                 for (var idx = 0; idx < items.length; idx++) {
        //                     if (items[idx].id === model.id) {
        //                         pushed.push(items[idx]);
        //                         items.splice(idx, 1);
        //                         found = true;
        //                         break;
        //                     }
        //                 }
        //             });

        //             if (found) {
        //                 this._removePristineForModel(model);
        //                 this._destroyed.pop();
        //             }
        //         }
        //     } finally {
        //         this.options.autoSync = autoSync;
        //     }

        //     if (pushed.length) {
        //         this.trigger("push", {
        //             type: "destroy",
        //             items: pushed
        //         });
        //     }
        // },

        // remove: function(model) {
        //     var result,
        //         that = this,
        //         hasGroups = that._isServerGrouped();

        //     this._eachItem(that._data, function(items) {
        //         result = removeModel(items, model);
        //         if (result && hasGroups) {
        //             if (!result.isNew || !result.isNew()) {
        //                 that._destroyed.push(result);
        //             }
        //             return true;
        //         }
        //     });

        //     this._removeModelFromRanges(model);

        //     this._updateRangesLength();

        //     return model;
        // },

        // sync: function() {
        //     var that = this,
        //         idx,
        //         length,
        //         created = [],
        //         updated = [],
        //         destroyed = that._destroyed,
        //         data = that._flatData(that._data);

        //     if (!that.reader.model) {
        //         return;
        //     }

        //     for (idx = 0, length = data.length; idx < length; idx++) {
        //         if (data[idx].isNew()) {
        //             created.push(data[idx]);
        //         } else if (data[idx].dirty) {
        //             updated.push(data[idx]);
        //         }
        //     }

        //     var promises = that._send("create", created);

        //     promises.push.apply(promises ,that._send("update", updated));
        //     promises.push.apply(promises ,that._send("destroy", destroyed));

        //     $.when.apply(null, promises)
        //         .then(function() {
        //             var idx, length;

        //             for (idx = 0, length = arguments.length; idx < length; idx++){
        //                 that._accept(arguments[idx]);
        //             }

        //             that._change({ action: "sync" });

        //             that.trigger(SYNC);
        //         });
        // },

        // cancelChanges: function(model) {
        //     var that = this;

        //     if (model instanceof kendo.data.Model) {
        //         that._cancelModel(model);
        //     } else {
        //         that._destroyed = [];
        //         that._data = that._observe(that._pristineData);
        //         if (that.options.serverPaging) {
        //             that._total = that._pristineTotal;
        //         }
        //         that._change();
        //     }
        // },

        // hasChanges: function() {
        //     var idx,
        //         length,
        //         data = this._data;

        //     if (this._destroyed.length) {
        //         return true;
        //     }

        //     for (idx = 0, length = data.length; idx < length; idx++) {
        //         if (data[idx].isNew() || data[idx].dirty) {
        //             return true;
        //         }
        //     }

        //     return false;
        // },

        // _accept: function(result) {
        //     var that = this,
        //         models = result.models,
        //         response = result.response,
        //         idx = 0,
        //         serverGroup = that._isServerGrouped(),
        //         pristine = that._pristineData,
        //         type = result.type,
        //         length;

        //     that.trigger(REQUESTEND, { response: response, type: type });

        //     if (response && !isEmptyObject(response)) {
        //         response = that.reader.parse(response);

        //         if (that._handleCustomErrors(response)) {
        //             return;
        //         }

        //         response = that.reader.data(response);

        //         if (!isArray(response)) {
        //             response = [response];
        //         }
        //     } else {
        //         response = $.map(models, function(model) { return model.toJSON(); } );
        //     }

        //     if (type === "destroy") {
        //         that._destroyed = [];
        //     }

        //     for (idx = 0, length = models.length; idx < length; idx++) {
        //         if (type !== "destroy") {
        //             models[idx].accept(response[idx]);

        //             if (type === "create") {
        //                 pristine.push(serverGroup ? wrapInEmptyGroup(that.group(), models[idx]) : response[idx]);
        //             } else if (type === "update") {
        //                 that._updatePristineForModel(models[idx], response[idx]);
        //             }
        //         } else {
        //             that._removePristineForModel(models[idx]);
        //         }
        //     }
        // },

        _updatePristineForModel: function(model, values) {
            this._executeOnPristineForModel(model, function(index, items) {
                kendo.deepExtend(items[index], values);
            });
        },

        _executeOnPristineForModel: function(model, callback) {
            this._eachPristineItem(
                function(items) {
                    var index = indexOfPristineModel(items, model);
                    if (index > -1) {
                        callback(index, items);
                        return true;
                    }
                });
        },

        _removePristineForModel: function(model) {
            this._executeOnPristineForModel(model, function(index, items) {
                items.splice(index, 1);
            });
        },

        _readData: function(data) {
            var read = !this._isServerGrouped() ? this.reader.data : this.reader.groups;
            return read(data);
        },

        _eachPristineItem: function(callback) {
            this._eachItem(this._pristineData, callback);
        },

       _eachItem: function(data, callback) {
            if (data && data.length) {
                if (this._isServerGrouped()) {
                    eachGroupItems(data, callback);
                } else {
                    callback(data);
                }
            }
        },

        _pristineForModel: function(model) {
            var pristine,
                idx,
                callback = function(items) {
                    idx = indexOfPristineModel(items, model);
                    if (idx > -1) {
                        pristine = items[idx];
                        return true;
                    }
                };

            this._eachPristineItem(callback);

            return pristine;
        },

        _cancelModel: function(model) {
            var pristine = this._pristineForModel(model),
                idx;

           this._eachItem(this._data, function(items) {
                idx = indexOfModel(items, model);
                if (idx != -1) {
                    if (!model.isNew() && pristine) {
                        items[idx].accept(pristine);
                    } else {
                        items.splice(idx, 1);
                    }
                }
            });
        },

        _promise: function(data, models, type) {
            var that = this,
            transport = that.transport;

            return $.Deferred(function(deferred) {

                that.trigger(REQUESTSTART, { type: type });

                transport[type].call(transport, extend({
                    success: function(response) {
                        deferred.resolve({
                            response: response,
                            models: models,
                            type: type
                        });
                    },
                    error: function(response, status, error) {
                        deferred.reject(response);
                        that.error(response, status, error);
                    }
                }, data)
                );
            }).promise();
        },

        _send: function(method, data) {
            var that = this,
                idx,
                length,
                promises = [],
                converted = that.reader.serialize(toJSON(data));

            if (that.options.batch) {
                if (data.length) {
                    promises.push(that._promise( { data: { models: converted } }, data , method));
                }
            } else {
                for (idx = 0, length = data.length; idx < length; idx++) {
                    promises.push(that._promise( { data: converted[idx] }, [ data[idx] ], method));
                }
            }

            return promises;
        },

        read: function(data) {
            var that = this, params = that._params(data);

            that._queueRequest(params, function() {
                if (!that.trigger(REQUESTSTART, { type: "read" })) {
                    that.trigger(PROGRESS);

                    that._ranges = [];
                    that.transport.read({
                        data: params,
                        success: proxy(that.success, that),
                        error: proxy(that.error, that)
                    });
                } else {
                    that._dequeueRequest();
                }
            });
        },

        success: function(data) {
            var that = this,
                options = that.options;

            that.trigger(REQUESTEND, { response: data, type: "read" });

            data = that.reader.parse(data);

            if (that._handleCustomErrors(data)) {
                that._dequeueRequest();
                return;
            }

            that._total = that.reader.total(data);
            that._pristineTotal = that._total;

            if (that._aggregate && options.serverAggregates) {
                that._aggregateResult = that.reader.aggregates(data);
            }

            data = that._readData(data);

            that._pristineData = data.slice(0);

            that._data = that._observe(data);

            that._addRange(that._data);

            that._process(that._data);
            that._dequeueRequest();
        },

        _addRange: function(data) {
            var that = this,
                start = that._skip || 0,
                end = start + that._flatData(data).length;

            that._ranges.push({ start: start, end: end, data: data });
            that._ranges.sort( function(x, y) { return x.start - y.start; } );
        },

        error: function(xhr, status, errorThrown) {
            this._dequeueRequest();
            this.trigger(REQUESTEND, { });
            this.trigger(ERROR, { xhr: xhr, status: status, errorThrown: errorThrown });
        },

        _params: function(data) {
            var that = this,
                options =  extend({
                    take: that.take(),
                    skip: that.skip(),
                    page: that.page(),
                    pageSize: that.pageSize(),
                    sort: that._sort,
                    filter: that._filter,
                    group: that._group,
                    aggregate: that._aggregate
                }, data);

            if (!that.options.serverPaging) {
                delete options.take;
                delete options.skip;
                delete options.page;
                delete options.pageSize;
            }

            if (!that.options.serverGrouping) {
                delete options.group;
            } else if (that.reader.model && options.group) {
                options.group = convertDescriptorsField(options.group, that.reader.model);
            }

            if (!that.options.serverFiltering) {
                delete options.filter;
            } else if (that.reader.model && options.filter) {
               options.filter = convertFilterDescriptorsField(options.filter, that.reader.model);
            }

            if (!that.options.serverSorting) {
                delete options.sort;
            } else if (that.reader.model && options.sort) {
                options.sort = convertDescriptorsField(options.sort, that.reader.model);
            }

            if (!that.options.serverAggregates) {
                delete options.aggregate;
            } else if (that.reader.model && options.aggregate) {
                options.aggregate = convertDescriptorsField(options.aggregate, that.reader.model);
            }

            return options;
        },

        _queueRequest: function(options, callback) {
            var that = this;
            if (!that._requestInProgress) {
                that._requestInProgress = true;
                that._pending = undefined;
                callback();
            } else {
                that._pending = { callback: proxy(callback, that), options: options };
            }
        },

        _dequeueRequest: function() {
            var that = this;
            that._requestInProgress = false;
            if (that._pending) {
                that._queueRequest(that._pending.options, that._pending.callback);
            }
        },

        _handleCustomErrors: function(response) {
            if (this.reader.errors) {
                var errors = this.reader.errors(response);
                if (errors) {
                    this.trigger(ERROR, { xhr: null, status: "customerror", errorThrown: "custom error", errors: errors });
                    return true;
                }
            }
            return false;
        },
        _observe: function(data) {
            var that = this,
                model = that.reader.model,
                wrap = false;

            if (model && data.length) {
                wrap = !(data[0] instanceof model);
            }

            if (data instanceof ObservableArray) {
                if (wrap) {
                    data.type = that.reader.model;
                    data.wrapAll(data, data);
                }
            } else {
                data = new ObservableArray(data, that.reader.model);
                data.parent = function() { return that.parent(); };
            }

            if (that._isServerGrouped()) {
                wrapGroupItems(data, model);
            }

            if (that._changeHandler && that._data && that._data instanceof ObservableArray) {
                that._data.unbind(CHANGE, that._changeHandler);
            } else {
                that._changeHandler = proxy(that._change, that);
            }

            return data.bind(CHANGE, that._changeHandler);
        },

        _change: function(e) {
            var that = this, idx, length, action = e ? e.action : "";

            if (action === "remove") {
                for (idx = 0, length = e.items.length; idx < length; idx++) {
                    if (!e.items[idx].isNew || !e.items[idx].isNew()) {
                        that._destroyed.push(e.items[idx]);
                    }
                }
            }

            if (that.options.autoSync && (action === "add" || action === "remove" || action === "itemchange")) {
                that.sync();
            } else {
                var total = parseInt(that._total || that._pristineTotal, 10);
                if (action === "add") {
                    total += e.items.length;
                } else if (action === "remove") {
                    total -= e.items.length;
                } else if (action !== "itemchange" && action !== "sync" && !that.options.serverPaging) {
                    total = that._pristineTotal;
                } else if (action === "sync") {
                    total = that._pristineTotal = parseInt(that._total, 10);
                }

                that._total = total;

                that._process(that._data, e);
            }
        },

        _process: function (data, e) {
            var that = this,
                options = {},
                result;

            if (that.options.serverPaging !== true) {
                options.skip = that._skip;
                options.take = that._take || that._pageSize;

                if(options.skip === undefined && that._page !== undefined && that._pageSize !== undefined) {
                    options.skip = (that._page - 1) * that._pageSize;
                }
            }

            if (that.options.serverSorting !== true) {
                options.sort = that._sort;
            }

            if (that.options.serverFiltering !== true) {
                options.filter = that._filter;
            }

            if (that.options.serverGrouping !== true) {
                options.group = that._group;
            }

            if (that.options.serverAggregates !== true) {
                options.aggregate = that._aggregate;
                that._aggregateResult = calculateAggregates(data, options);
            }

            result = Query.process(data, options);

            that._view = result.data;

            if (result.total !== undefined && !that.options.serverFiltering) {
                that._total = result.total;
            }

            e = e || {};

            e.items = e.items || that._view;

            that.trigger(CHANGE, e);
        },

        _mergeState: function(options) {
            var that = this;

            if (options !== undefined) {
                that._pageSize = options.pageSize;
                that._page = options.page;
                that._sort = options.sort;
                that._filter = options.filter;
                that._group = options.group;
                that._aggregate = options.aggregate;
                that._skip = options.skip;
                that._take = options.take;

                if(that._skip === undefined) {
                    that._skip = that.skip();
                    options.skip = that.skip();
                }

                if(that._take === undefined && that._pageSize !== undefined) {
                    that._take = that._pageSize;
                    options.take = that._take;
                }

                if (options.sort) {
                    that._sort = options.sort = normalizeSort(options.sort);
                }

                if (options.filter) {
                    that._filter = options.filter = normalizeFilter(options.filter);
                }

                if (options.group) {
                    that._group = options.group = normalizeGroup(options.group);
                }
                if (options.aggregate) {
                    that._aggregate = options.aggregate = normalizeAggregate(options.aggregate);
                }
            }
            return options;
        },

        query: function(options) {
            var that = this,
                result,
                remote = that.options.serverSorting || that.options.serverPaging || that.options.serverFiltering || that.options.serverGrouping || that.options.serverAggregates;

            if (remote || ((that._data === undefined || that._data.length === 0) && !that._destroyed.length)) {
                that.read(that._mergeState(options));
            } else {
                if (!that.trigger(REQUESTSTART, { type: "read" })) {
                    that.trigger(PROGRESS);

                    result = Query.process(that._data, that._mergeState(options));

                    if (!that.options.serverFiltering) {
                        if (result.total !== undefined) {
                            that._total = result.total;
                        } else {
                            that._total = that._data.length;
                        }
                    }

                    that._view = result.data;
                    that._aggregateResult = calculateAggregates(that._data, options);
                    that.trigger(REQUESTEND, { });
                    that.trigger(CHANGE, { items: result.data });
                }
            }
        },

        fetch: function(callback) {
            var that = this;

            return $.Deferred(function(deferred) {
                var success = function(e) {
                    that.unbind(ERROR, error);

                    deferred.resolve();

                    if (callback) {
                        callback.call(that, e);
                    }
                };

                var error = function(e) {
                    deferred.reject(e);
                };

                that.one(CHANGE, success);
                that.one(ERROR, error);
                that._query();
            }).promise();
        },

        _query: function(options) {
            var that = this;

            that.query(extend({}, {
                page: that.page(),
                pageSize: that.pageSize(),
                sort: that.sort(),
                filter: that.filter(),
                group: that.group(),
                aggregate: that.aggregate()
            }, options));
        },

        next: function(options) {
            var that = this,
                page = that.page(),
                total = that.total();

            options = options || {};

            if (!page || (total && page + 1 > that.totalPages())) {
                return;
            }

            that._skip = page * that.take();

            page += 1;
            options.page = page;

            that._query(options);

            return page;
        },

        prev: function(options) {
            var that = this,
                page = that.page();

            options = options || {};

            if (!page || page === 1) {
                return;
            }

            that._skip = that._skip - that.take();

            page -= 1;
            options.page = page;

            that._query(options);

            return page;
        },

        page: function(val) {
            var that = this,
            skip;

            if(val !== undefined) {
                val = math.max(math.min(math.max(val, 1), that.totalPages()), 1);
                that._query({ page: val });
                return;
            }
            skip = that.skip();

            return skip !== undefined ? math.round((skip || 0) / (that.take() || 1)) + 1 : undefined;
        },

        pageSize: function(val) {
            var that = this;

            if(val !== undefined) {
                that._query({ pageSize: val, page: 1 });
                return;
            }

            return that.take();
        },

        sort: function(val) {
            var that = this;

            if(val !== undefined) {
                that._query({ sort: val });
                return;
            }

            return that._sort;
        },

        filter: function(val) {
            var that = this;

            if (val === undefined) {
                return that._filter;
            }

            that._query({ filter: val, page: 1 });
        },

        group: function(val) {
            var that = this;

            if(val !== undefined) {
                that._query({ group: val });
                return;
            }

            return that._group;
        },

        total: function() {
            return parseInt(this._total || 0, 10);
        },

        aggregate: function(val) {
            var that = this;

            if(val !== undefined) {
                that._query({ aggregate: val });
                return;
            }

            return that._aggregate;
        },

        aggregates: function() {
            return this._aggregateResult;
        },

        totalPages: function() {
            var that = this,
            pageSize = that.pageSize() || that.total();

            return math.ceil((that.total() || 0) / pageSize);
        },

        inRange: function(skip, take) {
            var that = this,
                end = math.min(skip + take, that.total());

            if (!that.options.serverPaging && that._data.length > 0) {
                return true;
            }

            return that._findRange(skip, end).length > 0;
        },

        lastRange: function() {
            var ranges = this._ranges;
            return ranges[ranges.length - 1] || { start: 0, end: 0, data: [] };
        },

        firstItemUid: function() {
            var ranges = this._ranges;
            return ranges.length && ranges[0].data.length && ranges[0].data[0].uid;
        },

        range: function(skip, take) {
            skip = math.min(skip || 0, this.total());

            var that = this,
                pageSkip = math.max(math.floor(skip / take), 0) * take,
                size = math.min(pageSkip + take, that.total()),
                data;

            data = that._findRange(skip, math.min(skip + take, that.total()));

            if (data.length) {
                that._skip = skip > that.skip() ? math.min(size, (that.totalPages() - 1) * that.take()) : pageSkip;

                that._take = take;

                var paging = that.options.serverPaging;
                var sorting = that.options.serverSorting;
                var filtering = that.options.serverFiltering;
                var aggregates = that.options.serverAggregates;
                try {
                    that.options.serverPaging = true;
                    if (!that._isServerGrouped() && !(that.group() && that.group().length)) {
                        that.options.serverSorting = true;
                    }
                    that.options.serverFiltering = true;
                    that.options.serverPaging = true;
                    that.options.serverAggregates = true;

                    if (paging) {
                        that._data = data = that._observe(data);
                    }
                    that._process(data);
                } finally {
                    that.options.serverPaging = paging;
                    that.options.serverSorting = sorting;
                    that.options.serverFiltering = filtering;
                    that.options.serverAggregates = aggregates;
                }

                return;
            }

            if (take !== undefined) {
                if (!that._rangeExists(pageSkip, size)) {
                    that.prefetch(pageSkip, take, function() {
                        if (skip > pageSkip && size < that.total() && !that._rangeExists(size, math.min(size + take, that.total()))) {
                            that.prefetch(size, take, function() {
                                that.range(skip, take);
                            });
                        } else {
                            that.range(skip, take);
                        }
                    });
                } else if (pageSkip < skip) {
                    that.prefetch(size, take, function() {
                        that.range(skip, take);
                    });
                }
            }
        },

        _findRange: function(start, end) {
            var that = this,
                ranges = that._ranges,
                range,
                data = [],
                skipIdx,
                takeIdx,
                startIndex,
                endIndex,
                rangeData,
                rangeEnd,
                processed,
                options = that.options,
                remote = options.serverSorting || options.serverPaging || options.serverFiltering || options.serverGrouping || options.serverAggregates,
                flatData,
                count,
                length;

            for (skipIdx = 0, length = ranges.length; skipIdx < length; skipIdx++) {
                range = ranges[skipIdx];
                if (start >= range.start && start <= range.end) {
                    count = 0;

                    for (takeIdx = skipIdx; takeIdx < length; takeIdx++) {
                        range = ranges[takeIdx];
                        flatData = that._flatData(range.data);

                        if (flatData.length && start + count >= range.start) {
                            rangeData = range.data;
                            rangeEnd = range.end;

                            if (!remote) {
                                var sort = normalizeGroup(that.group() || []).concat(normalizeSort(that.sort() || []));
                                processed = Query.process(range.data, { sort: sort, filter: that.filter() });
                                flatData = rangeData = processed.data;

                                if (processed.total !== undefined) {
                                    rangeEnd = processed.total;
                                }
                            }

                            startIndex = 0;
                            if (start + count > range.start) {
                                startIndex = (start + count) - range.start;
                            }
                            endIndex = flatData.length;
                            if (rangeEnd > end) {
                                endIndex = endIndex - (rangeEnd - end);
                            }
                            count += endIndex - startIndex;
                            data = that._mergeGroups(data, rangeData, startIndex, endIndex);

                            if (end <= range.end && count == end - start) {
                                return data;
                            }
                        }
                    }
                    break;
                }
            }
            return [];
        },

        _mergeGroups: function(data, range, skip, take) {
            if (this._isServerGrouped()) {
                var temp = range.toJSON(),
                    prevGroup;

                if (data.length) {
                    prevGroup = data[data.length - 1];
                }

                mergeGroups(prevGroup, temp, skip, take);

                return data.concat(temp);
            }
            return data.concat(range.slice(skip, take));
        },

        skip: function() {
            var that = this;

            if (that._skip === undefined) {
                return (that._page !== undefined ? (that._page  - 1) * (that.take() || 1) : undefined);
            }
            return that._skip;
        },

        take: function() {
            return this._take || this._pageSize;
        },

        _prefetchSuccessHandler: function (skip, size, callback) {
            var that = this;

            return function(data) {
                var found = false,
                    range = { start: skip, end: size, data: [] },
                    idx,
                    length,
                    temp;

                that._dequeueRequest();

                that.trigger(REQUESTEND, { response: data, type: "read" });

                data = that.reader.parse(data);

                temp = that._readData(data);

                if (temp.length) {
                    for (idx = 0, length = that._ranges.length; idx < length; idx++) {
                        if (that._ranges[idx].start === skip) {
                            found = true;
                            range = that._ranges[idx];
                            break;
                        }
                    }
                    if (!found) {
                        that._ranges.push(range);
                    }
                }

                range.data = that._observe(temp);
                range.end = range.start + that._flatData(range.data).length;
                that._ranges.sort( function(x, y) { return x.start - y.start; } );
                that._total = that.reader.total(data);

                if (callback && temp.length) {
                    callback();
                } else {
                    that.trigger(CHANGE, {});
                }
            };
        },

        prefetch: function(skip, take, callback) {
            var that = this,
                size = math.min(skip + take, that.total()),
                options = {
                    take: take,
                    skip: skip,
                    page: skip / take + 1,
                    pageSize: take,
                    sort: that._sort,
                    filter: that._filter,
                    group: that._group,
                    aggregate: that._aggregate
                };

            if (!that._rangeExists(skip, size)) {
                clearTimeout(that._timeout);

                that._timeout = setTimeout(function() {
                    that._queueRequest(options, function() {
                        if (!that.trigger(REQUESTSTART, { type: "read" })) {
                            that.transport.read({
                                data: that._params(options),
                                success: that._prefetchSuccessHandler(skip, size, callback)
                            });
                        } else {
                            that._dequeueRequest();
                        }
                    });
                }, 100);
            } else if (callback) {
                callback();
            }
        },

        _rangeExists: function(start, end) {
            var that = this,
                ranges = that._ranges,
                idx,
                length;

            for (idx = 0, length = ranges.length; idx < length; idx++) {
                if (ranges[idx].start <= start && ranges[idx].end >= end) {
                    return true;
                }
            }
            return false;
        },

        _removeModelFromRanges: function(model) {
            var result,
                found,
                range;

            for (var idx = 0, length = this._ranges.length; idx < length; idx++) {
                range = this._ranges[idx];

                this._eachItem(range.data, function(items) {
                    result = removeModel(items, model);
                    if (result) {
                        found = true;
                    }
                });

                if (found) {
                    break;
                }
            }
        },

        _updateRangesLength: function() {
            var startOffset = 0,
                range,
                rangeLength;

            for (var idx = 0, length = this._ranges.length; idx < length; idx++) {
                range = this._ranges[idx];
                range.start = range.start - startOffset;

                rangeLength = this._flatData(range.data).length;
                startOffset = range.end - rangeLength;
                range.end = range.start + rangeLength;
            }
        }
    });

    var Transport = {};

    Transport.create = function(options, data) {
        var transport,
            transportOptions = options.transport;

        if (transportOptions) {
            transportOptions.read = typeof transportOptions.read === STRING ? { url: transportOptions.read } : transportOptions.read;

            if (options.type) {
                if (kendo.data.transports[options.type] && !isPlainObject(kendo.data.transports[options.type])) {
                    transport = new kendo.data.transports[options.type](extend(transportOptions, { data: data }));
                } else {
                    transportOptions = extend(true, {}, kendo.data.transports[options.type], transportOptions);
                }

                options.schema = extend(true, {}, kendo.data.schemas[options.type], options.schema);
            }

            if (!transport) {
                transport = isFunction(transportOptions.read) ? transportOptions : new RemoteTransport(transportOptions);
            }
        } else {
            transport = new LocalTransport({ data: options.data });
        }
        return transport;
    };

    DataSource.create = function(options) {
        if (isArray(options) || options instanceof ObservableArray) {
           options = { data: options };
        }

        var dataSource = options || {},
            data = dataSource.data,
            fields = dataSource.fields,
            table = dataSource.table,
            select = dataSource.select,
            idx,
            length,
            model = {},
            field;

        if (!data && fields && !dataSource.transport) {
            if (table) {
                data = inferTable(table, fields);
            } else if (select) {
                data = inferSelect(select, fields);
            }
        }

        if (kendo.data.Model && fields && (!dataSource.schema || !dataSource.schema.model)) {
            for (idx = 0, length = fields.length; idx < length; idx++) {
                field = fields[idx];
                if (field.type) {
                    model[field.field] = field;
                }
            }

            if (!isEmptyObject(model)) {
                dataSource.schema = extend(true, dataSource.schema, { model:  { fields: model } });
            }
        }

        dataSource.data = data;
        table = null;
        dataSource.table = null;

        return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);
    };

    function inferSelect(select, fields) {
        var options = $(select)[0].children,
            idx,
            length,
            data = [],
            record,
            firstField = fields[0],
            secondField = fields[1],
            value,
            option;

        for (idx = 0, length = options.length; idx < length; idx++) {
            record = {};
            option = options[idx];

            if (option.disabled) {
                continue;
            }

            record[firstField.field] = option.text;

            value = option.attributes.value;

            if (value && value.specified) {
                value = option.value;
            } else {
                value = option.text;
            }

            record[secondField.field] = value;

            data.push(record);
        }

        return data;
    }

    // function inferTable(table, fields) {
    //     var tbody = $(table)[0].tBodies[0],
    //     rows = tbody ? tbody.rows : [],
    //     idx,
    //     length,
    //     fieldIndex,
    //     fieldCount = fields.length,
    //     data = [],
    //     cells,
    //     record,
    //     cell,
    //     empty;

    //     for (idx = 0, length = rows.length; idx < length; idx++) {
    //         record = {};
    //         empty = true;
    //         cells = rows[idx].cells;

    //         for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {
    //             cell = cells[fieldIndex];
    //             if(cell.nodeName.toLowerCase() !== "th") {
    //                 empty = false;
    //                 record[fields[fieldIndex].field] = cell.innerHTML;
    //             }
    //         }
    //         if(!empty) {
    //             data.push(record);
    //         }
    //     }

    //     return data;
    // }

    // var Node = Model.define({
    //     init: function(value) {
    //         var that = this,
    //             hasChildren = that.hasChildren || value && value.hasChildren,
    //             childrenField = "items",
    //             childrenOptions = {};

    //         kendo.data.Model.fn.init.call(that, value);

    //         if (typeof that.children === STRING) {
    //             childrenField = that.children;
    //         }

    //         childrenOptions = {
    //             schema: {
    //                 data: childrenField,
    //                 model: {
    //                     hasChildren: hasChildren,
    //                     id: that.idField
    //                 }
    //             }
    //         };

    //         if (typeof that.children !== STRING) {
    //             extend(childrenOptions, that.children);
    //         }

    //         childrenOptions.data = value;

    //         if (!hasChildren) {
    //             hasChildren = childrenOptions.schema.data;
    //         }

    //         if (typeof hasChildren === STRING) {
    //             hasChildren = kendo.getter(hasChildren);
    //         }

    //         if (isFunction(hasChildren)) {
    //             that.hasChildren = !!hasChildren.call(that, that);
    //         }

    //         that._childrenOptions = childrenOptions;

    //         if (that.hasChildren) {
    //             that._initChildren();
    //         }

    //         that._loaded = !!(value && (value[childrenField] || value._loaded));
    //     },

    //     _initChildren: function() {
    //         var that = this;
    //         var children, transport, parameterMap;

    //         if (!(that.children instanceof HierarchicalDataSource)) {
    //             children = that.children = new HierarchicalDataSource(that._childrenOptions);

    //             transport = children.transport;
    //             parameterMap = transport.parameterMap;

    //             transport.parameterMap = function(data, type) {
    //                 data[that.idField || "id"] = that.id;

    //                 if (parameterMap) {
    //                     data = parameterMap(data, type);
    //                 }

    //                 return data;
    //             };

    //             children.parent = function(){
    //                 return that;
    //             };

    //             children.bind(CHANGE, function(e){
    //                 e.node = e.node || that;
    //                 that.trigger(CHANGE, e);
    //             });

    //             children.bind(ERROR, function(e){
    //                 var collection = that.parent();

    //                 if (collection) {
    //                     e.node = e.node || that;
    //                     collection.trigger(ERROR, e);
    //                 }
    //             });

    //             that._updateChildrenField();
    //         }
    //     },

    //     append: function(model) {
    //         this._initChildren();
    //         this.loaded(true);
    //         this.children.add(model);
    //     },

    //     hasChildren: false,

    //     level: function() {
    //         var parentNode = this.parentNode(),
    //             level = 0;

    //         while (parentNode && parentNode.parentNode) {
    //             level++;
    //             parentNode = parentNode.parentNode ? parentNode.parentNode() : null;
    //         }

    //         return level;
    //     },

    //     _updateChildrenField: function() {
    //         var fieldName = this._childrenOptions.schema.data;

    //         this[fieldName || "items"] = this.children.data();
    //     },

    //     _childrenLoaded: function() {
    //         this._loaded = true;

    //         this._updateChildrenField();
    //     },

    //     load: function() {
    //         var options = {};
    //         var method = "_query";
    //         var children;

    //         if (this.hasChildren) {
    //             this._initChildren();

    //             children = this.children;

    //             options[this.idField || "id"] = this.id;

    //             if (!this._loaded) {
    //                 children._data = undefined;
    //                 method = "read";
    //             }

    //             children.one(CHANGE, proxy(this._childrenLoaded, this));
    //             children[method](options);
    //         } else {
    //             this.loaded(true);
    //         }
    //     },

    //     parentNode: function() {
    //         var array = this.parent();

    //         return array.parent();
    //     },

    //     loaded: function(value) {
    //         if (value !== undefined) {
    //             this._loaded = value;
    //         } else {
    //             return this._loaded;
    //         }
    //     },

    //     shouldSerialize: function(field) {
    //         return Model.fn.shouldSerialize.call(this, field) &&
    //                 field !== "children" &&
    //                 field !== "_loaded" &&
    //                 field !== "hasChildren" &&
    //                 field !== "_childrenOptions";
    //     }
    // });

    // function dataMethod(name) {
    //     return function() {
    //         var data = this._data,
    //             result = DataSource.fn[name].apply(this, slice.call(arguments));

    //         if (this._data != data) {
    //             this._attachBubbleHandlers();
    //         }

    //         return result;
    //     };
    // }

    // var HierarchicalDataSource = DataSource.extend({
    //     init: function(options) {
    //         var node = Node.define({
    //             children: options
    //         });

    //         DataSource.fn.init.call(this, extend(true, {}, { schema: { modelBase: node, model: node } }, options));

    //         this._attachBubbleHandlers();
    //     },

    //     _attachBubbleHandlers: function() {
    //         var that = this;

    //         that._data.bind(ERROR, function(e) {
    //             that.trigger(ERROR, e);
    //         });
    //     },

    //     remove: function(node){
    //         var parentNode = node.parentNode(),
    //             dataSource = this,
    //             result;

    //         if (parentNode && parentNode._initChildren) {
    //             dataSource = parentNode.children;
    //         }

    //         result = DataSource.fn.remove.call(dataSource, node);

    //         if (parentNode && !dataSource.data().length) {
    //             parentNode.hasChildren = false;
    //         }

    //         return result;
    //     },

    //     success: dataMethod("success"),

    //     data: dataMethod("data"),

    //     insert: function(index, model) {
    //         var parentNode = this.parent();

    //         if (parentNode && parentNode._initChildren) {
    //             parentNode.hasChildren = true;
    //             parentNode._initChildren();
    //         }

    //         return DataSource.fn.insert.call(this, index, model);
    //     },

    //     _find: function(method, value) {
    //         var idx, length, node, data, children;

    //         node = DataSource.fn[method].call(this, value);

    //         if (node) {
    //             return node;
    //         }

    //         data = this._flatData(this.data());

    //         if (!data) {
    //             return;
    //         }

    //         for (idx = 0, length = data.length; idx < length; idx++) {
    //             children = data[idx].children;

    //             if (!(children instanceof HierarchicalDataSource)) {
    //                 continue;
    //             }

    //             node = children[method](value);

    //             if (node) {
    //                 return node;
    //             }
    //         }
    //     },

    //     get: function(id) {
    //         return this._find("get", id);
    //     },

    //     getByUid: function(uid) {
    //         return this._find("getByUid", uid);
    //     }
    // });

    // function inferList(list, fields) {
    //     var items = $(list).children(),
    //         idx,
    //         length,
    //         data = [],
    //         record,
    //         textField = fields[0].field,
    //         urlField = fields[1] && fields[1].field,
    //         spriteCssClassField = fields[2] && fields[2].field,
    //         imageUrlField = fields[3] && fields[3].field,
    //         item,
    //         id,
    //         textChild,
    //         className,
    //         children;

    //     function elements(collection, tagName) {
    //         return collection.filter(tagName).add(collection.find(tagName));
    //     }

    //     for (idx = 0, length = items.length; idx < length; idx++) {
    //         record = { _loaded: true };
    //         item = items.eq(idx);

    //         textChild = item[0].firstChild;
    //         children = item.children();
    //         list = children.filter("ul");
    //         children = children.filter(":not(ul)");

    //         id = item.attr("data-id");

    //         if (id) {
    //             record.id = id;
    //         }

    //         if (textChild) {
    //             record[textField] = textChild.nodeType == 3 ? textChild.nodeValue : children.text();
    //         }

    //         if (urlField) {
    //             record[urlField] = elements(children, "a").attr("href");
    //         }

    //         if (imageUrlField) {
    //             record[imageUrlField] = elements(children, "img").attr("src");
    //         }

    //         if (spriteCssClassField) {
    //             className = elements(children, ".k-sprite").prop("className");
    //             record[spriteCssClassField] = className && $.trim(className.replace("k-sprite", ""));
    //         }

    //         if (list.length) {
    //             record.items = inferList(list.eq(0), fields);
    //         }

    //         if (item.attr("data-hasChildren") == "true") {
    //             record.hasChildren = true;
    //         }

    //         data.push(record);
    //     }

    //     return data;
    // }

    // HierarchicalDataSource.create = function(options) {
    //     options = options && options.push ? { data: options } : options;

    //     var dataSource = options || {},
    //         data = dataSource.data,
    //         fields = dataSource.fields,
    //         list = dataSource.list;

    //     if (data && data._dataSource) {
    //         return data._dataSource;
    //     }

    //     if (!data && fields && !dataSource.transport) {
    //         if (list) {
    //             data = inferList(list, fields);
    //         }
    //     }

    //     dataSource.data = data;

    //     return dataSource instanceof HierarchicalDataSource ? dataSource : new HierarchicalDataSource(dataSource);
    // };

    // var Buffer = kendo.Observable.extend({
    //     init: function(dataSource, viewSize, disablePrefetch) {
    //         kendo.Observable.fn.init.call(this);

    //         this._prefetching = false;
    //         this.dataSource = dataSource;
    //         this.prefetch = !disablePrefetch;

    //         var buffer = this;

    //         dataSource.bind("change", function() {
    //             buffer._change();
    //         });

    //         this._syncWithDataSource();

    //         this.setViewSize(viewSize);
    //     },

    //     setViewSize: function(viewSize) {
    //         this.viewSize = viewSize;
    //         this._recalculate();
    //     },

    //     at: function(index)  {
    //         var pageSize = this.pageSize, item;

    //         if (index >= this.total()) {
    //             this.trigger("endreached", {index: index });
    //             return;
    //         }

    //         if (!this.useRanges) {
    //            return this.dataSource.view()[index];
    //         }
    //         if (this.useRanges) {
    //             // out of range request
    //             if (index < this.dataOffset || index > this.skip + pageSize) {
    //                 var offset = Math.floor(index / pageSize) * pageSize;
    //                 this.range(offset);
    //             }

    //             // prefetch
    //             if (index === this.prefetchThreshold) {
    //                 this._prefetch();
    //             }

    //             // mid-range jump - prefetchThreshold and nextPageThreshold may be equal, do not change to else if
    //             if (index === this.midPageThreshold) {
    //                 this.range(this.nextMidRange);
    //             }
    //             // next range jump
    //             else if (index === this.nextPageThreshold) {
    //                 this.range(this.nextFullRange);
    //             }
    //             // pull-back
    //             else if (index === this.pullBackThreshold) {
    //                 if (this.offset === this.skip) { // from full range to mid range
    //                     this.range(this.previousMidRange);
    //                 } else { // from mid range to full range
    //                     this.range(this.previousFullRange);
    //                 }
    //             }

    //             item = this.dataSource.at(index - this.dataOffset);
    //         }

    //         if (item === undefined) {
    //             this.trigger("endreached", { index: index });
    //         }

    //         return item;
    //     },

    //     indexOf: function(item) {
    //         return this.dataSource.data().indexOf(item) + this.dataOffset;
    //     },

    //     total: function() {
    //         return parseInt(this.dataSource.total(), 10);
    //     },

    //     next: function() {
    //         var buffer = this,
    //             pageSize = buffer.pageSize,
    //             offset = buffer.skip - buffer.viewSize, // this calculation relies that the buffer has already jumped into the mid range segment
    //             pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize + pageSize;

    //         this.offset = offset;
    //         this.dataSource.prefetch(pageSkip, pageSize, function() {
    //             buffer._goToRange(offset, true);
    //         });
    //     },

    //     range: function(offset) {
    //         if (this.offset === offset) {
    //             return;
    //         }

    //         var buffer = this,
    //             pageSize = this.pageSize,
    //             pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize + pageSize,
    //             dataSource = this.dataSource;

    //         this.offset = offset;
    //         this._recalculate();
    //         if (dataSource.inRange(offset, pageSize)) {
    //             this._goToRange(offset);
    //         } else if (this.prefetch) {
    //             dataSource.prefetch(pageSkip, pageSize, function() {
    //                 buffer._goToRange(offset, true);
    //             });
    //         }
    //     },

    //     syncDataSource: function() {
    //         var offset = this.offset;
    //         this.offset = null;
    //         this.range(offset);
    //     },

    //     destroy: function() {
    //         this.unbind();
    //     },

    //     _prefetch: function() {
    //         var buffer = this,
    //             pageSize = this.pageSize,
    //             prefetchOffset = this.skip + pageSize,
    //             dataSource = this.dataSource;

    //         if (!dataSource.inRange(prefetchOffset, pageSize) && !this._prefetching && this.prefetch) {
    //             this._prefetching = true;
    //             this.trigger("prefetching", { skip: prefetchOffset, take: pageSize });

    //             dataSource.prefetch(prefetchOffset, pageSize, function() {
    //                 buffer._prefetching = false;
    //                 buffer.trigger("prefetched", { skip: prefetchOffset, take: pageSize });
    //             });
    //         }
    //     },

    //     _goToRange: function(offset, expanding) {
    //         if (this.offset !== offset) {
    //             return;
    //         }

    //         this.dataOffset = offset;
    //         this._expanding = expanding;
    //         this.dataSource.range(offset, this.pageSize);
    //     },

    //     _change: function() {
    //         var dataSource = this.dataSource,
    //             firstItemUid = dataSource.firstItemUid();

    //         this.length = this.useRanges ? dataSource.lastRange().end : dataSource.view().length;

    //         if (this._firstItemUid !== firstItemUid || !this.useRanges) {
    //             this._syncWithDataSource();
    //             this._recalculate();
    //             this.trigger("reset", { offset: this.offset });
    //         }

    //         this.trigger("resize");

    //         if (this._expanding) {
    //             this.trigger("expand");
    //         }

    //         delete this._expanding;
    //     },

    //     _syncWithDataSource: function() {
    //         var dataSource = this.dataSource;

    //         this._firstItemUid = dataSource.firstItemUid();
    //         this.dataOffset = this.offset = dataSource.skip() || 0;
    //         this.pageSize = dataSource.pageSize();
    //         this.useRanges = dataSource.options.serverPaging;
    //     },

    //     _recalculate: function() {
    //         var pageSize = this.pageSize,
    //             offset = this.offset,
    //             viewSize = this.viewSize,
    //             skip = Math.ceil(offset / pageSize) * pageSize;

    //         this.skip = skip;
    //         this.midPageThreshold = skip + pageSize - 1;
    //         this.nextPageThreshold = skip + viewSize - 1;
    //         this.prefetchThreshold = skip + Math.floor(pageSize / 3 * 2);
    //         this.pullBackThreshold = this.offset - 1;

    //         this.nextMidRange = skip + pageSize - viewSize;
    //         this.nextFullRange = skip;
    //         this.previousMidRange = offset - viewSize;
    //         this.previousFullRange = skip - pageSize;
    //     }
    // });

    // var BatchBuffer = kendo.Observable.extend({
    //     init: function(dataSource, batchSize) {
    //         var batchBuffer = this;

    //         kendo.Observable.fn.init.call(batchBuffer);

    //         this.dataSource = dataSource;
    //         this.batchSize = batchSize;
    //         this._total = 0;

    //         this.buffer = new Buffer(dataSource, batchSize * 3);

    //         this.buffer.bind({
    //             "endreached": function (e) {
    //                 batchBuffer.trigger("endreached", { index: e.index });
    //             },
    //             "prefetching": function (e) {
    //                 batchBuffer.trigger("prefetching", { skip: e.skip, take: e.take });
    //             },
    //             "prefetched": function (e) {
    //                 batchBuffer.trigger("prefetched", { skip: e.skip, take: e.take });
    //             },
    //             "reset": function () {
    //                 batchBuffer._total = 0;
    //                 batchBuffer.trigger("reset");
    //             },
    //             "resize": function () {
    //                 batchBuffer._total = Math.ceil(this.length / batchBuffer.batchSize);
    //                 batchBuffer.trigger("resize", { total: batchBuffer.total(), offset: this.offset });
    //             }
    //         });
    //     },

    //     syncDataSource: function() {
    //         this.buffer.syncDataSource();
    //     },

    //     at: function(index) {
    //         var buffer = this.buffer,
    //             skip = index * this.batchSize,
    //             take = this.batchSize,
    //             view = [],
    //             item;

    //         if (buffer.offset > skip) {
    //             buffer.at(buffer.offset - 1);
    //         }

    //         for (var i = 0; i < take; i++) {
    //             item = buffer.at(skip + i);

    //             if (item === undefined) {
    //                 break;
    //             }

    //             view.push(item);
    //         }

    //         return view;
    //     },

    //     total: function() {
    //         return this._total;
    //     },

    //     destroy: function() {
    //         this.buffer.destroy();
    //         this.unbind();
    //     }
    // });

    extend(true, kendo.data, {
        readers: {
            json: DataReader
        },
        Query: Query,
        DataSource: DataSource,
        // HierarchicalDataSource: HierarchicalDataSource,
        // Node: Node,
        ObservableObject: ObservableObject,
        ObservableArray: ObservableArray,
        LocalTransport: LocalTransport,
        // RemoteTransport: RemoteTransport,
        // Cache: Cache,
        DataReader: DataReader,
        Model: Model
        // Buffer: Buffer,
        // BatchBuffer: BatchBuffer
    });
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.tabstrip',[ "./kendo.data" ], f);
})(function(){

(function ($, undefined) {
    var kendo = window.kendo,
        ui = kendo.ui,
        keys = kendo.keys,
        map = $.map,
        each = $.each,
        trim = $.trim,
        extend = $.extend,
        template = kendo.template,
        Widget = ui.Widget,
        excludedNodesRegExp = /^(a|div)$/i,
        NS = ".kendoTabStrip",
        IMG = "img",
        HREF = "href",
        PREV = "prev",
        LINK = "k-link",
        LAST = "k-last",
        CLICK = "click",
        ERROR = "error",
        EMPTY = ":empty",
        IMAGE = "k-image",
        FIRST = "k-first",
        SELECT = "select",
        ACTIVATE = "activate",
        CONTENT = "k-content",
        CONTENTURL = "contentUrl",
        MOUSEENTER = "mouseenter",
        MOUSELEAVE = "mouseleave",
        CONTENTLOAD = "contentLoad",
        DISABLEDSTATE = "k-state-disabled",
        DEFAULTSTATE = "k-state-default",
        ACTIVESTATE = "k-state-active",
        FOCUSEDSTATE = "k-state-focused",
        HOVERSTATE = "k-state-hover",
        TABONTOP = "k-tab-on-top",
        NAVIGATABLEITEMS = ".k-item:not(." + DISABLEDSTATE + ")",
        HOVERABLEITEMS = ".k-tabstrip-items > " + NAVIGATABLEITEMS + ":not(." + ACTIVESTATE + ")",

        templates = {
            content: template(
                "<div class='k-content'#= contentAttributes(data) # role='tabpanel'>#= content(item) #</div>"
            ),
            itemWrapper: template(
                "<#= tag(item) # class='k-link'#= contentUrl(item) ##= textAttributes(item) #>" +
                    "#= image(item) ##= sprite(item) ##= text(item) #" +
                "</#= tag(item) #>"
            ),
            item: template(
                "<li class='#= wrapperCssClass(group, item) #' role='tab' #=item.active ? \"aria-selected='true'\" : ''#>" +
                    "#= itemWrapper(data) #" +
                "</li>"
            ),
            image: template("<img class='k-image' alt='' src='#= imageUrl #' />"),
            sprite: template("<span class='k-sprite #= spriteCssClass #'></span>"),
            empty: template("")
        },

        rendering = {
            wrapperCssClass: function (group, item) {
                var result = "k-item",
                    index = item.index;

                if (item.enabled === false) {
                    result += " k-state-disabled";
                } else {
                    result += " k-state-default";
                }

                if (index === 0) {
                    result += " k-first";
                }

                if (index == group.length-1) {
                    result += " k-last";
                }

                return result;
            },
            textAttributes: function(item) {
                return item.url ? " href='" + item.url + "'" : "";
            },
            text: function(item) {
                return item.encoded === false ? item.text : kendo.htmlEncode(item.text);
            },
            tag: function(item) {
                return item.url ? "a" : "span";
            },
            contentAttributes: function(content) {
                return content.active !== true ? " style='display:none' aria-hidden='true' aria-expanded='false'" : "";
            },
            content: function(item) {
                return item.content ? item.content : item.contentUrl ? "" : "&nbsp;";
            },
            contentUrl: function(item) {
                return item.contentUrl ? kendo.attr("content-url") + '="' + item.contentUrl + '"' : "";
            }
        };

    function updateTabClasses (tabs) {
        tabs.children(IMG)
            .addClass(IMAGE);

        tabs.children("a")
            .addClass(LINK)
            .children(IMG)
            .addClass(IMAGE);

        tabs.filter(":not([disabled]):not([class*=k-state-disabled])")
            .addClass(DEFAULTSTATE);

        tabs.filter("li[disabled]")
            .addClass(DISABLEDSTATE)
            .removeAttr("disabled");

        tabs.filter(":not([class*=k-state])")
            .children("a")
            .filter(":focus")
            .parent()
            .addClass(ACTIVESTATE + " " + TABONTOP);

        tabs.attr("role", "tab");
        tabs.filter("." + ACTIVESTATE)
            .attr("aria-selected", true);


        tabs.each(function() {
            var item = $(this);

            if (!item.children("." + LINK).length) {
                item
                    .contents()      // exclude groups, real links, templates and empty text nodes
                    .filter(function() { return (!this.nodeName.match(excludedNodesRegExp) && !(this.nodeType == 3 && !trim(this.nodeValue))); })
                    .wrapAll("<a class='" + LINK + "'/>");
            }
        });

    }

    function updateFirstLast (tabGroup) {
        var tabs = tabGroup.children(".k-item");

        tabs.filter(".k-first:not(:first-child)").removeClass(FIRST);
        tabs.filter(".k-last:not(:last-child)").removeClass(LAST);
        tabs.filter(":first-child").addClass(FIRST);
        tabs.filter(":last-child").addClass(LAST);
    }

    var TabStrip = Widget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            that._animations(that.options);

            if (that.element.is("ul")) {
                that.wrapper = that.element.wrapAll("<div />").parent();
            } else {
                that.wrapper = that.element;
            }

            options = that.options;

            that._isRtl = kendo.support.isRtl(that.wrapper);

            that._tabindex();

            that._updateClasses();

            that._dataSource();

            if (options.dataSource) {
                that.dataSource.fetch();
            }

            if (that.options.contentUrls) {
                that.wrapper.find(".k-tabstrip-items > .k-item")
                    .each(function(index, item) {
                        $(item).find(">." + LINK).data(CONTENTURL, that.options.contentUrls[index]);
                    });
            }

            that.wrapper
                .on(MOUSEENTER + NS + " " + MOUSELEAVE + NS, HOVERABLEITEMS, that._toggleHover)
                .on("keydown" + NS, $.proxy(that._keydown, that))
                .on("focus" + NS, $.proxy(that._active, that))
                .on("blur" + NS, function() { that._current(null); });

            that.wrapper.children(".k-tabstrip-items")
                .on(CLICK + NS, ".k-state-disabled .k-link", false)
                .on(CLICK + NS, " > " + NAVIGATABLEITEMS, function(e) {
                    if (that.wrapper[0] !== document.activeElement) {
                        that.wrapper.focus();
                    }

                    if (that._click($(e.currentTarget))) {
                        e.preventDefault();
                    }
                });

            var selectedItems = that.tabGroup.children("li." + ACTIVESTATE),
                content = that.contentHolder(selectedItems.index());

            if (selectedItems[0] && content.length > 0 && content[0].childNodes.length === 0) {
                that.activateTab(selectedItems.eq(0));
            }

            that.element.attr("role", "tablist");

            if (that.element[0].id) {
                that._ariaId = that.element[0].id + "_ts_active";
            }

            kendo.notify(that);
        },

        _active: function() {
            var item = this.tabGroup.children().filter("." + ACTIVESTATE);

            item = item[0] ? item : this._endItem("first");
            if (item[0]) {
                this._current(item);
            }
        },

        _endItem: function(action) {
            return this.tabGroup.children(NAVIGATABLEITEMS)[action]();
        },

        _item: function(item, action) {
            var endItem;
            if (action === PREV) {
                endItem = "last";
            } else {
                endItem = "first";
            }

            if (!item) {
                return this._endItem(endItem);
            }

            item = item[action]();

            if (!item[0]) {
                item = this._endItem(endItem);
            }

            if (item.hasClass(DISABLEDSTATE)) {
                item = this._item(item, action);
            }

            return item;
        },

        _current: function(candidate) {
            var that = this,
                focused = that._focused,
                id = that._ariaId;

            if (candidate === undefined) {
                return focused;
            }

            if (focused) {
                if (focused[0].id === id) {
                    focused.removeAttr("id");
                }
                focused.removeClass(FOCUSEDSTATE);
            }

            if (candidate) {
                if (!candidate.hasClass(ACTIVESTATE)) {
                    candidate.addClass(FOCUSEDSTATE);
                }

                that.element.removeAttr("aria-activedescendant");

                id = candidate[0].id || id;

                if (id) {
                    candidate.attr("id", id);
                    that.element.attr("aria-activedescendant", id);
                }
            }

            that._focused = candidate;
        },

        _keydown: function(e) {
            var that = this,
                key = e.keyCode,
                current = that._current(),
                rtl = that._isRtl,
                action;

            if (e.target != e.currentTarget) {
                return;
            }

            if (key == keys.DOWN || key == keys.RIGHT) {
                action = rtl ? PREV : "next";
            } else if (key == keys.UP || key == keys.LEFT) {
                action = rtl ? "next" : PREV;
            } else if (key == keys.ENTER || key == keys.SPACEBAR) {
                that._click(current);
                e.preventDefault();
            } else if (key == keys.HOME) {
                that._click(that._endItem("first"));
                e.preventDefault();
                return;
            } else if (key == keys.END) {
                that._click(that._endItem("last"));
                e.preventDefault();
                return;
            }

            if (action) {
                that._click(that._item(current, action));
                e.preventDefault();
            }
        },

        _dataSource: function() {
            var that = this;

            if (that.dataSource && that._refreshHandler) {
                that.dataSource.unbind("change", that._refreshHandler);
            } else {
                that._refreshHandler = $.proxy(that.refresh, that);
            }

            that.dataSource = kendo.data.DataSource.create(that.options.dataSource)
                                .bind("change", that._refreshHandler);
        },

        setDataSource: function(dataSource) {
            this.options.dataSource = dataSource;
            this._dataSource();
            dataSource.fetch();
        },

        _animations: function(options) {
            if (options && ("animation" in options) && !options.animation) {
                options.animation = { open: { effects: {} }, close: { effects: {} } }; // No animation
            }
        },

        refresh: function(e) {
            var that = this,
                options = that.options,
                text = kendo.getter(options.dataTextField),
                content = kendo.getter(options.dataContentField),
                contentUrl = kendo.getter(options.dataContentUrlField),
                image = kendo.getter(options.dataImageUrlField),
                url = kendo.getter(options.dataUrlField),
                sprite = kendo.getter(options.dataSpriteCssClass),
                idx,
                tabs = [],
                tab,
                action,
                view = that.dataSource.view(),
                length;


            e = e || {};
            action = e.action;

            if (action) {
               view = e.items;
            }

            for (idx = 0, length = view.length; idx < length; idx ++) {
                tab = {
                    text: text(view[idx])
                };

                if (options.dataContentField) {
                    tab.content = content(view[idx]);
                }

                if (options.dataContentUrlField) {
                    tab.contentUrl = contentUrl(view[idx]);
                }

                if (options.dataUrlField) {
                    tab.url = url(view[idx]);
                }

                if (options.dataImageUrlField) {
                    tab.imageUrl = image(view[idx]);
                }

                if (options.dataSpriteCssClass) {
                    tab.spriteCssClass = sprite(view[idx]);
                }

                tabs[idx] = tab;
            }

            if (e.action == "add") {
                if (e.index < that.tabGroup.children().length) {
                    that.insertBefore(tabs, that.tabGroup.children().eq(e.index));
                } else {
                    that.append(tabs);
                }
            } else if (e.action == "remove") {
                for (idx = 0; idx < view.length; idx++) {
                   that.remove(e.index);
                }
            } else if (e.action == "itemchange") {
                idx = that.dataSource.view().indexOf(view[0]);
                if (e.field === options.dataTextField) {
                    that.tabGroup.children().eq(idx).find(".k-link").text(view[0].get(e.field));
                }
            } else {
                that.trigger("dataBinding");
                that.remove("li");
                that.append(tabs);
                that.trigger("dataBound");
            }
        },

        value: function(value) {
            var that = this;

            if (value !== undefined) {
                if (value != that.value()) {
                   that.tabGroup.children().each(function() {
                        if ($.trim($(this).text()) == value) {
                            that.select(this);
                        }
                   });
                }
            } else {
                return that.select().text();
            }
        },

        items: function() {
            return this.tabGroup[0].children;
        },

        setOptions: function(options) {
            var animation = this.options.animation;

            this._animations(options);

            options.animation = extend(true, animation, options.animation);

            Widget.fn.setOptions.call(this, options);
        },

        events: [
            SELECT,
            ACTIVATE,
            ERROR,
            CONTENTLOAD,
            "change",
            "dataBinding",
            "dataBound"
        ],

        options: {
            name: "TabStrip",
            dataTextField: "",
            dataContentField: "",
            dataImageUrlField: "",
            dataUrlField: "",
            dataSpriteCssClass: "",
            dataContentUrlField: "",
            animation: {
                open: {
                    effects: "expand:vertical fadeIn",
                    duration: 200
                },
                close: { // if close animation effects are defined, they will be used instead of open.reverse
                    duration: 200
                }
            },
            collapsible: false
        },

        destroy: function() {
            var that = this;

            Widget.fn.destroy.call(that);

            if (that._refreshHandler) {
                that.dataSource.unbind("change", that._refreshHandler);
            }

            that.wrapper.off(NS);
            that.wrapper.children(".k-tabstrip-items").off(NS);

            kendo.destroy(that.wrapper);
        },

        select: function (element) {
            var that = this;

            if (arguments.length === 0) {
                return that.tabGroup.children("li." + ACTIVESTATE);
            }

            if (!isNaN(element)) {
                element = that.tabGroup.children().get(element);
            }

            element = that.tabGroup.find(element);
            $(element).each(function (index, item) {
                item = $(item);
                if (!item.hasClass(ACTIVESTATE) && !that.trigger(SELECT, { item: item[0], contentElement: that.contentHolder(item.index())[0] })) {
                    that.activateTab(item);
                }
            });

            return that;
        },

        enable: function (element, state) {
            this._toggleDisabled(element, state !== false);

            return this;
        },

        disable: function (element) {
            this._toggleDisabled(element, false);

            return this;
        },

        reload: function (element) {
            element = this.tabGroup.find(element);
            var that = this;

            element.each(function () {
                var item = $(this),
                    contentUrl = item.find("." + LINK).data(CONTENTURL),
                    content = that.contentHolder(item.index());

                if (contentUrl) {
                    that.ajaxRequest(item, content, null, contentUrl);
                }
            });

            return that;
        },

        append: function (tab) {
            var that = this,
                inserted = that._create(tab);

            each(inserted.tabs, function (idx) {
                that.tabGroup.append(this);
                that.wrapper.append(inserted.contents[idx]);
            });

            updateFirstLast(that.tabGroup);
            that._updateContentElements();

            return that;
        },

        insertBefore: function (tab, referenceTab) {
            referenceTab = this.tabGroup.find(referenceTab);

            var that = this,
                inserted = that._create(tab),
                referenceContent = $(that.contentElement(referenceTab.index()));

            each(inserted.tabs, function (idx) {
                referenceTab.before(this);
                referenceContent.before(inserted.contents[idx]);
            });

            updateFirstLast(that.tabGroup);
            that._updateContentElements();

            return that;
        },

        insertAfter: function (tab, referenceTab) {
            referenceTab = this.tabGroup.find(referenceTab);

            var that = this,
                inserted = that._create(tab),
                referenceContent = $(that.contentElement(referenceTab.index()));

            each(inserted.tabs, function (idx) {
                referenceTab.after(this);
                referenceContent.after(inserted.contents[idx]);
            });

            updateFirstLast(that.tabGroup);
            that._updateContentElements();

            return that;
        },

        remove: function (elements) {
            var that = this,
                type = typeof elements,
                contents = $();

            if (type === "string") {
                elements = that.tabGroup.find(elements);
            } else if (type === "number") {
                elements = that.tabGroup.children().eq(elements);
            }

            elements.each(function () {
                contents.push(that.contentElement($(this).index()));
            });
            elements.remove();
            contents.remove();

            that._updateContentElements();

            return that;
        },

        _create: function (tab) {
            var plain = $.isPlainObject(tab),
                that = this, tabs, contents, content;

            if (plain || $.isArray(tab)) {
                tab = $.isArray(tab) ? tab : [tab];

                tabs = map(tab, function (value, idx) {
                            return $(TabStrip.renderItem({
                                group: that.tabGroup,
                                item: extend(value, { index: idx })
                            }));
                        });

                contents = map( tab, function (value, idx) {
                            if (value.content || value.contentUrl) {
                                return $(TabStrip.renderContent({
                                    item: extend(value, { index: idx })
                                }));
                            }
                        });
            } else {
                if (typeof tab == "string" && tab[0] != "<") {
                    tabs = that.element.find(tab);
                } else {
                    tabs = $(tab);
                }
                contents = $();
                tabs.each(function () {
                    content = $("<div class='" + CONTENT + "'/>");
                    if (/k-tabstrip-items/.test(this.parentNode.className)) {
                        var index = parseInt(this.getAttribute("aria-controls").replace(/^.*-/, ""), 10) - 1;
                        content = $(that.contentElement(index));
                    }
                    contents = contents.add(content);
                });

                updateTabClasses(tabs);
            }

            return { tabs: tabs, contents: contents };
        },

        _toggleDisabled: function(element, enable) {
            element = this.tabGroup.find(element);
            element.each(function () {
                $(this)
                    .toggleClass(DEFAULTSTATE, enable)
                    .toggleClass(DISABLEDSTATE, !enable);
            });
        },

        _updateClasses: function() {
            var that = this,
                tabs, activeItem, activeTab;

            that.wrapper.addClass("k-widget k-header k-tabstrip");

            that.tabGroup = that.wrapper.children("ul").addClass("k-tabstrip-items k-reset");

            if (!that.tabGroup[0]) {
                that.tabGroup = $("<ul class='k-tabstrip-items k-reset'/>").appendTo(that.wrapper);
            }

            tabs = that.tabGroup.find("li").addClass("k-item");

            if (tabs.length) {
                activeItem = tabs.filter("." + ACTIVESTATE).index();
                activeTab = activeItem >= 0 ? activeItem : undefined;

                that.tabGroup // Remove empty text nodes
                    .contents()
                    .filter(function () { return (this.nodeType == 3 && !trim(this.nodeValue)); })
                    .remove();
            }

            if (activeItem >= 0) {
                tabs.eq(activeItem).addClass(TABONTOP);
            }

            that.contentElements = that.wrapper.children("div");

            that.contentElements
                .addClass(CONTENT)
                .eq(activeTab)
                .addClass(ACTIVESTATE)
                .css({ display: "block" });

            if (tabs.length) {
                updateTabClasses(tabs);

                updateFirstLast(that.tabGroup);
                that._updateContentElements();
            }
        },

        _updateContentElements: function() {
            var that = this,
                contentUrls = that.options.contentUrls || [],
                items = that.tabGroup.find(".k-item"),
                tabStripID = (that.element.attr("id") || kendo.guid()) + "-",
                contentElements = that.wrapper.children("div");

            if (contentElements.length && (items.length > contentElements.length)) {
                contentElements.each(function(idx) {
                    var currentIndex = parseInt(this.id.replace(tabStripID, ""), 10),
                        item = items.filter("[aria-controls=" + tabStripID + currentIndex + "]"),
                        id = tabStripID + (idx+1);

                    item.data("aria", id);
                    this.setAttribute("id", id);
                });

                items.each(function() {
                    var item = $(this);

                    this.setAttribute("aria-controls", item.data("aria"));
                    item.removeData("aria");
                });
            } else {
                items.each(function(idx) {
                    var currentContent = contentElements.eq(idx),
                        id = tabStripID + (idx+1);

                    this.setAttribute("aria-controls", id);

                    if (!currentContent.length && contentUrls[idx]) {
                        $("<div class='" + CONTENT + "'/>").appendTo(that.wrapper).attr("id", id);
                    } else {
                        currentContent.attr("id", id);

                        if (!$(this).children(".k-loading")[0] && !contentUrls[idx]) {
                            $("<span class='k-loading k-complete'/>").prependTo(this);
                        }
                    }
                    currentContent.attr("role", "tabpanel");
                    currentContent.filter(":not(." + ACTIVESTATE + ")").attr("aria-hidden", true).attr("aria-expanded", false);
                    currentContent.filter("." + ACTIVESTATE).attr("aria-expanded", true);
                });
            }

            that.contentElements = that.contentAnimators = that.wrapper.children("div"); // refresh the contents

            if (kendo.kineticScrollNeeded && kendo.mobile.ui.Scroller) {
                kendo.touchScroller(that.contentElements);
                that.contentElements = that.contentElements.children(".km-scroll-container");
            }
        },

        _toggleHover: function(e) {
            $(e.currentTarget).toggleClass(HOVERSTATE, e.type == MOUSEENTER);
        },

        _click: function (item) {
            var that = this,
                link = item.find("." + LINK),
                href = link.attr(HREF),
                collapse = that.options.collapsible,
                contentHolder = that.contentHolder(item.index()),
                prevent, isAnchor;

            if (item.closest(".k-widget")[0] != that.wrapper[0]) {
                return;
            }

            if (item.is("." + DISABLEDSTATE + (!collapse ? ",." + ACTIVESTATE : ""))) {
                return true;
            }

            isAnchor = link.data(CONTENTURL) || (href && (href.charAt(href.length - 1) == "#" || href.indexOf("#" + that.element[0].id + "-") != -1));
            prevent = !href || isAnchor;

            if (that.tabGroup.children("[data-animating]").length) {
                return prevent;
            }

            if (that.trigger(SELECT, { item: item[0], contentElement: contentHolder[0] })) {
                return true;
            }

            if (prevent === false) {
                return;
            }

            if (collapse && item.is("." + ACTIVESTATE)) {
                that.deactivateTab(item);
                return true;
            }

            if (that.activateTab(item)) {
                prevent = true;
            }

            return prevent;
        },

        deactivateTab: function (item) {
            var that = this,
                animationSettings = that.options.animation,
                animation = animationSettings.open,
                close = extend({}, animationSettings.close),
                hasCloseAnimation = close && "effects" in close;
            item = that.tabGroup.find(item);

            close = extend( hasCloseAnimation ? close : extend({ reverse: true }, animation), { hide: true });

            if (kendo.size(animation.effects)) {
                item.kendoAddClass(DEFAULTSTATE, { duration: animation.duration });
                item.kendoRemoveClass(ACTIVESTATE, { duration: animation.duration });
            } else {
                item.addClass(DEFAULTSTATE);
                item.removeClass(ACTIVESTATE);
            }

            item.removeAttr("aria-selected");

            that.contentAnimators
                    .filter("." + ACTIVESTATE)
                    .kendoStop(true, true)
                    .kendoAnimate( close )
                    .removeClass(ACTIVESTATE)
                    .attr("aria-hidden", true);
        },

        activateTab: function (item) {
            item = this.tabGroup.find(item);

            var that = this,
                animationSettings = that.options.animation,
                animation = animationSettings.open,
                close = extend({}, animationSettings.close),
                hasCloseAnimation = close && "effects" in close,
                neighbours = item.parent().children(),
                oldTab = neighbours.filter("." + ACTIVESTATE),
                itemIndex = neighbours.index(item);

            close = extend( hasCloseAnimation ? close : extend({ reverse: true }, animation), { hide: true });
            // deactivate previously active tab
            if (kendo.size(animation.effects)) {
                oldTab.kendoRemoveClass(ACTIVESTATE, { duration: close.duration });
                item.kendoRemoveClass(HOVERSTATE, { duration: close.duration });
            } else {
                oldTab.removeClass(ACTIVESTATE);
                item.removeClass(HOVERSTATE);
            }

            // handle content elements
            var contentAnimators = that.contentAnimators;

            if (that.inRequest) {
                that.xhr.abort();
                that.inRequest = false;
            }

            if (contentAnimators.length === 0) {
                oldTab.removeClass(TABONTOP);
                item.addClass(TABONTOP) // change these directly to bring the tab on top.
                    .css("z-index");

                item.addClass(ACTIVESTATE);
                that._current(item);

                that.trigger("change");

                return false;
            }

            var visibleContents = contentAnimators.filter("." + ACTIVESTATE),
                contentHolder = that.contentHolder(itemIndex),
                contentElement = contentHolder.closest(".k-content");

            if (contentHolder.length === 0) {
                visibleContents
                    .removeClass( ACTIVESTATE )
                    .attr("aria-hidden", true)
                    .kendoStop(true, true)
                    .kendoAnimate( close );
                return false;
            }

            item.attr("data-animating", true);

            var isAjaxContent = (item.children("." + LINK).data(CONTENTURL) || false) && contentHolder.is(EMPTY),
                showContentElement = function () {
                    oldTab.removeClass(TABONTOP);
                    item.addClass(TABONTOP) // change these directly to bring the tab on top.
                        .css("z-index");

                    if (kendo.size(animation.effects)) {
                        oldTab.kendoAddClass(DEFAULTSTATE, { duration: animation.duration });
                        item.kendoAddClass(ACTIVESTATE, { duration: animation.duration });
                    } else {
                        oldTab.addClass(DEFAULTSTATE);
                        item.addClass(ACTIVESTATE);
                    }
                    oldTab.removeAttr("aria-selected");
                    item.attr("aria-selected", true);

                    that._current(item);

                    contentElement
                        .addClass(ACTIVESTATE)
                        .removeAttr("aria-hidden")
                        .kendoStop(true, true)
                        .attr("aria-expanded", true)
                        .kendoAnimate( extend({ init: function () {
                            that.trigger(ACTIVATE, { item: item[0], contentElement: contentHolder[0] });
                        } }, animation, { complete: function () { item.removeAttr("data-animating"); } } ) );
                },
                showContent = function() {
                    if (!isAjaxContent) {
                        showContentElement();
                        that.trigger("change");
                    } else {
                        item.removeAttr("data-animating");
                        that.ajaxRequest(item, contentHolder, function () {
                            item.attr("data-animating", true);
                            showContentElement();
                            that.trigger("change");
                        });
                    }
                };

            visibleContents
                    .removeClass(ACTIVESTATE);

            visibleContents.attr("aria-hidden", true);
            visibleContents.attr("aria-expanded", false);

            if (visibleContents.length) {
                visibleContents
                    .kendoStop(true, true)
                    .kendoAnimate(extend( {
                        complete: showContent
                   }, close ));
            } else {
                showContent();
            }

            return true;
        },

        contentElement: function (itemIndex) {
            if (isNaN(itemIndex - 0)) {
                return undefined;
            }

            var contentElements = this.contentElements && this.contentElements[0] && !kendo.kineticScrollNeeded ? this.contentElements : this.contentAnimators;

            itemIndex = contentElements && itemIndex < 0 ? contentElements.length + itemIndex : itemIndex;

            var idTest = new RegExp("-" + (itemIndex + 1) + "$");

            if (contentElements) {
                for (var i = 0, len = contentElements.length; i < len; i++) {
                    if (idTest.test(contentElements.eq(i).closest(".k-content")[0].id)) {
                        return contentElements[i];
                    }
                }
            }

            return undefined;
        },

        contentHolder: function (itemIndex) {
            var contentElement = $(this.contentElement(itemIndex)),
                scrollContainer = contentElement.children(".km-scroll-container");

            return kendo.support.touch && scrollContainer[0] ? scrollContainer : contentElement;
        },

        ajaxRequest: function (element, content, complete, url) {
            element = this.tabGroup.find(element);

            var that = this,
                xhr = $.ajaxSettings.xhr,
                link = element.find("." + LINK),
                data = {},
                halfWidth = element.width() / 2,
                fakeProgress = false,
                statusIcon = element.find(".k-loading").removeClass("k-complete");

            if (!statusIcon[0]) {
                statusIcon = $("<span class='k-loading'/>").prependTo(element);
            }

            var endState = halfWidth * 2 - statusIcon.width();

            var oldProgressAnimation = function() {
                statusIcon.animate({ marginLeft: (parseInt(statusIcon.css("marginLeft"), 10) || 0) < halfWidth ? endState : 0 }, 500, oldProgressAnimation);
            };

            if (kendo.support.browser.msie && kendo.support.browser.version < 10) {
                setTimeout(oldProgressAnimation, 40);
            }

            url = url || link.data(CONTENTURL) || link.attr(HREF);
            that.inRequest = true;

            that.xhr = $.ajax({
                type: "GET",
                cache: false,
                url: url,
                dataType: "html",
                data: data,
                xhr: function() {
                    var current = this,
                        request = xhr(),
                        event = current.progressUpload ? "progressUpload" : current.progress ? "progress" : false;

                    if (request) {
                        $.each([ request, request.upload ], function () {
                            if (this.addEventListener) {
                                this.addEventListener("progress", function(evt) {
                                    if (event) {
                                        current[event](evt);
                                    }
                                }, false);
                            }
                        });
                    }

                    current.noProgress = !(window.XMLHttpRequest && ('upload' in new XMLHttpRequest()));
                    return request;
                },

                progress: function(evt) {
                    if (evt.lengthComputable) {
                        var percent = parseInt((evt.loaded / evt.total * 100), 10) + "%";
                        statusIcon
                            .stop(true)
                            .addClass("k-progress")
                            .css({
                                "width": percent,
                                "marginLeft": 0
                            });
                    }
                },

                error: function (xhr, status) {
                    if (that.trigger("error", { xhr: xhr, status: status })) {
                        this.complete();
                    }
                },

                stopProgress: function () {
                    clearInterval(fakeProgress);
                    statusIcon
                        .stop(true)
                        .addClass("k-progress")
                        [0].style.cssText = "";
                },

                complete: function (xhr) {
                    that.inRequest = false;
                    if (this.noProgress) {
                        setTimeout(this.stopProgress, 500);
                    } else {
                        this.stopProgress();
                    }

                    if (xhr.statusText == "abort") {
                        statusIcon.remove();
                    }
                },

                success: function (data) {
                    statusIcon.addClass("k-complete");
                    try {
                        var current = this,
                            loaded = 10;

                        if (current.noProgress) {
                            statusIcon.width(loaded+"%");
                            fakeProgress = setInterval(function () {
                                current.progress({ lengthComputable: true, loaded: Math.min(loaded, 100), total: 100 });
                                loaded += 10;
                            }, 40);
                        }

                        content.html(data);
                    } catch (e) {
                        var console = window.console;

                        if (console && console.error) {
                            console.error(e.name + ": " + e.message + " in " + url);
                        }
                        this.error(this.xhr, "error");
                    }

                    if (complete) {
                        complete.call(that, content);
                    }

                    that.trigger(CONTENTLOAD, { item: element[0], contentElement: content[0] });
                }
            });
        }
    });

    // client-side rendering
    extend(TabStrip, {
        renderItem: function (options) {
            options = extend({ tabStrip: {}, group: {} }, options);

            var empty = templates.empty,
                item = options.item;

            return templates.item(extend(options, {
                image: item.imageUrl ? templates.image : empty,
                sprite: item.spriteCssClass ? templates.sprite : empty,
                itemWrapper: templates.itemWrapper
            }, rendering));
        },

        renderContent: function (options) {
            return templates.content(extend(options, rendering));
        }
    });

    kendo.ui.plugin(TabStrip);

})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.mobile.tabstrip',[ "./kendo.core" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        ui = kendo.mobile.ui,
        Widget = ui.Widget,
        ACTIVE_STATE_CLASS = "km-state-active",
        SELECT = "select";

    function createBadge(value) {
        return $('<span class="km-badge">' + value + '</span>');
    }

    var TabStrip = Widget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);
            that.container().bind("show", $.proxy(this, "refresh"));

            that.element
               .addClass("km-tabstrip")
               .find("a").each(that._buildButton)
               .eq(that.options.selectedIndex).addClass(ACTIVE_STATE_CLASS);

            that.element.on("down", "a", "_release");
        },

        events: [
            SELECT
        ],

        switchTo: function(url) {
            var tabs = this.element.find('a'),
                tab,
                path,
                idx = 0,
                length = tabs.length;

            if(isNaN(url)) {
                for (; idx < length; idx ++) {
                    tab = tabs[idx];
                    path = tab.href.replace(/(\#.+)(\?.+)$/, "$1"); // remove the fragment query string - http://www.foo.com?foo#bar**?baz=qux**

                    if (path.indexOf(url, path.length - url.length) !== -1) {
                        this._setActiveItem($(tab));
                        return true;
                    }
                }
            } else {
                this._setActiveItem(tabs.eq(url));
                return true;
            }

            return false;
        },

        switchByFullUrl: function(url) {
            var tab;

            tab = this.element.find("a[href$='" + url + "']");
            this._setActiveItem(tab);
        },

        clear: function() {
            this.currentItem().removeClass(ACTIVE_STATE_CLASS);
        },

        currentItem: function() {
            return this.element.children("." + ACTIVE_STATE_CLASS);
        },

        badge: function(item, value) {
            var tabstrip = this.element, badge;

            if (!isNaN(item)) {
                item = tabstrip.children().get(item);
            }

            item = tabstrip.find(item);
            badge = $(item.find(".km-badge")[0] || createBadge(value).insertAfter(item.children(".km-icon")));

            if (value || value === 0) {
                badge.html(value);
                return this;
            }

            if (value === false) {
                badge.empty().remove();
                return this;
            }

            return badge.html();
        },

        _release: function(e) {
            if (e.which > 1) {
                return;
            }

            var that = this,
                item = $(e.currentTarget);

            if (item[0] === that.currentItem()[0]) {
                return;
            }

            if (that.trigger(SELECT, {item: item})) {
                e.preventDefault();
            } else {
                that._setActiveItem(item);
            }
        },

        _setActiveItem: function(item) {
            if (!item[0]) {
                return;
            }
            this.clear();
            item.addClass(ACTIVE_STATE_CLASS);
        },

        _buildButton: function() {
            var button = $(this),
                icon = kendo.attrValue(button, "icon"),
                badge = kendo.attrValue(button, "badge"),
                image = button.find("img"),
                iconSpan = $('<span class="km-icon"/>');

            button
                .addClass("km-button")
                .attr(kendo.attr("role"), "tab")
                    .contents().not(image)
                    .wrapAll('<span class="km-text"/>');

            if (image[0]) {
                image.addClass("km-image").prependTo(button);
            } else {
                button.prepend(iconSpan);
                if (icon) {
                    iconSpan.addClass("km-" + icon);
                    if (badge || badge === 0) {
                        createBadge(badge).insertAfter(iconSpan);
                    }
                }
            }
        },

        refresh: function(e) {
            var url = e.view.element.attr(kendo.attr("url"));
            if (!this.switchTo(e.view.id) && url) {
                this.switchTo(url);
            }
        },

        options: {
            name: "TabStrip",
            selectedIndex: 0,
            enable: true
        }
    });

    ui.plugin(TabStrip);
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/* Modernizr 2.8.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-inputtypes-touch-addtest-prefixed-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes
 */
;


define('vendor/Modernizr',[], function() {
    var Modernizr = (function( window, document, undefined ) {

        var version = '2.8.2',

        Modernizr = {},


        docElement = document.documentElement,

        mod = 'modernizr',
        modElem = document.createElement(mod),
        mStyle = modElem.style,

        inputElem  = document.createElement('input')  ,

        smile = ':)',

        toString = {}.toString,

        prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),



        omPrefixes = 'Webkit Moz O ms',

        cssomPrefixes = omPrefixes.split(' '),

        domPrefixes = omPrefixes.toLowerCase().split(' '),


        tests = {},
        inputs = {},
        attrs = {},

        classes = [],

        slice = classes.slice,

        featureName, 


        injectElementWithStyles = function( rule, callback, nodes, testnames ) {

          var style, ret, node, docOverflow,
              div = document.createElement('div'),
                    body = document.body,
                    fakeBody = body || document.createElement('body');

          if ( parseInt(nodes, 10) ) {
                          while ( nodes-- ) {
                  node = document.createElement('div');
                  node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
                  div.appendChild(node);
              }
          }

                    style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
          div.id = mod;
              (body ? div : fakeBody).innerHTML += style;
          fakeBody.appendChild(div);
          if ( !body ) {
                    fakeBody.style.background = '';
                    fakeBody.style.overflow = 'hidden';
              docOverflow = docElement.style.overflow;
              docElement.style.overflow = 'hidden';
              docElement.appendChild(fakeBody);
          }

          ret = callback(div, rule);
            if ( !body ) {
              fakeBody.parentNode.removeChild(fakeBody);
              docElement.style.overflow = docOverflow;
          } else {
              div.parentNode.removeChild(div);
          }

          return !!ret;

        },



        isEventSupported = (function() {

          var TAGNAMES = {
            'select': 'input', 'change': 'input',
            'submit': 'form', 'reset': 'form',
            'error': 'img', 'load': 'img', 'abort': 'img'
          };

          function isEventSupported( eventName, element ) {

            element = element || document.createElement(TAGNAMES[eventName] || 'div');
            eventName = 'on' + eventName;

                var isSupported = eventName in element;

            if ( !isSupported ) {
                    if ( !element.setAttribute ) {
                element = document.createElement('div');
              }
              if ( element.setAttribute && element.removeAttribute ) {
                element.setAttribute(eventName, '');
                isSupported = is(element[eventName], 'function');

                        if ( !is(element[eventName], 'undefined') ) {
                  element[eventName] = undefined;
                }
                element.removeAttribute(eventName);
              }
            }

            element = null;
            return isSupported;
          }
          return isEventSupported;
        })(),


        _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

        if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
          hasOwnProp = function (object, property) {
            return _hasOwnProperty.call(object, property);
          };
        }
        else {
          hasOwnProp = function (object, property) { 
            return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
          };
        }


        if (!Function.prototype.bind) {
          Function.prototype.bind = function bind(that) {

            var target = this;

            if (typeof target != "function") {
                throw new TypeError();
            }

            var args = slice.call(arguments, 1),
                bound = function () {

                if (this instanceof bound) {

                  var F = function(){};
                  F.prototype = target.prototype;
                  var self = new F();

                  var result = target.apply(
                      self,
                      args.concat(slice.call(arguments))
                  );
                  if (Object(result) === result) {
                      return result;
                  }
                  return self;

                } else {

                  return target.apply(
                      that,
                      args.concat(slice.call(arguments))
                  );

                }

            };

            return bound;
          };
        }

        function setCss( str ) {
            mStyle.cssText = str;
        }

        function setCssAll( str1, str2 ) {
            return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
        }

        function is( obj, type ) {
            return typeof obj === type;
        }

        function contains( str, substr ) {
            return !!~('' + str).indexOf(substr);
        }

        function testProps( props, prefixed ) {
            for ( var i in props ) {
                var prop = props[i];
                if ( !contains(prop, "-") && mStyle[prop] !== undefined ) {
                    return prefixed == 'pfx' ? prop : true;
                }
            }
            return false;
        }

        function testDOMProps( props, obj, elem ) {
            for ( var i in props ) {
                var item = obj[props[i]];
                if ( item !== undefined) {

                                if (elem === false) return props[i];

                                if (is(item, 'function')){
                                    return item.bind(elem || obj);
                    }

                                return item;
                }
            }
            return false;
        }

        function testPropsAll( prop, prefixed, elem ) {

            var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
                props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

                if(is(prefixed, "string") || is(prefixed, "undefined")) {
              return testProps(props, prefixed);

                } else {
              props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
              return testDOMProps(props, prefixed, elem);
            }
        }    tests['touch'] = function() {
            var bool;

            if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
              bool = true;
            } else {
              injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
                bool = node.offsetTop === 9;
              });
            }

            return bool;
        };
        function webforms() {
                                Modernizr['inputtypes'] = (function(props) {

                for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++ ) {

                    inputElem.setAttribute('type', inputElemType = props[i]);
                    bool = inputElem.type !== 'text';

                                                        if ( bool ) {

                        inputElem.value         = smile;
                        inputElem.style.cssText = 'position:absolute;visibility:hidden;';

                        if ( /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ) {

                          docElement.appendChild(inputElem);
                          defaultView = document.defaultView;

                                            bool =  defaultView.getComputedStyle &&
                                  defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
                                                                                      (inputElem.offsetHeight !== 0);

                          docElement.removeChild(inputElem);

                        } else if ( /^(search|tel)$/.test(inputElemType) ){
                                                                                        } else if ( /^(url|email)$/.test(inputElemType) ) {
                                            bool = inputElem.checkValidity && inputElem.checkValidity() === false;

                        } else {
                                            bool = inputElem.value != smile;
                        }
                    }

                    inputs[ props[i] ] = !!bool;
                }
                return inputs;
            })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
            }
        for ( var feature in tests ) {
            if ( hasOwnProp(tests, feature) ) {
                                        featureName  = feature.toLowerCase();
                Modernizr[featureName] = tests[feature]();

                classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
            }
        }

        Modernizr.input || webforms();


         Modernizr.addTest = function ( feature, test ) {
           if ( typeof feature == 'object' ) {
             for ( var key in feature ) {
               if ( hasOwnProp( feature, key ) ) {
                 Modernizr.addTest( key, feature[ key ] );
               }
             }
           } else {

             feature = feature.toLowerCase();

             if ( Modernizr[feature] !== undefined ) {
                                                  return Modernizr;
             }

             test = typeof test == 'function' ? test() : test;

             if (typeof enableClasses !== "undefined" && enableClasses) {
               docElement.className += ' ' + (test ? '' : 'no-') + feature;
             }
             Modernizr[feature] = test;

           }

           return Modernizr; 
         };


        setCss('');
        modElem = inputElem = null;


        Modernizr._version      = version;

        Modernizr._prefixes     = prefixes;
        Modernizr._domPrefixes  = domPrefixes;
        Modernizr._cssomPrefixes  = cssomPrefixes;


        Modernizr.hasEvent      = isEventSupported;

        Modernizr.testProp      = function(prop){
            return testProps([prop]);
        };

        Modernizr.testAllProps  = testPropsAll;


        Modernizr.testStyles    = injectElementWithStyles;
        Modernizr.prefixed      = function(prop, obj, elem){
          if(!obj) {
            return testPropsAll(prop, 'pfx');
          } else {
                return testPropsAll(prop, obj, elem);
          }
        };



        return Modernizr;

    })(this, this.document);
    ;

    return Modernizr;
});
    
define('helpers/tabbeddashboard',[
    "core/dashboard",
    "generated/templates",
    "utils/browserutils",
    "kendo/kendo.tabstrip",
    "kendo/kendo.mobile.tabstrip",
    "vendor/Modernizr"
], function (Dashboard, JST, browserUtils, KTabStrip, KMobileTabStrip, Modernizr) {
  function TabbedDashboard() {
    Dashboard.call(this);

    var self = this,
        base = {},
        Public = {},
        raw = self._raw,
        title = "",
        Protected,
        pro = self.pro,
        _bp = {};

    Public = {
      setTabbedDashboardTitle: function(TabbedDashboardTitle) {
        title = TabbedDashboardTitle;
      },

      addDashboardTab: function(db, options) {
        var dbID = db.pro.getID(),
            newDB = null;
        options = options ? options : {};
        db.pro.isTabbed = true;
        if (!pro.dbList.hasOwnProperty(dbID)) {
          pro.dbList[dbID] = db;
          pro.dbList[dbID].active = options.active ? true : false;
          pro.dbList[dbID].title = options.title ? options.title : pro.dbList[dbID].pro.getDashboardTitle();
          pro.dbList[dbID].closable = options.closable ? true : false;
          pro.dbList[dbID].highlightOnActivity = options.highlightOnActivity ? true : false;
        }
      },

      renderTo: function($dbDiv) {
        preRender($dbDiv);
        renderShell();
        renderCore();
        pro.addServerLogButtonListener();
      },

      embedTo: function($dbDiv) {
        preRender($("#"+$dbDiv));
        pro.setEmbeddedWidthHeight();
        renderShell();
        renderCore();
        pro.addServerLogButtonListener();
      }

    };

    Protected = {

      dbList: {},

      tabObj: null,

      previousSelectedTab: null,

      $containerDiv: null,
      $activeDashboardDiv: null,
      $tabDiv: null,
      currentDashboard: null,
      $activeTab: null,
      currentDashboardKey: null,

      managedBind: function (jqDiv, eventName, callback) {
        jqDiv.bind(eventName, callback);
      },

      dispose: function () {
        pro.tabObj.destroy();
      }

    };

    var renderShell = function() {
      // Find the corediv
      pro.$containerDiv.html(JST.tabbeddashboard_standalone({
        title: title,
        mobile: Modernizr.touch
      }));
      pro.$tabDiv = pro.$containerDiv.find('#rfTabCore');
      pro.$serverLogButton = pro.$containerDiv.find(".rfServerLogButton");
    };

    var renderCore = function() {
      var data = [],
            firstDB = null,
            activeTab = null,
            key = null;
      if (!Modernizr.touch) {
        for (key in pro.dbList) {
          if(pro.dbList.hasOwnProperty(key)) {
            if (firstDB === null) {
              firstDB = key;
            }
            if (pro.dbList[key].active && activeTab === null) {
              activeTab = key;
            }
            $(".tabLinks").append('<li data-id="'+key+'">'+pro.dbList[key].title+'</li>');
            $("#rfTabCore").append("<div data-id='"+key+"'></div>");
          }
        }
        if (activeTab === null) {
          activeTab = firstDB;
        }
        pro.tabObj = $("#rfTabCore").kendoTabStrip({
          activate: onActivate,
          animation: {
            close: {
                duration: 100,
                effects: "fadeOut"
            },
            open: {
                duration: 100,
                effects: "fadeIn"
            }
          }
        }).data("kendoTabStrip");
        var tabToActivate = $("li[data-id='"+activeTab+"']");
        pro.tabObj.activateTab(tabToActivate);
      } else {
        for (key in pro.dbList) {
          if(pro.dbList.hasOwnProperty(key)) {
            if (firstDB === null) {
              firstDB = key;
            }
            if (pro.dbList[key].active && activeTab === null) {
              activeTab = key;
            }
            $("#mobile-tabstrip").append('<a href="#' + key + '" data-id="' + key + '">' + pro.dbList[key].title + '</a>');
            $("#content-container").append('<div id="' + key + '" style="display:none"></div>');
          }
        }

        if (activeTab === null) {
          activeTab = firstDB;
        }
        pro.tabObj = $("#mobile-tabstrip").kendoMobileTabStrip({
          select: onSelect
        }).data("kendoMobileTabStrip").switchTo("#" + activeTab);

        $("#" + activeTab).show();
        pro.dbList[activeTab].embedTo(activeTab);
        
      }
    };

    var onActivate = function (e) {
      var key = e.contentElement.id,
          dataset = e.contentElement.getAttribute("data-id");
      if(pro.previousSelectedTab !== null) {
        pro.dbList[pro.previousSelectedTab].pro.dispose();
      }
      if($("#" + key).text().length === 0) {
        pro.dbList[dataset].embedTo(key);
      } else {
        pro.dbList[dataset].pro.setResizeWatcher();
      }
      pro.previousSelectedTab = dataset;
    };

    var onSelect = function (e) {
      var key = e.item.data().id;
      hideAll();
      $("#" + key).show();
      if($("#" + key).text().length === 0) {
        pro.dbList[key].embedTo(key);
      }
    };

    var hideAll = function () {
      $("#content-container > div").hide();
    };

    var preRender = function($dbDiv) {
      pro.$containerDiv = $dbDiv;
      pro.$containerDiv.css({
        'margin': '0 auto'
      });
      if(!browserUtils.isBrowserSupported()) {
        pro.$containerDiv.html(JST.browser_error({}));
        return;
      }
    };

    raw._registerClassName("TabbedDashboard");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

  }
  return TabbedDashboard;
});

define('helpers/standalonedashboard',['core/dashboard',
        'helpers/tabbeddashboard'
        ], function (Dashboard, TabbedDashboard) {
  function StandaloneDashboard(callback, options) {
    options = options ? options : {};
    $(function() {
        db = options.tabbed ? new TabbedDashboard() : new Dashboard();
        callback(db);
        // This is a hack TODO: remove this
        if(!window.__disableSimpleDashboards) {
            db.renderTo($("#dbTarget"));
        }
    });
  }
  return StandaloneDashboard;
});

define('helpers/embeddeddashboard',['core/dashboard'], function (Dashboard) {
	var StandaloneDashboard = Dashboard;
	// For now we can have a standalone dashboard as just a dashboard
	return StandaloneDashboard;
});

/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.popup',[ "./kendo.core" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        ui = kendo.ui,
        Widget = ui.Widget,
        support = kendo.support,
        getOffset = kendo.getOffset,
        activeElement = kendo._activeElement,
        OPEN = "open",
        CLOSE = "close",
        DEACTIVATE = "deactivate",
        ACTIVATE = "activate",
        CENTER = "center",
        LEFT = "left",
        RIGHT = "right",
        TOP = "top",
        BOTTOM = "bottom",
        ABSOLUTE = "absolute",
        HIDDEN = "hidden",
        BODY = "body",
        LOCATION = "location",
        POSITION = "position",
        VISIBLE = "visible",
        EFFECTS = "effects",
        ACTIVE = "k-state-active",
        ACTIVEBORDER = "k-state-border",
        ACTIVEBORDERREGEXP = /k-state-border-(\w+)/,
        ACTIVECHILDREN = ".k-picker-wrap, .k-dropdown-wrap, .k-link",
        MOUSEDOWN = "down",
        WINDOW = $(window),
        DOCUMENT_ELEMENT = $(document.documentElement),
        RESIZE_SCROLL = "resize scroll",
        cssPrefix = support.transitions.css,
        TRANSFORM = cssPrefix + "transform",
        extend = $.extend,
        NS = ".kendoPopup",
        styles = ["font-size",
                  "font-family",
                  "font-stretch",
                  "font-style",
                  "font-weight",
                  "line-height"];

    function contains(container, target) {
        return container === target || $.contains(container, target);
    }

    var Popup = Widget.extend({
        init: function(element, options) {
            var that = this, parentPopup;

            options = options || {};

            if (options.isRtl) {
                options.origin = options.origin || BOTTOM + " " + RIGHT;
                options.position = options.position || TOP + " " + RIGHT;
            }

            Widget.fn.init.call(that, element, options);

            element = that.element;
            options = that.options;

            that.collisions = options.collision ? options.collision.split(" ") : [];

            if (that.collisions.length === 1) {
                that.collisions.push(that.collisions[0]);
            }

            parentPopup = $(that.options.anchor).closest(".k-popup,.k-group").filter(":not([class^=km-])"); // When popup is in another popup, make it relative.
            options.appendTo = $($(options.appendTo)[0] || parentPopup[0] || BODY);

            that.element.hide()
                .addClass("k-popup k-group k-reset")
                .toggleClass("k-rtl", !!options.isRtl)
                .css({ position : ABSOLUTE })
                .appendTo(options.appendTo)
                .on("mouseenter" + NS, function() {
                    that._hovered = true;
                })
                .on("mouseleave" + NS, function() {
                    that._hovered = false;
                });

            that.wrapper = $();

            if (options.animation === false) {
                options.animation = { open: { effects: {} }, close: { hide: true, effects: {} } };
            }

            extend(options.animation.open, {
                complete: function() {
                    that.wrapper.css({ overflow: VISIBLE }); // Forcing refresh causes flickering in mobile.
                    that.trigger(ACTIVATE);
                }
            });

            extend(options.animation.close, {
                complete: function() {
                    that.wrapper.hide();

                    var location = that.wrapper.data(LOCATION),
                        anchor = $(options.anchor),
                        direction, dirClass;

                    if (location) {
                        that.wrapper.css(location);
                    }

                    if (options.anchor != BODY) {
                        direction = (anchor[0].className.match(ACTIVEBORDERREGEXP) || ["", "down"])[1];
                        dirClass = ACTIVEBORDER + "-" + direction;

                        anchor
                            .removeClass(dirClass)
                            .children(ACTIVECHILDREN)
                            .removeClass(ACTIVE)
                            .removeClass(dirClass);

                        element.removeClass(ACTIVEBORDER + "-" + kendo.directions[direction].reverse);
                    }

                    that._closing = false;
                    that.trigger(DEACTIVATE);
                }
            });

            that._mousedownProxy = function(e) {
                that._mousedown(e);
            };

            that._resizeProxy = function(e) {
                that._resize(e);
            };

            if (options.toggleTarget) {
                $(options.toggleTarget).on(options.toggleEvent + NS, $.proxy(that.toggle, that));
            }
        },

        events: [
            OPEN,
            ACTIVATE,
            CLOSE,
            DEACTIVATE
        ],

        options: {
            name: "Popup",
            toggleEvent: "click",
            origin: BOTTOM + " " + LEFT,
            position: TOP + " " + LEFT,
            anchor: BODY,
            collision: "flip fit",
            viewport: window,
            copyAnchorStyles: true,
            autosize: false,
            modal: false,
            animation: {
                open: {
                    effects: "slideIn:down",
                    transition: true,
                    duration: 200
                },
                close: { // if close animation effects are defined, they will be used instead of open.reverse
                    duration: 100,
                    hide: true
                }
            }
        },

        destroy: function() {
            var that = this,
                options = that.options,
                element = that.element.off(NS),
                parent;

            Widget.fn.destroy.call(that);

            if (options.toggleTarget) {
                $(options.toggleTarget).off(NS);
            }

            if (!options.modal) {
                DOCUMENT_ELEMENT.unbind(MOUSEDOWN, that._mousedownProxy);
                WINDOW.unbind(RESIZE_SCROLL, that._resizeProxy);
            }

            kendo.destroy(that.element.children());
            element.removeData();

            if (options.appendTo[0] === document.body) {
                parent = element.parent(".k-animation-container");

                if (parent[0]) {
                    parent.remove();
                } else {
                    element.remove();
                }
            }
        },

        open: function(x, y) {
            var that = this,
                fixed = { isFixed: !isNaN(parseInt(y,10)), x: x, y: y },
                element = that.element,
                options = that.options,
                direction = "down",
                animation, wrapper,
                anchor = $(options.anchor),
                mobile = element[0] && element.hasClass("km-widget");

            if (!that.visible()) {
                if (options.copyAnchorStyles) {
                    if (mobile && styles[0] == "font-size") {
                        styles.shift();
                    }
                    element.css(kendo.getComputedStyles(anchor[0], styles));
                }

                if (element.data("animating") || that.trigger(OPEN)) {
                    return;
                }

                if (!options.modal) {
                    DOCUMENT_ELEMENT.unbind(MOUSEDOWN, that._mousedownProxy)
                                .bind(MOUSEDOWN, that._mousedownProxy);

                    // this binding hangs iOS in editor
                    if (!(support.mobileOS.ios || support.mobileOS.android)) {
                        WINDOW.unbind(RESIZE_SCROLL, that._resizeProxy)
                              .bind(RESIZE_SCROLL, that._resizeProxy);
                    }
                }

                that.wrapper = wrapper = kendo.wrap(element, options.autosize)
                                        .css({
                                            overflow: HIDDEN,
                                            display: "block",
                                            position: ABSOLUTE
                                        });

                if (support.mobileOS.android) {
                    wrapper.add(anchor).css(TRANSFORM, "translatez(0)"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.
                }

                wrapper.css(POSITION);

                if ($(options.appendTo)[0] == document.body) {
                    wrapper.css(TOP, "-10000px");
                }

                animation = extend(true, {}, options.animation.open);
                that.flipped = that._position(fixed);
                animation.effects = kendo.parseEffects(animation.effects, that.flipped);

                direction = animation.effects.slideIn ? animation.effects.slideIn.direction : direction;

                if (options.anchor != BODY) {
                    var dirClass = ACTIVEBORDER + "-" + direction;

                    element.addClass(ACTIVEBORDER + "-" + kendo.directions[direction].reverse);

                    anchor
                        .addClass(dirClass)
                        .children(ACTIVECHILDREN)
                        .addClass(ACTIVE)
                        .addClass(dirClass);
                }

                element.data(EFFECTS, animation.effects)
                       .kendoStop(true)
                       .kendoAnimate(animation);
            }
        },

        toggle: function() {
            var that = this;

            that[that.visible() ? CLOSE : OPEN]();
        },

        visible: function() {
            return this.element.is(":" + VISIBLE);
        },

        close: function() {
            var that = this,
                options = that.options, wrap,
                animation, openEffects, closeEffects;

            if (that.visible()) {
                wrap = (that.wrapper[0] ? that.wrapper : kendo.wrap(that.element).hide());

                if (that._closing || that.trigger(CLOSE)) {
                    return;
                }

                // Close all inclusive popups.
                that.element.find(".k-popup").each(function () {
                    var that = $(this),
                        popup = that.data("kendoPopup");

                    if (popup) {
                        popup.close();
                    }
                });

                DOCUMENT_ELEMENT.unbind(MOUSEDOWN, that._mousedownProxy);
                WINDOW.unbind(RESIZE_SCROLL, that._resizeProxy);

                animation = extend(true, {}, options.animation.close);
                openEffects = that.element.data(EFFECTS);
                closeEffects = animation.effects;

                if (!closeEffects && !kendo.size(closeEffects) && openEffects && kendo.size(openEffects)) {
                    animation.effects = openEffects;
                    animation.reverse = true;
                }

                that._closing = true;

                that.element.kendoStop(true);
                wrap.css({ overflow: HIDDEN }); // stop callback will remove hidden overflow
                that.element.kendoAnimate(animation);
            }
        },

        _resize: function(e) {
            var that = this;

            if (e.type === "resize") {
                clearTimeout(that._resizeTimeout);
                that._resizeTimeout = setTimeout(function() {
                    that._position();
                    that._resizeTimeout = null;
                }, 50);
            } else {
                if (!that._hovered && !contains(that.element[0], activeElement())) {
                    that.close();
                }
            }
        },

        _mousedown: function(e) {
            var that = this,
                container = that.element[0],
                options = that.options,
                anchor = $(options.anchor)[0],
                toggleTarget = options.toggleTarget,
                target = kendo.eventTarget(e),
                popup = $(target).closest(".k-popup"),
                mobile = popup.parent().parent(".km-shim").length;

            popup = popup[0];
            if (!mobile && popup && popup !== that.element[0]){
                return;
            }

            // This MAY result in popup not closing in certain cases.
            if ($(e.target).closest("a").data("rel") === "popover") {
                return;
            }

            if (!contains(container, target) && !contains(anchor, target) && !(toggleTarget && contains($(toggleTarget)[0], target))) {
                that.close();
            }
        },

        _fit: function(position, size, viewPortSize) {
            var output = 0;

            if (position + size > viewPortSize) {
                output = viewPortSize - (position + size);
            }

            if (position < 0) {
                output = -position;
            }

            return output;
        },

        _flip: function(offset, size, anchorSize, viewPortSize, origin, position, boxSize) {
            var output = 0;
                boxSize = boxSize || size;

            if (position !== origin && position !== CENTER && origin !== CENTER) {
                if (offset + boxSize > viewPortSize) {
                    output += -(anchorSize + size);
                }

                if (offset + output < 0) {
                    output += anchorSize + size;
                }
            }
            return output;
        },

        _position: function(fixed) {
            var that = this,
                element = that.element.css(POSITION, ""),
                wrapper = that.wrapper,
                options = that.options,
                viewport = $(options.viewport),
                viewportOffset = viewport.offset(),
                anchor = $(options.anchor),
                origins = options.origin.toLowerCase().split(" "),
                positions = options.position.toLowerCase().split(" "),
                collisions = that.collisions,
                zoomLevel = support.zoomLevel(),
                siblingContainer, parents,
                parentZIndex, zIndex = 10002,
                isWindow = !!((viewport[0] == window) && window.innerWidth && (zoomLevel <= 1.02)),
                idx = 0, length, viewportWidth, viewportHeight;

            // $(window).height() uses documentElement to get the height
            viewportWidth = isWindow ? window.innerWidth : viewport.width();
            viewportHeight = isWindow ? window.innerHeight : viewport.height();

            siblingContainer = anchor.parents().filter(wrapper.siblings());

            if (siblingContainer[0]) {
                parentZIndex = Number($(siblingContainer).css("zIndex"));
                if (parentZIndex) {
                    zIndex = parentZIndex + 1;
                } else {
                    parents = anchor.parentsUntil(siblingContainer);
                    for (length = parents.length; idx < length; idx++) {
                        parentZIndex = Number($(parents[idx]).css("zIndex"));
                        if (parentZIndex && zIndex < parentZIndex) {
                            zIndex = parentZIndex + 1;
                        }
                    }
                }
            }

            wrapper.css("zIndex", zIndex);

            if (fixed && fixed.isFixed) {
                wrapper.css({ left: fixed.x, top: fixed.y });
            } else {
                wrapper.css(that._align(origins, positions));
            }

            var pos = getOffset(wrapper, POSITION, anchor[0] === wrapper.offsetParent()[0]),
                offset = getOffset(wrapper),
                anchorParent = anchor.offsetParent().parent(".k-animation-container,.k-popup,.k-group"); // If the parent is positioned, get the current positions

            if (anchorParent.length) {
                pos = getOffset(wrapper, POSITION, true);
                offset = getOffset(wrapper);
            }

            if (viewport[0] === window) {
                offset.top -= (window.pageYOffset || document.documentElement.scrollTop || 0);
                offset.left -= (window.pageXOffset || document.documentElement.scrollLeft || 0);
            }
            else {
                offset.top -= viewportOffset.top;
                offset.left -= viewportOffset.left;
            }

            if (!that.wrapper.data(LOCATION)) { // Needed to reset the popup location after every closure - fixes the resize bugs.
                wrapper.data(LOCATION, extend({}, pos));
            }

            var offsets = extend({}, offset),
                location = extend({}, pos);

            if (collisions[0] === "fit") {
                location.top += that._fit(offsets.top, wrapper.outerHeight(), viewportHeight / zoomLevel);
            }

            if (collisions[1] === "fit") {
                location.left += that._fit(offsets.left, wrapper.outerWidth(), viewportWidth / zoomLevel);
            }

            var flipPos = extend({}, location);

            if (collisions[0] === "flip") {
                location.top += that._flip(offsets.top, element.outerHeight(), anchor.outerHeight(), viewportHeight / zoomLevel, origins[0], positions[0], wrapper.outerHeight());
            }

            if (collisions[1] === "flip") {
                location.left += that._flip(offsets.left, element.outerWidth(), anchor.outerWidth(), viewportWidth / zoomLevel, origins[1], positions[1], wrapper.outerWidth());
            }

            element.css(POSITION, ABSOLUTE);
            wrapper.css(location);

            return (location.left != flipPos.left || location.top != flipPos.top);
        },

        _align: function(origin, position) {
            var that = this,
                element = that.wrapper,
                anchor = $(that.options.anchor),
                verticalOrigin = origin[0],
                horizontalOrigin = origin[1],
                verticalPosition = position[0],
                horizontalPosition = position[1],
                anchorOffset = getOffset(anchor),
                appendTo = $(that.options.appendTo),
                appendToOffset,
                width = element.outerWidth(),
                height = element.outerHeight(),
                anchorWidth = anchor.outerWidth(),
                anchorHeight = anchor.outerHeight(),
                top = anchorOffset.top,
                left = anchorOffset.left,
                round = Math.round;

            if (appendTo[0] != document.body) {
                appendToOffset = getOffset(appendTo);
                top -= appendToOffset.top;
                left -= appendToOffset.left;
            }


            if (verticalOrigin === BOTTOM) {
                top += anchorHeight;
            }

            if (verticalOrigin === CENTER) {
                top += round(anchorHeight / 2);
            }

            if (verticalPosition === BOTTOM) {
                top -= height;
            }

            if (verticalPosition === CENTER) {
                top -= round(height / 2);
            }

            if (horizontalOrigin === RIGHT) {
                left += anchorWidth;
            }

            if (horizontalOrigin === CENTER) {
                left += round(anchorWidth / 2);
            }

            if (horizontalPosition === RIGHT) {
                left -= width;
            }

            if (horizontalPosition === CENTER) {
                left -= round(width / 2);
            }

            return {
                top: top,
                left: left
            };
        }
    });

    ui.plugin(Popup);
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.notification',[ "./kendo.core", "./kendo.popup" ], f);
})(function(){

;

(function($, undefined) {
    var kendo = window.kendo,
        Widget = kendo.ui.Widget,
        proxy = $.proxy,
        extend = $.extend,
        setTimeout = window.setTimeout,
        CLICK = "click",
        SHOW = "show",
        HIDE = "hide",
        KNOTIFICATION = "k-notification",
        KICLOSE = ".k-notification-wrap .k-i-close",
        INFO = "info",
        SUCCESS = "success",
        WARNING = "warning",
        ERROR = "error",
        TOP = "top",
        LEFT = "left",
        BOTTOM = "bottom",
        RIGHT = "right",
        UP = "up",
        NS = ".kendoNotification",
        WRAPPER = '<div class="k-widget k-notification"></div>',
        TEMPLATE = '<div class="k-notification-wrap">' +
                '<span class="k-icon k-i-note">#=typeIcon#</span>' +
                '#=content#' +
                '<span class="k-icon k-i-close">Hide</span>' +
            '</div>';

    var Notification = Widget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            options = that.options;

            if (!options.appendTo || !$(options.appendTo).is(element)) {
                that.element.hide();
            }

            that._compileTemplates(options.templates);
            that._guid = "_" + kendo.guid();
            that._isRtl = kendo.support.isRtl(element);
            that._compileStacking(options.stacking, options.position.top);

            kendo.notify(that);
        },

        events: [
            SHOW,
            HIDE
        ],

        options: {
            name: "Notification",
            position: {
                pinned: true,
                top: null,
                left: null,
                bottom: 20,
                right: 20
            },
            stacking: "default",
            hideOnClick: true,
            button: false,
            allowHideAfter: 0,
            autoHideAfter: 5000,
            appendTo: null,
            width: null,
            height: null,
            templates: [],
            animation: {
                open: {
                    effects: "fade:in",
                    duration: 300
                },
                close: {
                    effects: "fade:out",
                    duration: 600,
                    hide: true
                }
            },
            handleClick: null
        },

        _compileTemplates: function(templates) {
            var that = this;
            var kendoTemplate = kendo.template;
            
            that._compiled = {};

            $.each(templates, function(key, value) {
                that._compiled[value.type] = kendoTemplate(value.template || $("#" + value.templateId).html());
            });

            that._defaultCompiled = kendoTemplate(TEMPLATE);
        },

        _getCompiled: function(type) {
            var that = this;
            var defaultCompiled = that._defaultCompiled;

            return type ? that._compiled[type] || defaultCompiled : defaultCompiled;
        },

        _compileStacking: function(stacking, top) {
            var that = this,
                paddings = { paddingTop: 0, paddingRight: 0, paddingBottom: 0, paddingLeft: 0 },
                origin, position;

            switch (stacking) {
                case "down":
                    origin = BOTTOM + " " + LEFT;
                    position = TOP + " " + LEFT;
                    delete paddings.paddingBottom;
                break;
                case RIGHT:
                    origin = TOP + " " + RIGHT;
                    position = TOP + " " + LEFT;
                    delete paddings.paddingRight;
                break;
                case LEFT:
                    origin = TOP + " " + LEFT;
                    position = TOP + " " + RIGHT;
                    delete paddings.paddingLeft;
                break;
                case UP:
                    origin = TOP + " " + LEFT;
                    position = BOTTOM + " " + LEFT;
                    delete paddings.paddingTop;
                break;
                default:
                    if (top !== null) {
                        origin = BOTTOM + " " + LEFT;
                        position = TOP + " " + LEFT;
                        delete paddings.paddingBottom;
                    } else {
                        origin = TOP + " " + LEFT;
                        position = BOTTOM + " " + LEFT;
                        delete paddings.paddingTop;
                    }
                break;
            }

            that._popupOrigin = origin;
            that._popupPosition = position;
            that._popupPaddings = paddings;
        },

        _attachPopupEvents: function(options, popup) {
            var that = this,
                allowHideAfter = options.allowHideAfter,
                attachDelay = !isNaN(allowHideAfter) && allowHideAfter > 0,
                closeIcon;

            function attachClick(target) {
                target.on(CLICK + NS, function() {
                    if(options.handleClick) {
                        options.handleClick();
                    }
                    else{
                        popup.close();
                    }
                });
            }

            if(options.handleClick) {
                popup.bind("activate", function(e) {
                    attachClick(popup.element);
                });
            }

            if (options.hideOnClick) {
                popup.bind("activate", function(e) {
                    if (attachDelay) {
                        setTimeout(function(){
                            attachClick(popup.element);
                        }, allowHideAfter);
                    } else {
                        attachClick(popup.element);
                    }
                });
            } else if (options.button) {
                closeIcon = popup.element.find(KICLOSE);
                if (attachDelay) {
                    setTimeout(function(){
                        attachClick(closeIcon);
                    }, allowHideAfter);
                } else {
                    attachClick(closeIcon);
                }
            }
        },

        _showPopup: function(wrapper, options) {
            var that = this,
                autoHideAfter = options.autoHideAfter,
                x = options.position.left,
                y = options.position.top,
                allowHideAfter = options.allowHideAfter,
                popup, openPopup, attachClick, closeIcon;
            
            openPopup = $("." + that._guid).last();

            popup = new kendo.ui.Popup(wrapper, {
                anchor: openPopup[0] ? openPopup : document.body,
                origin: that._popupOrigin,
                position: that._popupPosition,
                animation: options.animation,
                modal: true,
                collision: "",
                isRtl: that._isRtl,
                close: function(e) {
                    that.trigger(HIDE, {element: this.element});
                },
                deactivate: function(e) {
                    e.sender.element.off(NS);
                    e.sender.element.find(KICLOSE).off(NS);
                    e.sender.destroy();
                }
            });

            that._attachPopupEvents(options, popup);

            if (openPopup[0]) {
                popup.open();
            } else {
                if (x === null) {
                    x = $(window).width() - wrapper.width() - options.position.right;
                }

                if (y === null) {
                    y = $(window).height() - wrapper.height() - options.position.bottom;
                }

                popup.open(x, y);
            }

            popup.wrapper.addClass(that._guid).css(extend({margin:0}, that._popupPaddings));

            if (options.position.pinned) {
                popup.wrapper.css("position", "fixed");
                if (openPopup[0]) {
                    that._togglePin(popup.wrapper, true);
                }
            } else if (!openPopup[0]) {
                that._togglePin(popup.wrapper, false);
            }

            if (autoHideAfter > 0) {
                setTimeout(function(){
                    popup.close();
                }, autoHideAfter);
            }
        },

        _togglePin: function(wrapper, pin) {
            var win = $(window),
                sign = pin ? -1 : 1;

            wrapper.css({
                top: parseInt(wrapper.css(TOP), 10) + sign * win.scrollTop(),
                left: parseInt(wrapper.css(LEFT), 10) + sign * win.scrollLeft()
            });
        },

        _attachStaticEvents: function(options, wrapper) {
            var that = this,
                allowHideAfter = options.allowHideAfter,
                attachDelay = !isNaN(allowHideAfter) && allowHideAfter > 0;

            function attachClick(target) {
                target.on(CLICK + NS, proxy(that._hideStatic, that, wrapper));
            }

            if (options.hideOnClick) {
                if (attachDelay) {
                    setTimeout(function(){
                        attachClick(wrapper);
                    }, allowHideAfter);
                } else {
                    attachClick(wrapper);
                }
            } else if (options.button) {
                if (attachDelay) {
                    setTimeout(function(){
                        attachClick(wrapper.find(KICLOSE));
                    }, allowHideAfter);
                } else {
                    attachClick(wrapper.find(KICLOSE));
                }
            }
        },

        _showStatic: function(wrapper, options) {
            var that = this,
                autoHideAfter = options.autoHideAfter,
                animation = options.animation,
                insertionMethod = options.stacking == UP || options.stacking == LEFT ? "prependTo" : "appendTo",
                attachClick;

            wrapper
                .addClass(that._guid)
                [insertionMethod](options.appendTo)
                .hide()
                .kendoAnimate(animation.open);

            that._attachStaticEvents(options, wrapper);

            if (autoHideAfter > 0) {
                setTimeout(function(){
                    that._hideStatic(wrapper);
                }, autoHideAfter);
            }
        },

        _hideStatic: function(wrapper) {
            wrapper.kendoAnimate(extend(this.options.animation.close, { complete: function() {
                wrapper.off(NS).find(KICLOSE).off(NS);
                wrapper.remove();
            }}));
            this.trigger(HIDE, {element: wrapper});
        },

        show: function(content, type) {
            var that = this,
                options = that.options,
                wrapper = $(WRAPPER),
                args, defaultArgs, popup;

            if (!type) {
                type = INFO;
            }

            if (content !== null && content !== undefined && content !== "") {
                
                if (kendo.isFunction(content)) {
                    content = content();
                }

                defaultArgs = {typeIcon: type, content: ""};

                if ($.isPlainObject(content)) {
                    args = extend(defaultArgs, content);
                } else {
                    args = extend(defaultArgs, {content: content});
                }

                wrapper
                    .addClass(KNOTIFICATION + "-" + type)
                    .toggleClass(KNOTIFICATION + "-button", options.button)
                    .attr("data-role", "alert")
                    .css({width: options.width, height: options.height})
                    .append(that._getCompiled(type)(args));
                
                if ($(options.appendTo)[0]) {
                    that._showStatic(wrapper, options);
                } else {
                    that._showPopup(wrapper, options);
                }

                that.trigger(SHOW, {element: wrapper});
            }

            return that;
        },

        info: function(content) {
            return this.show(content, INFO);
        },

        success: function(content) {
            return this.show(content, SUCCESS);
        },

        warning: function(content) {
            return this.show(content, WARNING);
        },

        error: function(content) {
            return this.show(content, ERROR);
        },

        hide: function() {
            var that = this,
                openedNotifications = that.getNotifications();

            if (that.options.appendTo) {
                openedNotifications.each(function(idx, element){
                    that._hideStatic($(element));
                });
            } else {
                openedNotifications.each(function(idx, element){
                    var popup = $(element).data("kendoPopup");
                    if (popup) {
                        popup.close();
                    }
                });
            }

            return that;
        },

        getNotifications: function() {
            var that = this,
                guidElements = $("." + that._guid);
                
            if (that.options.appendTo) {
                return guidElements;
            } else {
                return guidElements.children("." + KNOTIFICATION);
            }
        },

        setOptions: function(newOptions) {
            var that = this,
                options;

            Widget.fn.setOptions.call(that, newOptions);

            options = that.options;

            if (newOptions.templates !== undefined) {
                that._compileTemplates(options.templates);
            }

            if (newOptions.stacking !== undefined || newOptions.position !== undefined) {
                that._compileStacking(options.stacking, options.position.top);
            }
        },

        destroy: function() {
            Widget.fn.destroy.call(this);
            this.getNotifications().off(NS).find(KICLOSE).off(NS);
        }
    });

    kendo.ui.plugin(Notification);

})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
define('utils/rfnotification',["kendo/kendo.notification", "generated/templates"], function(KNotification, JST) {
    var RFNotification = {
        create: function(msg, exception, id, _handleClick) {
            var handleClickFlag = typeof _handleClick === 'undefined' ? true : _handleClick;
            var $notification = $("<div/>").addClass("rfNotification");
            $("body").append($notification);

            var errorTemplate = JST.notification_errors({
                msg: msg
            });

            $notification.append(errorTemplate);
            $notification.kendoNotification({
              allowHideAfter: 2000,
               position: {
                stacking: 'down',
                top: 30,
                right: 30
               },
              handleClick: function() {
                if(handleClickFlag) {
                  rf.logger.showLogs(id);
                }
              }
            }).data('kendoNotification');

            $notification.data('kendoNotification').show(errorTemplate, "error");
        }
    };

    return RFNotification;
});
define('utils/ajaxwrapper',["utils/rfnotification"], function (RFNotification) {
  var AjaxWrapper = function () {

    var self = this;

    self.ajax = function(options) {
      var renderer = options.renderer ? options.renderer : null;
      $.ajax({
        type: options.type ? options.type : 'GET',
        url: options.url,
        data: options.data ? options.data : {},
        success: function(data, status, xhr) {
          options.success(data);

          if(data.logs) {
            var message;
            for(var i=0; i<data.logs.length; i++) {
              message = data.logs[i].message + ' : ' + data.logs[i].log;
              rf.logger.log(message, {
                'source': 'server'
              });
            }

          }

        },
        error: function(xhr, errorType, error) {
          var id = rf.logger.error("There was an error processing your request.", '', {
            source: 'server',
            extraInfo: true,
            infoFormatter: errorFormatter,
            error: { type: errorType, xhr: xhr },
            obj: this
          });

          RFNotification.create(getErrorNotificationMessage(), null, id);
        }
      });
    };

     var errorFormatter = function(item) {
      var response = item.data.error.xhr.responseJSON;
      var $div = $("<div/>");
      $div.append($("<li/>").text(item.data.obj.url));
      $div.append($("<li/>").html("<strong>" + item.data.error.type + "</strong>"));
      if(response && response.errors) {
        $div.append($("<div/>").html("<strong>" + response.errors.error + "</strong>"));
        $div.append($("<div/>").html(response.backtrace));
      }
      else {
        $div.append($("<div/>").html(item.data.error.xhr.responseText));
      }

      return $div;
    };

    var getErrorNotificationMessage = function() {
      var message ;

      if(rf.logger.debugMode) {
        message = 'There was an error processing your request. Click to view.';
      }
      else {
        message = 'There was an error processing your request';
      }

      return message;
    } 

  };

  return AjaxWrapper;
});

define('data/query',['utils/ajaxwrapper'], function (AjaxWrapper) {
  function Query() {
    var self = this,
        ds = null,
        subscribers = [],
        component = null,
        params = {
          sort : {
            column: null,
            order: null
          }
        };

    self.setDataSource = function (d) {
      ds = d;
    };

    self.run = function (callback) {
      self.runAsync(callback);
    };

    self.subscribe = function (callback) {
      subscribers.push(callback);
    };

    self.limit = function (skip, take) {
      params.limit = {
        skip: skip,
        take: take
      };

      return self;
    };

    self.runAndSubscribe = function (callback) {
      self.subscribe(callback);
      self.run(callback);
    };

    self.triggerUpdates = function (_component) {
      component = _component;
      self.runAsync(function (newData) {
        for (var i = 0; i < subscribers.length; i++) {
          subscribers[i](newData);
        }
      });

    };

    self.runAsync = function (callback) {
      if(ds.url === null) {
        var res = self.runSyncArray ();
        callback(res);
      }
      else {
        self.runAsyncURL (callback);
      }
    };

    self.runSyncArray = function () {
      // Get the data.
      var data = ds.getRawData();
      var handleLimit = function () {
        if (typeof(params.limit) === "object") {
          data = data.slice(params.limit.skip, params.limit.skip + params.limit.take);
        }
      };

      handleLimit();
      return data;
    };

    self.runAsyncURL = function (callback) {
      component.lock();
      var rfAjax = new AjaxWrapper();
      rfAjax.ajax({
        type: "POST",
        url: ds.url,
        renderer: component.pro.renderer,
        db: component.pro.db,
        data: {
          params: JSON.stringify(params)
        },
        success: function(data) {
          component.unlock();
          callback(JSON.parse(data.data));
        }
      });
    };

    self.sort = function (column, order) {
      order = order ? order : (params.sort.order === 'DESC' ? 'AESC' : 'DESC');
      params.sort = {
        column: column,
        order: order
      };
      return self;
    };
  }

  return Query;
});

define('data/datasource',[
  "data/query"
], function (Query) {
  function DataSource() {
    var self = this,
        data = [],
        queries = [],
        applyingPatch = false,
        dataError = {
          status: false,
          msg: ""
        };

    self.url = null;

    self.pushRow = function (row) {
      data.push(row);
      triggerUpdates();
    };

    self.createQuery = function () {
      var query = new Query();
      query.setDataSource(self);
      queries.push(query);
      return query;
    };

    self.getRawData = function () {
      return data;
    };

    self.setRawData = function (_data) {
      data = _data;
    };

    self.clearRows = function () {
      data = [];
      triggerUpdates();
    };

    self.setURL = function (_url) {
      self.url = _url;
    };

    var triggerUpdates = function () {
      if(applyingPatch) {
        return;
      }
      for (var i = 0; i < queries.length; i++) {
        queries[i].triggerUpdates();
      }
    };
    
    self.addColumn = function (key, values) {
      var i, dataLen = data.length;
      if(data.length != 0 && data.length != values.length) {
        dataError.status = true;
        dataError.msg = "Array length did not match";
      }
      for (i = 0; i < values.length; i++) {
        if (i >= dataLen) {
          data[i] = {};
        }
        data[i][key] = values[i];
      }
      triggerUpdates();
    };

    self.getErrorStatus = function () {
      return dataError;
    };

    self.startApplyPatches = function () {
      applyingPatch = true;
    };

    self.endApplyPatches = function () {
      applyingPatch = false;
      triggerUpdates();
    };

    self.applyPatch = function (patchObj) {
      var action = patchObj.action, index = patchObj.index, params = patchObj.params;

      var applied = false;

      switch (action) {
        case 'setColumn':
        self.setColumn(index, params);
        applied = true;
        break;
        case 'pushRow':
        self.pushRow(params);
        applied = true;
        break;
        case 'addColumn':
        self.addColumn(index, params);
        applied = true;
        break;
        case 'clearRows':
        self.clearRows();
        applied = true;
        break;
        default:
        break;
      }
    };

    self.applyPatches = function (patches) {
      self.startApplyPatches();
      for(var i = 0; i < patches.length; i++) {
        self.applyPatch(patches[i]);
      }
      self.endApplyPatches();
    };
  }

  return DataSource;
});

define('utils/iconutils',[], function() {
    var IconUtils = {
        getHTMLForIcon: function(id, config) {
          config = config || {};
          var span = $('<span/>'),
              css = config.css || {};

          span.addClass('rficon rfi-' + id + ' ' + config.extraClass || '');
          span.css(_.extend(css, {
              fontSize: config.fontSize || 'inherit',
              color: config.color || '#000'
          }));

          return span;
        }
    };

    return IconUtils;
});
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.userevents',[ "./kendo.core" ], f);
})(function(){

(function ($, undefined) {
    var kendo = window.kendo,
        support = kendo.support,
        document = window.document,
        Class = kendo.Class,
        Observable = kendo.Observable,
        now = $.now,
        extend = $.extend,
        OS = support.mobileOS,
        invalidZeroEvents = OS && OS.android,
        DEFAULT_MIN_HOLD = 800,
        DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0, // WP8 and W8 are very sensitive and always report move.

        // UserEvents events
        PRESS = "press",
        HOLD = "hold",
        SELECT = "select",
        START = "start",
        MOVE = "move",
        END = "end",
        CANCEL = "cancel",
        TAP = "tap",
        RELEASE = "release",
        GESTURESTART = "gesturestart",
        GESTURECHANGE = "gesturechange",
        GESTUREEND = "gestureend",
        GESTURETAP = "gesturetap";

    function touchDelta(touch1, touch2) {
        var x1 = touch1.x.location,
            y1 = touch1.y.location,
            x2 = touch2.x.location,
            y2 = touch2.y.location,
            dx = x1 - x2,
            dy = y1 - y2;

        return {
            center: {
               x: (x1 + x2) / 2,
               y: (y1 + y2) / 2
            },

            distance: Math.sqrt(dx*dx + dy*dy)
        };
    }

    function getTouches(e) {
        var touches = [],
            originalEvent = e.originalEvent,
            currentTarget = e.currentTarget,
            idx = 0, length,
            changedTouches,
            touch;

        if (e.api) {
            touches.push({
                id: 2,  // hardcoded ID for API call;
                event: e,
                target: e.target,
                currentTarget: e.target,
                location: e
            });
        }
        else if (e.type.match(/touch/)) {
            changedTouches = originalEvent ? originalEvent.changedTouches : [];
            for (length = changedTouches.length; idx < length; idx ++) {
                touch = changedTouches[idx];
                touches.push({
                    location: touch,
                    event: e,
                    target: touch.target,
                    currentTarget: currentTarget,
                    id: touch.identifier
                });
            }
        }
        else if (support.pointers || support.msPointers) {
            touches.push({
                location: originalEvent,
                event: e,
                target: e.target,
                currentTarget: currentTarget,
                id: originalEvent.pointerId
            });
        } else {
            touches.push({
                id: 1, // hardcoded ID for mouse event;
                event: e,
                target: e.target,
                currentTarget: currentTarget,
                location: e
            });
        }

        return touches;
    }

    var TouchAxis = Class.extend({
        init: function(axis, location) {
            var that = this;

            that.axis = axis;

            that._updateLocationData(location);

            that.startLocation = that.location;
            that.velocity = that.delta = 0;
            that.timeStamp = now();
        },

        move: function(location) {
            var that = this,
                offset = location["page" + that.axis],
                timeStamp = now(),
                timeDelta = (timeStamp - that.timeStamp) || 1; // Firing manually events in tests can make this 0;

            if (!offset && invalidZeroEvents) {
                return;
            }

            that.delta = offset - that.location;

            that._updateLocationData(location);

            that.initialDelta = offset - that.startLocation;
            that.velocity = that.delta / timeDelta;
            that.timeStamp = timeStamp;
        },

        _updateLocationData: function(location) {
            var that = this, axis = that.axis;

            that.location = location["page" + axis];
            that.client = location["client" + axis];
            that.screen = location["screen" + axis];
        }
    });

    var Touch = Class.extend({
        init: function(userEvents, target, touchInfo) {
            extend(this, {
                x: new TouchAxis("X", touchInfo.location),
                y: new TouchAxis("Y", touchInfo.location),
                userEvents: userEvents,
                target: target,
                currentTarget: touchInfo.currentTarget,
                initialTouch: touchInfo.target,
                id: touchInfo.id,
                pressEvent: touchInfo,
                _moved: false,
                _finished: false
            });
        },

        press: function() {
            this._holdTimeout = setTimeout($.proxy(this, "_hold"), this.userEvents.minHold);
            this._trigger(PRESS, this.pressEvent);
        },

        _hold: function() {
            this._trigger(HOLD, this.pressEvent);
        },

        move: function(touchInfo) {
            var that = this;

            if (that._finished) { return; }

            that.x.move(touchInfo.location);
            that.y.move(touchInfo.location);

            if (!that._moved) {
                if (that._withinIgnoreThreshold()) {
                    return;
                }

                if (!UserEvents.current || UserEvents.current === that.userEvents) {
                    that._start(touchInfo);
                } else {
                    return that.dispose();
                }
            }

            // Event handlers may cancel the drag in the START event handler, hence the double check for pressed.
            if (!that._finished) {
                that._trigger(MOVE, touchInfo);
            }
        },

        end: function(touchInfo) {
            var that = this;

            that.endTime = now();

            if (that._finished) { return; }

            // Mark the object as finished if there are blocking operations in the event handlers (alert/confirm)
            that._finished = true;

            if (that._moved) {
                that._trigger(END, touchInfo);
            } else {
                that._trigger(TAP, touchInfo);
            }

            clearTimeout(that._holdTimeout);
            that._trigger(RELEASE, touchInfo);

            that.dispose();
        },

        dispose: function() {
            var userEvents = this.userEvents,
                activeTouches = userEvents.touches;

            this._finished = true;
            this.pressEvent = null;
            clearTimeout(this._holdTimeout);

            activeTouches.splice($.inArray(this, activeTouches), 1);
        },

        skip: function() {
            this.dispose();
        },

        cancel: function() {
            this.dispose();
        },

        isMoved: function() {
            return this._moved;
        },

        _start: function(touchInfo) {
            clearTimeout(this._holdTimeout);

            this.startTime = now();
            this._moved = true;
            this._trigger(START, touchInfo);
        },

        _trigger: function(name, touchInfo) {
            var that = this,
                jQueryEvent = touchInfo.event,
                data = {
                    touch: that,
                    x: that.x,
                    y: that.y,
                    target: that.target,
                    event: jQueryEvent
                };

            if(that.userEvents.notify(name, data)) {
                jQueryEvent.preventDefault();
            }
        },

        _withinIgnoreThreshold: function() {
            var xDelta = this.x.initialDelta,
                yDelta = this.y.initialDelta;

            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.userEvents.threshold;
        }
    });

    function preventTrigger(e) {
        e.preventDefault();

        var target = $(e.data.root),   // Determine the correct parent to receive the event and bubble.
            parent = target.closest(".k-widget").parent();

        if (!parent[0]) {
            parent = target.parent();
        }

        var fakeEventData = $.extend(true, {}, e, { target: target[0] });
        parent.trigger($.Event(e.type, fakeEventData));
    }

    function withEachUpEvent(callback) {
        var downEvents = kendo.eventMap.up.split(" "),
            idx = 0,
            length = downEvents.length;

        for(; idx < length; idx ++) {
            callback(downEvents[idx]);
        }
    }

    var UserEvents = Observable.extend({
        init: function(element, options) {
            var that = this,
                filter,
                ns = kendo.guid();

            options = options || {};
            filter = that.filter = options.filter;
            that.threshold = options.threshold || DEFAULT_THRESHOLD;
            that.minHold = options.minHold || DEFAULT_MIN_HOLD;
            that.touches = [];
            that._maxTouches = options.multiTouch ? 2 : 1;
            that.allowSelection = options.allowSelection;
            that.captureUpIfMoved = options.captureUpIfMoved;
            that.eventNS = ns;

            element = $(element).handler(that);
            Observable.fn.init.call(that);

            extend(that, {
                element: element,
                surface: options.global ? $(document.documentElement) : $(options.surface || element),
                stopPropagation: options.stopPropagation,
                pressed: false
            });

            that.surface.handler(that)
                .on(kendo.applyEventMap("move", ns), "_move")
                .on(kendo.applyEventMap("up cancel", ns), "_end");

            element.on(kendo.applyEventMap("down", ns), filter, "_start");

            if (support.pointers || support.msPointers) {
                element.css("-ms-touch-action", "pinch-zoom double-tap-zoom");
            }

            if (options.preventDragEvent) {
                element.on(kendo.applyEventMap("dragstart", ns), kendo.preventDefault);
            }

            element.on(kendo.applyEventMap("mousedown selectstart", ns), filter, { root: element }, "_select");

            if (that.captureUpIfMoved && support.eventCapture) {
                var surfaceElement = that.surface[0],
                    preventIfMovingProxy = $.proxy(that.preventIfMoving, that);

                withEachUpEvent(function(eventName) {
                    surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
                });
            }

            that.bind([
            PRESS,
            HOLD,
            TAP,
            START,
            MOVE,
            END,
            RELEASE,
            CANCEL,
            GESTURESTART,
            GESTURECHANGE,
            GESTUREEND,
            GESTURETAP,
            SELECT
            ], options);
        },

        preventIfMoving: function(e) {
            if (this._isMoved()) {
                e.preventDefault();
            }
        },

        destroy: function() {
            var that = this;

            if (that._destroyed) {
                return;
            }

            that._destroyed = true;

            if (that.captureUpIfMoved && support.eventCapture) {
                var surfaceElement = that.surface[0];
                withEachUpEvent(function(eventName) {
                    surfaceElement.removeEventListener(eventName, that.preventIfMoving);
                });
            }

            that.element.kendoDestroy(that.eventNS);
            that.surface.kendoDestroy(that.eventNS);
            that.element.removeData("handler");
            that.surface.removeData("handler");
            that._disposeAll();

            that.unbind();
            delete that.surface;
            delete that.element;
            delete that.currentTarget;
        },

        capture: function() {
            UserEvents.current = this;
        },

        cancel: function() {
            this._disposeAll();
            this.trigger(CANCEL);
        },

        notify: function(eventName, data) {
            var that = this,
                touches = that.touches;

            if (this._isMultiTouch()) {
                switch(eventName) {
                    case MOVE:
                        eventName = GESTURECHANGE;
                        break;
                    case END:
                        eventName = GESTUREEND;
                        break;
                    case TAP:
                        eventName = GESTURETAP;
                        break;
                }

                extend(data, {touches: touches}, touchDelta(touches[0], touches[1]));
            }

            return this.trigger(eventName, data);
        },

        // API
        press: function(x, y, target) {
            this._apiCall("_start", x, y, target);
        },

        move: function(x, y) {
            this._apiCall("_move", x, y);
        },

        end: function(x, y) {
            this._apiCall("_end", x, y);
        },

        _isMultiTouch: function() {
            return this.touches.length > 1;
        },

        _maxTouchesReached: function() {
            return this.touches.length >= this._maxTouches;
        },

        _disposeAll: function() {
            var touches = this.touches;
            while (touches.length > 0) {
                touches.pop().dispose();
            }
        },

        _isMoved: function() {
            return $.grep(this.touches, function(touch) {
                return touch.isMoved();
            }).length;
        },

        _select: function(e) {
           if (!this.allowSelection || this.trigger(SELECT, { event: e })) {
                preventTrigger(e);
           }
        },

        _start: function(e) {
            var that = this,
                idx = 0,
                filter = that.filter,
                target,
                touches = getTouches(e),
                length = touches.length,
                touch,
                which = e.which;

            if (which && which > 1){
                return;
            }

            if (that._maxTouchesReached()) {
                return;
            }

            UserEvents.current = null;

            that.currentTarget = e.currentTarget;

            if (that.stopPropagation) {
                e.stopPropagation();
            }

            for (; idx < length; idx ++) {
                if (that._maxTouchesReached()) {
                    break;
                }

                touch = touches[idx];

                if (filter) {
                    target = $(touch.currentTarget); // target.is(filter) ? target : target.closest(filter, that.element);
                } else {
                    target = that.element;
                }

                if (!target.length) {
                    continue;
                }

                touch = new Touch(that, target, touch);
                that.touches.push(touch);
                touch.press();

                if (that._isMultiTouch()) {
                    that.notify("gesturestart", {});
                }
            }
        },

        _move: function(e) {
            this._eachTouch("move", e);
        },

        _end: function(e) {
            this._eachTouch("end", e);
        },

        _eachTouch: function(methodName, e) {
            var that = this,
                dict = {},
                touches = getTouches(e),
                activeTouches = that.touches,
                idx,
                touch,
                touchInfo,
                matchingTouch;

            for (idx = 0; idx < activeTouches.length; idx ++) {
                touch = activeTouches[idx];
                dict[touch.id] = touch;
            }

            for (idx = 0; idx < touches.length; idx ++) {
                touchInfo = touches[idx];
                matchingTouch = dict[touchInfo.id];

                if (matchingTouch) {
                    matchingTouch[methodName](touchInfo);
                }
            }
        },

        _apiCall: function(type, x, y, target) {
            this[type]({
                api: true,
                pageX: x,
                pageY: y,
                clientX: x,
                clientY: y,
                target: $(target || this.element)[0],
                stopPropagation: $.noop,
                preventDefault: $.noop
            });
        }
    });

    UserEvents.minHold = function(value) {
        DEFAULT_MIN_HOLD = value;
    };

    kendo.getTouches = getTouches;
    kendo.touchDelta = touchDelta;
    kendo.UserEvents = UserEvents;
 })(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.draganddrop',[ "./kendo.core", "./kendo.userevents" ], f);
})(function(){

(function ($, undefined) {
    var kendo = window.kendo,
        support = kendo.support,
        document = window.document,
        Class = kendo.Class,
        Widget = kendo.ui.Widget,
        Observable = kendo.Observable,
        UserEvents = kendo.UserEvents,
        proxy = $.proxy,
        extend = $.extend,
        getOffset = kendo.getOffset,
        draggables = {},
        dropTargets = {},
        dropAreas = {},
        lastDropTarget,
        elementUnderCursor = kendo.elementUnderCursor,
        KEYUP = "keyup",
        CHANGE = "change",

        // Draggable events
        DRAGSTART = "dragstart",
        HOLD = "hold",
        DRAG = "drag",
        DRAGEND = "dragend",
        DRAGCANCEL = "dragcancel",

        // DropTarget events
        DRAGENTER = "dragenter",
        DRAGLEAVE = "dragleave",
        DROP = "drop";

    function contains(parent, child) {
        try {
            return $.contains(parent, child) || parent == child;
        } catch (e) {
            return false;
        }
    }

    function numericCssPropery(element, property) {
        return parseInt(element.css(property), 10) || 0;
    }

    function within(value, range) {
        return Math.min(Math.max(value, range.min), range.max);
    }

    function containerBoundaries(container, element) {
        var offset = getOffset(container),
            minX = offset.left + numericCssPropery(container, "borderLeftWidth") + numericCssPropery(container, "paddingLeft"),
            minY = offset.top + numericCssPropery(container, "borderTopWidth") + numericCssPropery(container, "paddingTop"),
            maxX = minX + container.width() - element.outerWidth(true),
            maxY = minY + container.height() - element.outerHeight(true);

        return {
            x: { min: minX, max: maxX },
            y: { min: minY, max: maxY }
        };
    }

    function checkTarget(target, targets, areas) {
        var theTarget, theFilter, i = 0,
            targetLen = targets && targets.length,
            areaLen = areas && areas.length;

        while (target && target.parentNode) {
            for (i = 0; i < targetLen; i ++) {
                theTarget = targets[i];
                if (theTarget.element[0] === target) {
                    return { target: theTarget, targetElement: target };
                }
            }

            for (i = 0; i < areaLen; i ++) {
                theFilter = areas[i];
                if (support.matchesSelector.call(target, theFilter.options.filter)) {
                    return { target: theFilter, targetElement: target };
                }
            }

            target = target.parentNode;
        }

        return undefined;
    }

    var TapCapture = Observable.extend({
        init: function(element, options) {
            var that = this,
                domElement = element[0];

            that.capture = false;

            if (domElement.addEventListener) {
                $.each(kendo.eventMap.down.split(" "), function() {
                    domElement.addEventListener(this, proxy(that._press, that), true);
                });
                $.each(kendo.eventMap.up.split(" "), function() {
                    domElement.addEventListener(this, proxy(that._release, that), true);
                });
            } else {
                $.each(kendo.eventMap.down.split(" "), function() {
                    domElement.attachEvent(this, proxy(that._press, that));
                });
                $.each(kendo.eventMap.up.split(" "), function() {
                    domElement.attachEvent(this, proxy(that._release, that));
                });
            }

            Observable.fn.init.call(that);

            that.bind(["press", "release"], options || {});
        },

        captureNext: function() {
            this.capture = true;
        },

        cancelCapture: function() {
            this.capture = false;
        },

        _press: function(e) {
            var that = this;
            that.trigger("press");
            if (that.capture) {
                e.preventDefault();
            }
        },

        _release: function(e) {
            var that = this;
            that.trigger("release");

            if (that.capture) {
                e.preventDefault();
                that.cancelCapture();
            }
        }
    });

    var PaneDimension = Observable.extend({
        init: function(options) {
            var that = this;
            Observable.fn.init.call(that);

            that.forcedEnabled = false;

            $.extend(that, options);

            that.scale = 1;

            if (that.horizontal) {
                that.measure = "offsetWidth";
                that.scrollSize = "scrollWidth";
                that.axis = "x";
            } else {
                that.measure = "offsetHeight";
                that.scrollSize = "scrollHeight";
                that.axis = "y";
            }
        },

        makeVirtual: function() {
            $.extend(this, {
                virtual: true,
                forcedEnabled: true,
                _virtualMin: 0,
                _virtualMax: 0
            });
        },

        virtualSize: function(min, max) {
            if (this._virtualMin !== min || this._virtualMax !== max) {
                this._virtualMin = min;
                this._virtualMax = max;
                this.update();
            }
        },

        outOfBounds: function(offset) {
            return offset > this.max || offset < this.min;
        },

        forceEnabled: function() {
            this.forcedEnabled = true;
        },

        getSize: function() {
            return this.container[0][this.measure];
        },

        getTotal: function() {
            return this.element[0][this.scrollSize];
        },

        rescale: function(scale) {
            this.scale = scale;
        },

        update: function(silent) {
            var that = this,
                total = that.virtual ? that._virtualMax : that.getTotal(),
                scaledTotal = total * that.scale,
                size = that.getSize();

            that.max = that.virtual ? -that._virtualMin : 0;
            that.size = size;
            that.total = scaledTotal;
            that.min = Math.min(that.max, size - scaledTotal);
            that.minScale = size / total;
            that.centerOffset = (scaledTotal - size) / 2;

            that.enabled = that.forcedEnabled || (scaledTotal > size);

            if (!silent) {
                that.trigger(CHANGE, that);
            }
        }
    });

    var PaneDimensions = Observable.extend({
        init: function(options) {
            var that = this;

            Observable.fn.init.call(that);

            that.x = new PaneDimension(extend({horizontal: true}, options));
            that.y = new PaneDimension(extend({horizontal: false}, options));
            that.container = options.container;
            that.forcedMinScale = options.minScale;
            that.maxScale = options.maxScale || 100;

            that.bind(CHANGE, options);
        },

        rescale: function(newScale) {
            this.x.rescale(newScale);
            this.y.rescale(newScale);
            this.refresh();
        },

        centerCoordinates: function() {
            return { x: Math.min(0, -this.x.centerOffset), y: Math.min(0, -this.y.centerOffset) };
        },

        refresh: function() {
            var that = this;
            that.x.update();
            that.y.update();
            that.enabled = that.x.enabled || that.y.enabled;
            that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
            that.fitScale = Math.max(that.x.minScale, that.y.minScale);
            that.trigger(CHANGE);
        }
    });

    var PaneAxis = Observable.extend({
        init: function(options) {
            var that = this;
            extend(that, options);
            Observable.fn.init.call(that);
        },

        outOfBounds: function() {
            return this.dimension.outOfBounds(this.movable[this.axis]);
        },

        dragMove: function(delta) {
            var that = this,
                dimension = that.dimension,
                axis = that.axis,
                movable = that.movable,
                position = movable[axis] + delta;

            if (!dimension.enabled) {
                return;
            }

            if ((position < dimension.min && delta < 0) || (position > dimension.max && delta > 0)) {
                delta *= that.resistance;
            }

            movable.translateAxis(axis, delta);
            that.trigger(CHANGE, that);
        }
    });

    var Pane = Class.extend({

        init: function(options) {
            var that = this,
                x,
                y,
                resistance,
                movable;

            extend(that, {elastic: true}, options);

            resistance = that.elastic ? 0.5 : 0;
            movable = that.movable;

            that.x = x = new PaneAxis({
                axis: "x",
                dimension: that.dimensions.x,
                resistance: resistance,
                movable: movable
            });

            that.y = y = new PaneAxis({
                axis: "y",
                dimension: that.dimensions.y,
                resistance: resistance,
                movable: movable
            });

            that.userEvents.bind(["move", "end", "gesturestart", "gesturechange"], {
                gesturestart: function(e) {
                    that.gesture = e;
                    that.offset = that.dimensions.container.offset();
                },

                gesturechange: function(e) {
                    var previousGesture = that.gesture,
                        previousCenter = previousGesture.center,

                        center = e.center,

                        scaleDelta = e.distance / previousGesture.distance,

                        minScale = that.dimensions.minScale,
                        maxScale = that.dimensions.maxScale,
                        coordinates;

                    if (movable.scale <= minScale && scaleDelta < 1) {
                        // Resist shrinking. Instead of shrinking from 1 to 0.5, it will shrink to 0.5 + (1 /* minScale */ - 0.5) * 0.8 = 0.9;
                        scaleDelta += (1 - scaleDelta) * 0.8;
                    }

                    if (movable.scale * scaleDelta >= maxScale) {
                        scaleDelta = maxScale / movable.scale;
                    }

                    var offsetX = movable.x + that.offset.left,
                        offsetY = movable.y + that.offset.top;

                    coordinates = {
                        x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
                        y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
                    };

                    movable.scaleWith(scaleDelta);

                    x.dragMove(coordinates.x);
                    y.dragMove(coordinates.y);

                    that.dimensions.rescale(movable.scale);
                    that.gesture = e;
                    e.preventDefault();
                },

                move: function(e) {
                    if (e.event.target.tagName.match(/textarea|input/i)) {
                        return;
                    }

                    if (x.dimension.enabled || y.dimension.enabled) {
                        x.dragMove(e.x.delta);
                        y.dragMove(e.y.delta);
                        e.preventDefault();
                    } else {
                        e.touch.skip();
                    }
                },

                end: function(e) {
                    e.preventDefault();
                }
            });
        }
    });

    var TRANSFORM_STYLE = support.transitions.prefix + "Transform",
        translate;


    if (support.hasHW3D) {
        translate = function(x, y, scale) {
            return "translate3d(" + x + "px," + y +"px,0) scale(" + scale + ")";
        };
    } else {
        translate = function(x, y, scale) {
            return "translate(" + x + "px," + y +"px) scale(" + scale + ")";
        };
    }

    var Movable = Observable.extend({
        init: function(element) {
            var that = this;

            Observable.fn.init.call(that);

            that.element = $(element);
            that.element[0].style.webkitTransformOrigin = "left top";
            that.x = 0;
            that.y = 0;
            that.scale = 1;
            that._saveCoordinates(translate(that.x, that.y, that.scale));
        },

        translateAxis: function(axis, by) {
            this[axis] += by;
            this.refresh();
        },

        scaleTo: function(scale) {
            this.scale = scale;
            this.refresh();
        },

        scaleWith: function(scaleDelta) {
            this.scale *= scaleDelta;
            this.refresh();
        },

        translate: function(coordinates) {
            this.x += coordinates.x;
            this.y += coordinates.y;
            this.refresh();
        },

        moveAxis: function(axis, value) {
            this[axis] = value;
            this.refresh();
        },

        moveTo: function(coordinates) {
            extend(this, coordinates);
            this.refresh();
        },

        refresh: function() {
            var that = this,
                x = that.x,
                y = that.y,
                newCoordinates;

            if (that.round) {
                x = Math.round(x);
                y = Math.round(y);
            }

            newCoordinates = translate(x, y, that.scale);

            if (newCoordinates != that.coordinates) {
                if (kendo.support.browser.msie && kendo.support.browser.version < 10) {
                    that.element[0].style.position = "absolute";
                    that.element[0].style.left = that.x + "px";
                    that.element[0].style.top = that.y + "px";
                } else {
                    that.element[0].style[TRANSFORM_STYLE] = newCoordinates;
                }
                that._saveCoordinates(newCoordinates);
                that.trigger(CHANGE);
            }
        },

        _saveCoordinates: function(coordinates) {
            this.coordinates = coordinates;
        }
    });

    var DropTarget = Widget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            var group = that.options.group;

            if (!(group in dropTargets)) {
                dropTargets[group] = [ that ];
            } else {
                dropTargets[group].push( that );
            }
        },

        events: [
            DRAGENTER,
            DRAGLEAVE,
            DROP
        ],

        options: {
            name: "DropTarget",
            group: "default"
        },

        destroy: function() {
            var groupName = this.options.group,
                group = dropTargets[groupName] || dropAreas[groupName],
                i;

            if (group.length > 1) {
                Widget.fn.destroy.call(this);

                for (i = 0; i < group.length; i++) {
                    if (group[i] == this) {
                        group.splice(i, 1);
                        break;
                    }
                }
            } else {
                DropTarget.destroyGroup(groupName);
            }
        },

        _trigger: function(eventName, e) {
            var that = this,
                draggable = draggables[that.options.group];

            if (draggable) {
                return that.trigger(eventName, extend({}, e.event, {
                           draggable: draggable,
                           dropTarget: e.dropTarget
                       }));
            }
        },

        _over: function(e) {
            this._trigger(DRAGENTER, e);
        },

        _out: function(e) {
            this._trigger(DRAGLEAVE, e);
        },

        _drop: function(e) {
            var that = this,
                draggable = draggables[that.options.group];

            if (draggable) {
                draggable.dropped = !that._trigger(DROP, e);
            }
        }
    });

    DropTarget.destroyGroup = function(groupName) {
        var group = dropTargets[groupName] || dropAreas[groupName],
            i;

        if (group) {
            for (i = 0; i < group.length; i++) {
                Widget.fn.destroy.call(group[i]);
            }

            group.length = 0;
            delete dropTargets[groupName];
            delete dropAreas[groupName];
        }
    };

    DropTarget._cache = dropTargets;

    var DropTargetArea = DropTarget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            var group = that.options.group;

            if (!(group in dropAreas)) {
                dropAreas[group] = [ that ];
            } else {
                dropAreas[group].push( that );
            }
        },

        options: {
            name: "DropTargetArea",
            group: "default",
            filter: null
        }
    });

    var Draggable = Widget.extend({
        init: function (element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            that._activated = false;

            that.userEvents = new UserEvents(that.element, {
                global: true,
                allowSelection: true,
                stopPropagation: true,
                filter: that.options.filter,
                threshold: that.options.distance,
                start: proxy(that._start, that),
                hold: proxy(that._hold, that),
                move: proxy(that._drag, that),
                end: proxy(that._end, that),
                cancel: proxy(that._cancel, that),
                select: proxy(that._select, that)
            });

            that._afterEndHandler = proxy(that._afterEnd, that);
            that.captureEscape = function(e) {
                if (e.keyCode === kendo.keys.ESC) {
                    that._trigger(DRAGCANCEL, {event: e});
                    that.userEvents.cancel();
                }
            };
        },

        events: [
            HOLD,
            DRAGSTART,
            DRAG,
            DRAGEND,
            DRAGCANCEL
        ],

        options: {
            name: "Draggable",
            distance: 5,
            group: "default",
            cursorOffset: null,
            axis: null,
            container: null,
            filter: null,
            ignore: null,
            holdToDrag: false,
            dropped: false
        },

        cancelHold: function() {
            this._activated = false;
        },

        _updateHint: function(e) {
            var that = this,
                coordinates,
                options = that.options,
                boundaries = that.boundaries,
                axis = options.axis,
                cursorOffset = that.options.cursorOffset;

            if (cursorOffset) {
               coordinates = { left: e.x.location + cursorOffset.left, top: e.y.location + cursorOffset.top };
            } else {
               that.hintOffset.left += e.x.delta;
               that.hintOffset.top += e.y.delta;
               coordinates = $.extend({}, that.hintOffset);
            }

            if (boundaries) {
                coordinates.top = within(coordinates.top, boundaries.y);
                coordinates.left = within(coordinates.left, boundaries.x);
            }

            if (axis === "x") {
                delete coordinates.top;
            } else if (axis === "y") {
                delete coordinates.left;
            }

            that.hint.css(coordinates);
        },

        _shouldIgnoreTarget: function(target) {
            var ignoreSelector = this.options.ignore;
            return ignoreSelector && $(target).is(ignoreSelector);
        },

        _select: function(e) {
            if (!this._shouldIgnoreTarget(e.event.target)) {
                e.preventDefault();
            }
        },

        _start: function(e) {
            var that = this,
                options = that.options,
                container = options.container,
                hint = options.hint;

            if (this._shouldIgnoreTarget(e.touch.initialTouch) || (options.holdToDrag && !that._activated)) {
                that.userEvents.cancel();
                return;
            }

            that.currentTarget = e.target;
            that.currentTargetOffset = getOffset(that.currentTarget);

            if (hint) {
                if (that.hint) {
                    that.hint.stop(true, true).remove();
                }

                that.hint = kendo.isFunction(hint) ? $(hint.call(that, that.currentTarget)) : hint;

                var offset = getOffset(that.currentTarget);
                that.hintOffset = offset;

                that.hint.css( {
                    position: "absolute",
                    zIndex: 20000, // the Window's z-index is 10000 and can be raised because of z-stacking
                    left: offset.left,
                    top: offset.top
                })
                .appendTo(document.body);
            }

            draggables[options.group] = that;

            that.dropped = false;

            if (container) {
                that.boundaries = containerBoundaries(container, that.hint);
            }

            if (that._trigger(DRAGSTART, e)) {
                that.userEvents.cancel();
                that._afterEnd();
            }

            $(document).on(KEYUP, that.captureEscape);
        },

        _hold: function(e) {
            this.currentTarget = e.target;

            if (this._trigger(HOLD, e)) {
                this.userEvents.cancel();
            } else {
                this._activated = true;
            }
        },

        _drag: function(e) {
            var that = this;

            e.preventDefault();

            that._withDropTarget(e, function(target, targetElement) {
                if (!target) {
                    if (lastDropTarget) {
                        lastDropTarget._trigger(DRAGLEAVE, extend(e, { dropTarget: $(lastDropTarget.targetElement) }));
                        lastDropTarget = null;
                    }
                    return;
                }

                if (lastDropTarget) {
                    if (targetElement === lastDropTarget.targetElement) {
                        return;
                    }

                    lastDropTarget._trigger(DRAGLEAVE, extend(e, { dropTarget: $(lastDropTarget.targetElement) }));
                }

                target._trigger(DRAGENTER, extend(e, { dropTarget: $(targetElement) }));
                lastDropTarget = extend(target, { targetElement: targetElement });
            });

            that._trigger(DRAG, e);

            if (that.hint) {
                that._updateHint(e);
            }
        },

        _end: function(e) {
            var that = this;

            that._withDropTarget(e, function(target, targetElement) {
                if (target) {
                    target._drop(extend({}, e, { dropTarget: $(targetElement) }));
                    lastDropTarget = null;
                }
            });

            that._trigger(DRAGEND, e);
            that._cancel(e.event);
        },

        _cancel: function() {
            var that = this;

            that._activated = false;

            if (that.hint && !that.dropped) {
                setTimeout(function() {
                    that.hint.stop(true, true).animate(that.currentTargetOffset, "fast", that._afterEndHandler);
                }, 0);

            } else {
                that._afterEnd();
            }
        },

        _trigger: function(eventName, e) {
            var that = this;

            return that.trigger(
                eventName, extend(
                {},
                e.event,
                {
                    x: e.x,
                    y: e.y,
                    currentTarget: that.currentTarget,
                    dropTarget: e.dropTarget
                }
            ));
        },

        _withDropTarget: function(e, callback) {
            var that = this,
                target, result,
                options = that.options,
                targets = dropTargets[options.group],
                areas = dropAreas[options.group];

            if (targets && targets.length || areas && areas.length) {

                target = elementUnderCursor(e);

                if (that.hint && contains(that.hint[0], target)) {
                    that.hint.hide();
                    target = elementUnderCursor(e);
                    // IE8 does not return the element in iframe from first attempt
                    if (!target) {
                        target = elementUnderCursor(e);
                    }
                    that.hint.show();
                }

                result = checkTarget(target, targets, areas);

                if (result) {
                    callback(result.target, result.targetElement);
                } else {
                    callback();
                }
            }
        },

        destroy: function() {
            var that = this;

            Widget.fn.destroy.call(that);

            that._afterEnd();

            that.userEvents.destroy();

            that.currentTarget = null;
        },

        _afterEnd: function() {
            var that = this;

            if (that.hint) {
                that.hint.remove();
            }

            delete draggables[that.options.group];

            that.trigger("destroy");
            $(document).off(KEYUP, that.captureEscape);
        }
    });

    kendo.ui.plugin(DropTarget);
    kendo.ui.plugin(DropTargetArea);
    kendo.ui.plugin(Draggable);
    kendo.TapCapture = TapCapture;
    kendo.containerBoundaries = containerBoundaries;

    extend(kendo.ui, {
        Pane: Pane,
        PaneDimensions: PaneDimensions,
        Movable: Movable
    });

 })(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.window',[ "./kendo.draganddrop" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        Widget = kendo.ui.Widget,
        Draggable = kendo.ui.Draggable,
        isPlainObject = $.isPlainObject,
        activeElement = kendo._activeElement,
        proxy = $.proxy,
        extend = $.extend,
        each = $.each,
        template = kendo.template,
        BODY = "body",
        templates,
        NS = ".kendoWindow",
        // classNames
        KWINDOW = ".k-window",
        KWINDOWTITLE = ".k-window-title",
        KWINDOWTITLEBAR = KWINDOWTITLE + "bar",
        KWINDOWCONTENT = ".k-window-content",
        KWINDOWRESIZEHANDLES = ".k-resize-handle",
        KOVERLAY = ".k-overlay",
        KCONTENTFRAME = "k-content-frame",
        LOADING = "k-loading",
        KHOVERSTATE = "k-state-hover",
        KFOCUSEDSTATE = "k-state-focused",
        MAXIMIZEDSTATE = "k-window-maximized",
        // constants
        VISIBLE = ":visible",
        HIDDEN = "hidden",
        CURSOR = "cursor",
        // events
        OPEN = "open",
        ACTIVATE = "activate",
        DEACTIVATE = "deactivate",
        CLOSE = "close",
        REFRESH = "refresh",
        RESIZE = "resize",
        DRAGSTART = "dragstart",
        DRAGEND = "dragend",
        ERROR = "error",
        OVERFLOW = "overflow",
        ZINDEX = "zIndex",
        MINIMIZE_MAXIMIZE = ".k-window-actions .k-i-minimize,.k-window-actions .k-i-maximize",
        KPIN = ".k-i-pin",
        KUNPIN = ".k-i-unpin",
        PIN_UNPIN = KPIN + "," + KUNPIN,
        TITLEBAR_BUTTONS = ".k-window-titlebar .k-window-action",
        REFRESHICON = ".k-window-titlebar .k-i-refresh",
        isLocalUrl = kendo.isLocalUrl;

    function defined(x) {
        return (typeof x != "undefined");
    }

    function constrain(value, low, high) {
        return Math.max(Math.min(parseInt(value, 10), high === Infinity ? high : parseInt(high, 10)), parseInt(low, 10));
    }

    function sizingAction(actionId, callback) {
        return function() {
            var that = this,
                wrapper = that.wrapper,
                style = wrapper[0].style,
                options = that.options;

            if (options.isMaximized || options.isMinimized) {
                return;
            }

            that.restoreOptions = {
                width: style.width,
                height: style.height
            };

            wrapper
                .children(KWINDOWRESIZEHANDLES).hide().end()
                .children(KWINDOWTITLEBAR).find(MINIMIZE_MAXIMIZE).parent().hide()
                    .eq(0).before(templates.action({ name: "Restore" }));

            callback.call(that);

            if (actionId == "maximize") {
                that.wrapper.children(KWINDOWTITLEBAR).find(PIN_UNPIN).parent().hide();
            } else {
                that.wrapper.children(KWINDOWTITLEBAR).find(PIN_UNPIN).parent().show();
            }

            return that;
        };
    }

    function executableScript() {
        return !this.type || this.type.toLowerCase().indexOf("script") >= 0;
    }

    var Window = Widget.extend({
        init: function(element, options) {
            var that = this,
                wrapper,
                offset = {},
                visibility, display, position,
                isVisible = false,
                content,
                windowContent,
                suppressActions = options && options.actions && !options.actions.length,
                id;

            Widget.fn.init.call(that, element, options);
            options = that.options;
            position = options.position;
            element = that.element;
            content = options.content;

            if (suppressActions) {
                options.actions = [];
            }

            that.appendTo = $(options.appendTo);

            that._animations();

            if (content && !isPlainObject(content)) {
                content = options.content = { url: content };
            }

            // remove script blocks to prevent double-execution
            element.find("script").filter(executableScript).remove();

            if (!element.parent().is(that.appendTo) && (position.top === undefined || position.left === undefined)) {
                if (element.is(VISIBLE)) {
                    offset = element.offset();
                    isVisible = true;
                } else {
                    visibility = element.css("visibility");
                    display = element.css("display");

                    element.css({ visibility: HIDDEN, display: "" });
                    offset = element.offset();
                    element.css({ visibility: visibility, display: display });
                }

                if (position.top === undefined) {
                    position.top = offset.top;
                }
                if (position.left === undefined) {
                    position.left = offset.left;
                }
            }

            if (!defined(options.visible) || options.visible === null) {
                options.visible = element.is(VISIBLE);
            }

            wrapper = that.wrapper = element.closest(KWINDOW);

            if (!element.is(".k-content") || !wrapper[0]) {
                element.addClass("k-window-content k-content");
                that._createWindow(element, options);
                wrapper = that.wrapper = element.closest(KWINDOW);

                that._dimensions();
            }

            that._position();

            if (options.pinned) {
                that.pin(true);
            }

            if (content) {
                that.refresh(content);
            }

            if (options.visible) {
                that.toFront();
            }

            windowContent = wrapper.children(KWINDOWCONTENT);
            that._tabindex(windowContent);

            if (options.visible && options.modal) {
                that._overlay(wrapper.is(VISIBLE)).css({ opacity: 0.5 });
            }

            wrapper
                .on("mouseenter" + NS, TITLEBAR_BUTTONS, proxy(that._buttonEnter, that))
                .on("mouseleave" + NS, TITLEBAR_BUTTONS, proxy(that._buttonLeave, that))
                .on("click" + NS, "> " + TITLEBAR_BUTTONS, proxy(that._windowActionHandler, that));

            windowContent
                .on("keydown" + NS, proxy(that._keydown, that))
                .on("focus" + NS, proxy(that._focus, that))
                .on("blur" + NS, proxy(that._blur, that));

            this._resizable();

            this._draggable();

            id = element.attr("id");
            if (id) {
                id = id + "_wnd_title";
                wrapper.children(KWINDOWTITLEBAR)
                       .children(KWINDOWTITLE)
                       .attr("id", id);

                windowContent
                    .attr({
                        "role": "dialog",
                        "aria-labelledby": id
                    });
            }

            wrapper.add(wrapper.children(".k-resize-handle," + KWINDOWTITLEBAR))
                    .on("mousedown" + NS, proxy(that.toFront, that));

            that.touchScroller = kendo.touchScroller(element);

            that._resizeHandler = proxy(that._onDocumentResize, that);

            $(window).on("resize", that._resizeHandler);

            if (options.visible) {
                that.trigger(OPEN);
                that.trigger(ACTIVATE);
            }

            kendo.notify(that);
        },

        _buttonEnter: function() {
            $(this).addClass(KHOVERSTATE);
        },

        _buttonLeave: function() {
            $(this).removeClass(KHOVERSTATE);
        },

        _focus: function() {
            this.wrapper.addClass(KFOCUSEDSTATE);
        },

        _blur: function() {
            this.wrapper.removeClass(KFOCUSEDSTATE);
        },

        _dimensions: function() {
            var wrapper = this.wrapper;
            var options = this.options;
            var width = options.width;
            var height = options.height;
            var maxHeight = options.maxHeight;
            var dimensions = ["minWidth","minHeight","maxWidth","maxHeight"];

            this.title(options.title);

            for (var i = 0; i < dimensions.length; i++) {
                var value = options[dimensions[i]];
                if (value && value != Infinity) {
                    wrapper.css(dimensions[i], value);
                }
            }

            if (maxHeight && maxHeight != Infinity) {
                this.element.css("maxHeight", maxHeight);
            }

            if (width) {
                if (width.toString().indexOf("%") > 0) {
                    wrapper.width(width);
                } else {
                    wrapper.width(constrain(width, options.minWidth, options.maxWidth));
                }
            }

            if (height) {
                if (height.toString().indexOf("%") > 0) {
                    wrapper.height(height);
                } else {
                    wrapper.height(constrain(height, options.minHeight, options.maxHeight));
                }
            }

            if (!options.visible) {
                wrapper.hide();
            }
        },

        _position: function() {
            var wrapper = this.wrapper,
                position = this.options.position;

            if (position.top === 0) {
                position.top = position.top.toString();
            }

            if (position.left === 0) {
                position.left = position.left.toString();
            }

            wrapper.css({
                top: position.top || "",
                left: position.left || ""
            });
        },

        _animations: function() {
            var options = this.options;

            if (options.animation === false) {
                options.animation = { open: { effects: {} }, close: { hide: true, effects: {} } };
            }
        },

        _resize: function() {
            kendo.resize(this.element.children());
        },

        _resizable: function() {
            var resizable = this.options.resizable;
            var wrapper = this.wrapper;

            if (this.resizing) {
                wrapper
                    .off("dblclick" + NS)
                    .children(KWINDOWRESIZEHANDLES).remove();

                this.resizing.destroy();
                this.resizing = null;
            }

            if (resizable) {
                wrapper.on("dblclick" + NS, KWINDOWTITLEBAR, proxy(function(e) {
                    if (!$(e.target).closest(".k-window-action").length) {
                        this.toggleMaximization();
                    }
                }, this));

                each("n e s w se sw ne nw".split(" "), function(index, handler) {
                    wrapper.append(templates.resizeHandle(handler));
                });

                this.resizing = new WindowResizing(this);
            }

            wrapper = null;
        },

        _draggable: function() {
            var draggable = this.options.draggable;

            if (this.dragging) {
                this.dragging.destroy();
                this.dragging = null;
            }
            if (draggable) {
                this.dragging = new WindowDragging(this, draggable.dragHandle || KWINDOWTITLEBAR);
            }
        },

        setOptions: function(options) {
            Widget.fn.setOptions.call(this, options);
            this._animations();
            this._dimensions();
            this._position();
            this._resizable();
            this._draggable();
        },

        events:[
            OPEN,
            ACTIVATE,
            DEACTIVATE,
            CLOSE,
            REFRESH,
            RESIZE,
            DRAGSTART,
            DRAGEND,
            ERROR
        ],

        options: {
            name: "Window",
            animation: {
                open: {
                    effects: { zoom: { direction: "in" }, fade: { direction: "in" } },
                    duration: 350
                },
                close: {
                    effects: { zoom: { direction: "out", properties: { scale: 0.7 } }, fade: { direction: "out" } },
                    duration: 350,
                    hide: true
                }
            },
            title: "",
            actions: ["Close"],
            autoFocus: true,
            modal: false,
            resizable: true,
            draggable: true,
            minWidth: 90,
            minHeight: 50,
            maxWidth: Infinity,
            maxHeight: Infinity,
            pinned: false,
            position: {},
            content: null,
            visible: null,
            height: null,
            width: null,
            appendTo: "body"
        },

        _closable: function() {
            return $.inArray("close", $.map(this.options.actions, function(x) { return x.toLowerCase(); })) > -1;
        },

        _keydown: function(e) {
            var that = this,
                options = that.options,
                keys = kendo.keys,
                keyCode = e.keyCode,
                wrapper = that.wrapper,
                offset, handled,
                distance = 10,
                isMaximized = that.options.isMaximized,
                newWidth, newHeight, w, h;

            if (e.target != e.currentTarget || that._closing) {
                return;
            }

            if (keyCode == keys.ESC && that._closable()) {
                that._close(false);
            }

            if (options.draggable && !e.ctrlKey && !isMaximized) {
                offset = kendo.getOffset(wrapper);

                if (keyCode == keys.UP) {
                    handled = wrapper.css("top", offset.top - distance);
                } else if (keyCode == keys.DOWN) {
                    handled = wrapper.css("top", offset.top + distance);
                } else if (keyCode == keys.LEFT) {
                    handled = wrapper.css("left", offset.left - distance);
                } else if (keyCode == keys.RIGHT) {
                    handled = wrapper.css("left", offset.left + distance);
                }
            }

            if (options.resizable && e.ctrlKey && !isMaximized) {
                if (keyCode == keys.UP) {
                    handled = true;
                    newHeight = wrapper.height() - distance;
                } else if (keyCode == keys.DOWN) {
                    handled = true;
                    newHeight = wrapper.height() + distance;
                } if (keyCode == keys.LEFT) {
                    handled = true;
                    newWidth = wrapper.width() - distance;
                } else if (keyCode == keys.RIGHT) {
                    handled = true;
                    newWidth = wrapper.width() + distance;
                }

                if (handled) {
                    w = constrain(newWidth, options.minWidth, options.maxWidth);
                    h = constrain(newHeight, options.minHeight, options.maxHeight);

                    if (!isNaN(w)) {
                        wrapper.width(w);
                        that.options.width = w + "px";
                    }
                    if (!isNaN(h)) {
                        wrapper.height(h);
                        that.options.height = h + "px";
                    }

                    that.resize();
                }
            }

            if (handled) {
                e.preventDefault();
            }
        },

        _overlay: function (visible) {
            var overlay = this.appendTo.children(KOVERLAY),
                wrapper = this.wrapper;

            if (!overlay.length) {
                overlay = $("<div class='k-overlay' />");
            }

            overlay
                .insertBefore(wrapper[0])
                .toggle(visible)
                .css(ZINDEX, parseInt(wrapper.css(ZINDEX), 10) - 1);

            return overlay;
        },

        _actionForIcon: function(icon) {
            var iconClass = /\bk-i-\w+\b/.exec(icon[0].className)[0];

            return {
                "k-i-close": "_close",
                "k-i-maximize": "maximize",
                "k-i-minimize": "minimize",
                "k-i-restore": "restore",
                "k-i-refresh": "refresh",
                "k-i-pin": "pin",
                "k-i-unpin": "unpin"
            }[iconClass];
        },

        _windowActionHandler: function (e) {
            if (this._closing) {
                return;
            }

            var icon = $(e.target).closest(".k-window-action").find(".k-icon");
            var action = this._actionForIcon(icon);

            if (action) {
                e.preventDefault();
                this[action]();
                return false;
            }
        },

        _modals: function() {
            var that = this;

            var zStack = $(KWINDOW).filter(function() {
                var dom = $(this);
                var object = that._object(dom);
                var options = object && object.options;

                return options && options.modal && options.visible && dom.is(VISIBLE);
            }).sort(function(a, b){
                return +$(a).css("zIndex") - +$(b).css("zIndex");
            });

            that = null;

            return zStack;
        },

        _object: function(element) {
            var content = element.children(KWINDOWCONTENT);

            return content.data("kendoWindow") || content.data("kendo" + this.options.name);
        },

        center: function () {
            var that = this,
                position = that.options.position,
                wrapper = that.wrapper,
                documentWindow = $(window),
                scrollTop = 0,
                scrollLeft = 0,
                newTop, newLeft;

            if (that.options.isMaximized) {
                return that;
            }

            if (!that.options.pinned) {
                scrollTop = documentWindow.scrollTop();
                scrollLeft = documentWindow.scrollLeft();
            }

            newLeft = scrollLeft + Math.max(0, (documentWindow.width() - wrapper.width()) / 2);
            newTop = scrollTop + Math.max(0, (documentWindow.height() - wrapper.height() - parseInt(wrapper.css("paddingTop"), 10)) / 2);

            wrapper.css({
                left: newLeft,
                top: newTop
            });

            position.top = newTop;
            position.left = newLeft;

            return that;
        },

        title: function (text) {
            var that = this,
                wrapper = that.wrapper,
                options = that.options,
                titleBar = wrapper.children(KWINDOWTITLEBAR),
                title = titleBar.children(KWINDOWTITLE),
                titleBarHeight = titleBar.outerHeight();

            if (!arguments.length) {
                return title.text();
            }

            if (text === false) {
                wrapper.addClass("k-window-titleless");
                titleBar.remove();
            } else {
                if (!titleBar.length) {
                    wrapper.prepend(templates.titlebar(extend(templates, options)));
                }

                wrapper.css("padding-top", titleBarHeight);
                titleBar.css("margin-top", -titleBarHeight);
            }

            title.text(text);
            that.options.title = text;

            return that;
        },

        content: function (html) {
            var content = this.wrapper.children(KWINDOWCONTENT),
                scrollContainer = content.children(".km-scroll-container");

            content = scrollContainer[0] ? scrollContainer : content;

            if (!defined(html)) {
                return content.html();
            }

            kendo.destroy(this.element.children());

            content.empty().html(html);
            return this;
        },

        open: function () {
            var that = this,
                wrapper = that.wrapper,
                options = that.options,
                showOptions = options.animation.open,
                contentElement = wrapper.children(KWINDOWCONTENT),
                overlay;

            if (!that.trigger(OPEN)) {
                if (that._closing) {
                    wrapper.kendoStop(true, true);
                }

                that._closing = false;

                that.toFront();

                if (options.autoFocus) {
                    that.element.focus();
                }

                options.visible = true;

                if (options.modal) {
                    overlay = that._overlay(false);

                    overlay.kendoStop(true, true);

                    if (showOptions.duration && kendo.effects.Fade) {
                        var overlayFx = kendo.fx(overlay).fadeIn();
                        overlayFx.duration(showOptions.duration || 0);
                        overlayFx.endValue(0.5);
                        overlayFx.play();
                    } else {
                        overlay.css("opacity", 0.5);
                    }

                    overlay.show();
                }

                if (!wrapper.is(VISIBLE)) {
                    contentElement.css(OVERFLOW, HIDDEN);
                    wrapper.show().kendoStop().kendoAnimate({
                        effects: showOptions.effects,
                        duration: showOptions.duration,
                        complete: proxy(this._activate, this)
                    });
                }
            }

            if (options.isMaximized) {
                that._documentScrollTop = $(document).scrollTop();
                $("html, body").css(OVERFLOW, HIDDEN);
            }

            return that;
        },

        _activate: function() {
            if (this.options.autoFocus) {
                this.element.focus();
            }
            this.trigger(ACTIVATE);
            this.wrapper.children(KWINDOWCONTENT).css(OVERFLOW, "");
        },

        _removeOverlay: function(suppressAnimation) {
            var modals = this._modals();
            var options = this.options;
            var hideOverlay = options.modal && !modals.length;
            var overlay = options.modal ? this._overlay(true) : $(undefined);
            var hideOptions = options.animation.close;

            if (hideOverlay) {
                if (!suppressAnimation && hideOptions.duration && kendo.effects.Fade) {
                    var overlayFx = kendo.fx(overlay).fadeOut();
                    overlayFx.duration(hideOptions.duration || 0);
                    overlayFx.startValue(0.5);
                    overlayFx.play();
                } else {
                    this._overlay(false).remove();
                }
            } else if (modals.length) {
                this._object(modals.last())._overlay(true);
            }
        },

        _close: function(systemTriggered) {
            var that = this,
                wrapper = that.wrapper,
                options = that.options,
                showOptions = options.animation.open,
                hideOptions = options.animation.close;

            if (wrapper.is(VISIBLE) && !that.trigger(CLOSE, { userTriggered: !systemTriggered })) {
                that._closing = true;
                options.visible = false;

                $(KWINDOW).each(function(i, element) {
                    var contentElement = $(element).children(KWINDOWCONTENT);

                    // Remove overlay set by toFront
                    if (element != wrapper && contentElement.find("> ." + KCONTENTFRAME).length > 0) {
                        contentElement.children(KOVERLAY).remove();
                    }
                });

                this._removeOverlay();

                wrapper.kendoStop().kendoAnimate({
                    effects: hideOptions.effects || showOptions.effects,
                    reverse: hideOptions.reverse === true,
                    duration: hideOptions.duration,
                    complete: proxy(this._deactivate, this)
                });
            }

            if (that.options.isMaximized) {
                $("html, body").css(OVERFLOW, "");
                if (that._documentScrollTop && that._documentScrollTop > 0) {
                    $(document).scrollTop(that._documentScrollTop);
                }
            }
        },

        _deactivate: function() {
            this.wrapper.hide().css("opacity","");
            this.trigger(DEACTIVATE);
            var lastModal = this._object(this._modals().last());
            if (lastModal) {
                lastModal.toFront();
            }
        },

        close: function () {
            this._close(true);
            return this;
        },

        _actionable: function(element) {
            return $(element).is(TITLEBAR_BUTTONS + "," + TITLEBAR_BUTTONS + " .k-icon,:input,a");
        },

        _shouldFocus: function(target) {
            var active = activeElement(),
                element = this.element;

            return this.options.autoFocus &&
                    !$(active).is(element) &&
                    !this._actionable(target) &&
                    (!element.find(active).length || !element.find(target).length);
        },

        toFront: function (e) {
            var that = this,
                wrapper = that.wrapper,
                currentWindow = wrapper[0],
                zIndex = +wrapper.css(ZINDEX),
                originalZIndex = zIndex,
                target = (e && e.target) || null;

            $(KWINDOW).each(function(i, element) {
                var windowObject = $(element),
                    zIndexNew = windowObject.css(ZINDEX),
                    contentElement = windowObject.children(KWINDOWCONTENT);

                if (!isNaN(zIndexNew)) {
                    zIndex = Math.max(+zIndexNew, zIndex);
                }

                // Add overlay to windows with iframes and lower z-index to prevent
                // trapping of events when resizing / dragging
                if (element != currentWindow && contentElement.find("> ." + KCONTENTFRAME).length > 0) {
                    contentElement.append(templates.overlay);
                }
            });

            if (!wrapper[0].style.zIndex || originalZIndex < zIndex) {
                wrapper.css(ZINDEX, zIndex + 2);
            }
            that.element.find("> .k-overlay").remove();

            if (that._shouldFocus(target)) {
                that.element.focus();

                var scrollTop = $(window).scrollTop(),
                    windowTop = parseInt(wrapper.position().top, 10);

                if (windowTop > 0 && windowTop < scrollTop) {
                    if (scrollTop > 0) {
                        $(window).scrollTop(windowTop);
                    } else {
                        wrapper.css("top", scrollTop);
                    }
                }
            }

            wrapper = null;

            return that;
        },

        toggleMaximization: function () {
            if (this._closing) {
                return this;
            }

            return this[this.options.isMaximized ? "restore" : "maximize"]();
        },

        restore: function () {
            var that = this;
            var options = that.options;
            var minHeight = options.minHeight;
            var restoreOptions = that.restoreOptions;

            if (!options.isMaximized && !options.isMinimized) {
                return that;
            }

            if (minHeight && minHeight != Infinity) {
                that.wrapper.css("min-height", minHeight);
            }

            that.wrapper
                .css({
                    position: options.pinned ? "fixed" : "absolute",
                    left: restoreOptions.left,
                    top: restoreOptions.top,
                    width: restoreOptions.width,
                    height: restoreOptions.height
                })
                .removeClass(MAXIMIZEDSTATE)
                .find(".k-window-content,.k-resize-handle").show().end()
                .find(".k-window-titlebar .k-i-restore").parent().remove().end().end()
                .find(MINIMIZE_MAXIMIZE).parent().show().end().end()
                .find(PIN_UNPIN).parent().show();

            that.options.width = restoreOptions.width;
            that.options.height = restoreOptions.height;

            $("html, body").css(OVERFLOW, "");
            if (this._documentScrollTop && this._documentScrollTop > 0) {
                $(document).scrollTop(this._documentScrollTop);
            }

            options.isMaximized = options.isMinimized = false;

            that.resize();

            return that;
        },

        maximize: sizingAction("maximize", function() {
            var that = this,
                wrapper = that.wrapper,
                position = wrapper.position();

            extend(that.restoreOptions, {
                left: position.left,
                top: position.top
            });

            wrapper.css({
                    left: 0,
                    top: 0,
                    position: "fixed"
                })
                .addClass(MAXIMIZEDSTATE);

            this._documentScrollTop = $(document).scrollTop();
            $("html, body").css(OVERFLOW, HIDDEN);

            that.options.isMaximized = true;

            that._onDocumentResize();
        }),

        minimize: sizingAction("minimize", function() {
            var that = this;

            that.wrapper.css({
                height: "",
                minHeight: ""
            });

            that.element.hide();

            that.options.isMinimized = true;
        }),

        pin: function(force) {
            var that = this,
                win = $(window),
                wrapper = that.wrapper,
                top = parseInt(wrapper.css("top"), 10),
                left = parseInt(wrapper.css("left"), 10);

            if (force || !that.options.pinned && !that.options.isMaximized) {
                wrapper.css({position: "fixed", top: top - win.scrollTop(), left: left - win.scrollLeft()});
                wrapper.children(KWINDOWTITLEBAR).find(KPIN).addClass("k-i-unpin").removeClass("k-i-pin");

                that.options.pinned = true;
            }
        },

        unpin: function() {
            var that = this,
                win = $(window),
                wrapper = that.wrapper,
                top = parseInt(wrapper.css("top"), 10),
                left = parseInt(wrapper.css("left"), 10);

            if (that.options.pinned && !that.options.isMaximized) {
                wrapper.css({position: "", top: top + win.scrollTop(), left: left + win.scrollLeft()});
                wrapper.children(KWINDOWTITLEBAR).find(KUNPIN).addClass("k-i-pin").removeClass("k-i-unpin");

                that.options.pinned = false;
            }
        },

        _onDocumentResize: function () {
            var that = this,
                wrapper = that.wrapper,
                wnd = $(window),
                w, h;

            if (!that.options.isMaximized) {
                return;
            }

            w = wnd.width();
            h = wnd.height() - parseInt(wrapper.css("padding-top"), 10);

            wrapper.css({
                    width: w,
                    height: h
                });
            that.options.width = w;
            that.options.height = h;

            that.resize();
        },

        refresh: function (options) {
            var that = this,
                initOptions = that.options,
                element = $(that.element),
                iframe,
                showIframe,
                url;

            if (!isPlainObject(options)) {
                options = { url: options };
            }

            options = extend({}, initOptions.content, options);

            showIframe = defined(initOptions.iframe) ? initOptions.iframe : options.iframe;

            url = options.url;

            if (url) {
                if (!defined(showIframe)) {
                    showIframe = !isLocalUrl(url);
                }

                if (!showIframe) {
                    // perform AJAX request
                    that._ajaxRequest(options);
                } else {
                    iframe = element.find("." + KCONTENTFRAME)[0];

                    if (iframe) {
                        // refresh existing iframe
                        iframe.src = url || iframe.src;
                    } else {
                        // render new iframe
                        element.html(templates.contentFrame(extend({}, initOptions, { content: options })));
                    }

                    element.find("." + KCONTENTFRAME)
                        .unbind("load" + NS)
                        .on("load" + NS, proxy(this._triggerRefresh, this));
                }
            } else {
                if (options.template) {
                    // refresh template
                    that.content(template(options.template)({}));
                }

                that.trigger(REFRESH);
            }

            element.toggleClass("k-window-iframecontent", showIframe);

            return that;
        },

        _triggerRefresh: function() {
            this.trigger(REFRESH);
        },

        _ajaxComplete: function() {
            clearTimeout(this._loadingIconTimeout);
            this.wrapper.find(REFRESHICON).removeClass(LOADING);
        },

        _ajaxError: function (xhr, status) {
            this.trigger(ERROR, { status: status, xhr: xhr });
        },

        _ajaxSuccess: function (contentTemplate) {
            return function (data) {
                if (contentTemplate) {
                    data = template(contentTemplate)(data || {});
                }

                this.content(data);
                this.element.prop("scrollTop", 0);

                this.trigger(REFRESH);
            };
        },

        _showLoading: function() {
            this.wrapper.find(REFRESHICON).addClass(LOADING);
        },

        _ajaxRequest: function (options) {
            this._loadingIconTimeout = setTimeout(proxy(this._showLoading, this), 100);

            $.ajax(extend({
                type: "GET",
                dataType: "html",
                cache: false,
                error: proxy(this._ajaxError, this),
                complete: proxy(this._ajaxComplete, this),
                success: proxy(this._ajaxSuccess(options.template), this)
            }, options));
        },

        destroy: function () {
            if (this.resizing) {
                this.resizing.destroy();
            }

            if (this.dragging) {
                this.dragging.destroy();
            }

            this.wrapper.off(NS)
                .children(KWINDOWCONTENT).off(NS).end()
                .find(".k-resize-handle,.k-window-titlebar").off(NS);

            $(window).off("resize", this._resizeHandler);

            clearTimeout(this._loadingIconTimeout);

            Widget.fn.destroy.call(this);

            this.unbind(undefined);

            kendo.destroy(this.wrapper);

            this._removeOverlay(true);

            this.wrapper.empty().remove();

            this.wrapper = this.appendTo = this.element = $();
        },

        _createWindow: function() {
            var contentHtml = this.element,
                options = this.options,
                iframeSrcAttributes,
                wrapper,
                isRtl = kendo.support.isRtl(contentHtml);

            if (options.scrollable === false) {
                contentHtml.attr("style", "overflow:hidden;");
            }

            wrapper = $(templates.wrapper(options));

            if (options.title !== false) {
                wrapper.append(templates.titlebar(extend(templates, options)));
            }

            // Collect the src attributes of all iframes and then set them to empty string.
            // This seems to fix this IE9 "feature": http://msdn.microsoft.com/en-us/library/gg622929%28v=VS.85%29.aspx?ppud=4
            iframeSrcAttributes = contentHtml.find("iframe:not(.k-content)").map(function() {
                var src = this.getAttribute("src");
                this.src = "";
                return src;
            });

            // Make sure the wrapper is appended to the body only once. IE9+ will throw exceptions if you move iframes in DOM
            wrapper
                .toggleClass("k-rtl", isRtl)
                .appendTo(this.appendTo)
                .append(contentHtml)
                .find("iframe:not(.k-content)").each(function(index) {
                   // Restore the src attribute of the iframes when they are part of the live DOM tree
                   this.src = iframeSrcAttributes[index];
                });

            wrapper.find(".k-window-title")
                .css(isRtl ? "left" : "right", wrapper.find(".k-window-actions").outerWidth() + 10);

            contentHtml.show();

            contentHtml.find("[data-role=editor]").each(function() {
                var editor = $(this).data("kendoEditor");

                if (editor) {
                    editor.refresh();
                }
            });

            wrapper = contentHtml = null;
        }
    });

    templates = {
        wrapper: template("<div class='k-widget k-window' />"),
        action: template(
            "<a role='button' href='\\#' class='k-window-action k-link'>" +
                "<span role='presentation' class='k-icon k-i-#= name.toLowerCase() #'>#= name #</span>" +
            "</a>"
        ),
        titlebar: template(
            "<div class='k-window-titlebar k-header'>&nbsp;" +
                "<span class='k-window-title'>#= title #</span>" +
                "<div class='k-window-actions'>" +
                "# for (var i = 0; i < actions.length; i++) { #" +
                    "#= action({ name: actions[i] }) #" +
                "# } #" +
                "</div>" +
            "</div>"
        ),
        overlay: "<div class='k-overlay' />",
        contentFrame: template(
            "<iframe frameborder='0' title='#= title #' class='" + KCONTENTFRAME + "' " +
                "src='#= content.url #'>" +
                    "This page requires frames in order to show content" +
            "</iframe>"
        ),
        resizeHandle: template("<div class='k-resize-handle k-resize-#= data #'></div>")
    };


    function WindowResizing(wnd) {
        this.owner = wnd;
        this._draggable = new Draggable(wnd.wrapper, {
            filter: KWINDOWRESIZEHANDLES,
            group: wnd.wrapper.id + "-resizing",
            dragstart: proxy(this.dragstart, this),
            drag: proxy(this.drag, this),
            dragend: proxy(this.dragend, this)
        });
    }

    WindowResizing.prototype = {
        dragstart: function (e) {
            var wnd = this.owner;
            var wrapper = wnd.wrapper;

            this.elementPadding = parseInt(wnd.wrapper.css("padding-top"), 10);
            this.initialCursorPosition = kendo.getOffset(wrapper, "position");

            this.resizeDirection = e.currentTarget.prop("className").replace("k-resize-handle k-resize-", "");

            this.initialSize = {
                width: wrapper.width(),
                height: wrapper.height()
            };

            this.containerOffset = kendo.getOffset(wnd.appendTo);

            wrapper
                .append(templates.overlay)
                .children(KWINDOWRESIZEHANDLES).not(e.currentTarget).hide();

            $(BODY).css(CURSOR, e.currentTarget.css(CURSOR));
        },
        drag: function (e) {
            var that = this,
                wnd = that.owner,
                wrapper = wnd.wrapper,
                options = wnd.options,
                direction = that.resizeDirection,
                containerOffset = that.containerOffset,
                initialPosition = that.initialCursorPosition,
                initialSize = that.initialSize,
                newWidth, newHeight,
                windowBottom, windowRight,
                x = Math.max(e.x.location, containerOffset.left),
                y = Math.max(e.y.location, containerOffset.top);

            if (direction.indexOf("e") >= 0) {
                newWidth = x - initialPosition.left;

                wrapper.width(constrain(newWidth, options.minWidth, options.maxWidth));
            } else if (direction.indexOf("w") >= 0) {
                windowRight = initialPosition.left + initialSize.width;
                newWidth = constrain(windowRight - x, options.minWidth, options.maxWidth);

                wrapper.css({
                    left: windowRight - newWidth - containerOffset.left,
                    width: newWidth
                });
            }

            if (direction.indexOf("s") >= 0) {
                newHeight = y - initialPosition.top - that.elementPadding;

                wrapper.height(constrain(newHeight, options.minHeight, options.maxHeight));
            } else if (direction.indexOf("n") >= 0) {
                windowBottom = initialPosition.top + initialSize.height;
                newHeight = constrain(windowBottom - y, options.minHeight, options.maxHeight);

                wrapper.css({
                    top: windowBottom - newHeight - containerOffset.top,
                    height: newHeight
                });
            }

            if (newWidth) {
                wnd.options.width = newWidth + "px";
            }
            if (newHeight) {
                wnd.options.height = newHeight + "px";
            }

            wnd.resize();
        },
        dragend: function (e) {
            var that = this,
                wnd = that.owner,
                wrapper = wnd.wrapper;

            wrapper
                .find(KOVERLAY).remove().end()
                .children(KWINDOWRESIZEHANDLES).not(e.currentTarget).show();

            $(BODY).css(CURSOR, "");

            if (wnd.touchScroller) {
               wnd.touchScroller.reset();
            }
            if (e.keyCode == 27) {
                wrapper.css(that.initialCursorPosition)
                    .css(that.initialSize);
            }

            return false;
        },
        destroy: function() {
            if (this._draggable) {
                this._draggable.destroy();
            }

            this._draggable = this.owner = null;
        }
    };

    function WindowDragging(wnd, dragHandle) {
        this.owner = wnd;
        this._draggable = new Draggable(wnd.wrapper, {
            filter: dragHandle,
            group: wnd.wrapper.id + "-moving",
            dragstart: proxy(this.dragstart, this),
            drag: proxy(this.drag, this),
            dragend: proxy(this.dragend, this),
            dragcancel: proxy(this.dragcancel, this)
        });

        this._draggable.userEvents.stopPropagation = false;
    }

    WindowDragging.prototype = {
        dragstart: function (e) {
            var wnd = this.owner,
                element = wnd.element,
                actions = element.find(".k-window-actions"),
                containerOffset = kendo.getOffset(wnd.appendTo);

            wnd.trigger(DRAGSTART);

            wnd.initialWindowPosition = kendo.getOffset(wnd.wrapper, "position");

            wnd.startPosition = {
                left: e.x.client - wnd.initialWindowPosition.left,
                top: e.y.client - wnd.initialWindowPosition.top
            };

            if (actions.length > 0) {
                wnd.minLeftPosition = actions.outerWidth() + parseInt(actions.css("right"), 10) - element.outerWidth();
            } else {
                wnd.minLeftPosition =  20 - element.outerWidth(); // at least 20px remain visible
            }

            wnd.minLeftPosition -= containerOffset.left;
            wnd.minTopPosition = -containerOffset.top;

            wnd.wrapper
                .append(templates.overlay)
                .children(KWINDOWRESIZEHANDLES).hide();

            $(BODY).css(CURSOR, e.currentTarget.css(CURSOR));
        },

        drag: function (e) {
            var wnd = this.owner,
                position = wnd.options.position,
                newTop = Math.max(e.y.client - wnd.startPosition.top, wnd.minTopPosition),
                newLeft = Math.max(e.x.client - wnd.startPosition.left, wnd.minLeftPosition),
                coordinates = {
                    left: newLeft,
                    top: newTop
                };

            $(wnd.wrapper).css(coordinates);
            position.top = newTop;
            position.left = newLeft;
        },

        _finishDrag: function() {
            var wnd = this.owner;

            wnd.wrapper
                .children(KWINDOWRESIZEHANDLES).toggle(!wnd.options.isMinimized).end()
                .find(KOVERLAY).remove();

            $(BODY).css(CURSOR, "");
        },

        dragcancel: function (e) {
            this._finishDrag();

            e.currentTarget.closest(KWINDOW).css(this.owner.initialWindowPosition);
        },

        dragend: function () {
            this._finishDrag();

            this.owner.trigger(DRAGEND);

            return false;
        },
        destroy: function() {
            if (this._draggable) {
                this._draggable.destroy();
            }

            this._draggable = this.owner = null;
        }
    };

    kendo.ui.plugin(Window);

})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
define('utils/modalutils',["generated/templates", "utils/iconutils", "kendo/kendo.window"], function (JST, iconUtils, kWindow) {

  var RFModal = function (_options) {
    var self = this,
        options = _options || {},
        title = options.title || '',
        $core = options.core || $('body'),
        modalID = options.id ? options.id : '',
        modal = $(JST.rfmodal({

        })),
        screenWidth, screenHeight,
        modalWidth, modalHeight,
        left, top,
        animations, initObjs, animIndex = 0,
        modalWindow, modalBody,
        modalObj;

    $core.append(modal);
    var calculateDimensions = function () {
      screenWidth = $(window).width();
      screenHeight = $(window).height();
      if (!options.fullscreen) {
        modalWidth = options.width || "60%";

        modalHeight = options.height || "60%";
      } else {
        var min = _.min([screenWidth, screenHeight]);

        modalWidth = min;
        modalHeight = min;
      }
    };
    calculateDimensions ();
    modalObj = modal.kendoWindow({
      modal: true,
      width: modalWidth,
      height: modalHeight,
      title: options.title,
      open: function () {
        modal.data("kendoWindow").center();
      },
      activate: function () {
        if (options.shown) {
          options.shown (modal);
          modal.focus();
          $(".rf-icon-maximize").hide();
        }
      },
      close: function () {
        if (options.hidden) {
          options.hidden ();
          $(".rf-icon-maximize").show();
        }
      },
      resizable: true
    }).data("kendoWindow");

    modalObj.center();

    self.destroy = function() {
        modal.data('kendoWindow').destroy();
    };

    // iconUtils.draw(modal, 16, 16);
    // self.body = modal.find('.rfModalBody');
    // self.header = modal.find('.rfModalHeader');
    // self.footer = modal.find('.rfModalFooter');


    // var redraw = function () {

    //   calculateDimensions();

    //   animations = [
    //     'drop-down',
    //     'pull-up',
    //     'peek-left',
    //     'peek-right'
    //   ];

    //   initObjs = [
    //     {
    //       left: (options.fullscreen) ? 0 : left,
    //       top: -((options.fullscreen) ? screenHeight : modalHeight),
    //       width: (options.fullscreen) ? screenWidth : modalWidth,
    //       height: (options.fullscreen) ? screenHeight : modalHeight
    //     },
    //     {
    //       left: (options.fullscreen) ? 0 : left,
    //       top: ((options.fullscreen) ? screenHeight : modalHeight),
    //       width: (options.fullscreen) ? screenWidth : modalWidth,
    //       height: (options.fullscreen) ? screenHeight : modalHeight
    //     },
    //     {
    //       left: -((options.fullscreen) ? screenWidth : modalWidth),
    //       top: (options.fullscreen) ? 0 : top,
    //       width: (options.fullscreen) ? screenWidth : modalWidth,
    //       height: (options.fullscreen) ? screenHeight : modalHeight
    //     },
    //     {
    //       left: ((options.fullscreen) ? screenWidth : modalWidth),
    //       top: (options.fullscreen) ? 0 : top,
    //       width: (options.fullscreen) ? screenWidth : modalWidth,
    //       height: (options.fullscreen) ? screenHeight : modalHeight
    //     }

    //   ];

    //   $core.append(modal);

    //   modal.show();

    //   modalWindow = modal.find('.rfModalWindow');

    //   modal.find('.cover').on('click', function () {
    //     self.close();
    //   });

    //   $('body').bind('keydown.modal', function (ev) {
    //     if (ev.which === 27) {
    //       self.close();
    //     }
    //   });

    //   modalBody = modal.find('.rfModalBody');

    //   if (options.animate) {

    //     var initPosition = initObjs[_.indexOf(animations, options.animate)];

    //     if (typeof initPosition === 'undefined') {
    //       console.error('no such animation function [ ' + options.animate + ' ]');
    //       modal.remove();
    //       return;
    //     }

    //     modalWindow.css(initPosition);

    //     modalWindow.animate({
    //       left: (options.fullscreen) ? (screenWidth / 2 - modalWidth / 2) : left,
    //       top: (options.fullscreen) ? (screenHeight / 2 - modalHeight / 2) : top,
    //       width: modalWidth,
    //       height: modalHeight
    //     }, 500);
    //   } else {

    //     modalWindow.css({
    //       left: left,
    //       top: top,
    //       width: modalWidth,
    //       height: modalHeight
    //     });

    //   }

    //   if (options.html) {
    //     self.body.html(options.html);
    //   }


    //   if (options.buttons) {
    //     for (var i = 0; i < options.buttons.length; i++) {
    //       (function (i) {
    //         var button = options.buttons[i];
    //         var caption = button.caption || 'button';
    //         var cls = button.cls || '';

    //         var $btn = $('<button/>').text(caption).addClass(cls);

    //         self.footer.append($btn);

    //         if (button.events) {
    //           var events = _.keys(button.events);
    //           for (var j = 0; j < events.length; j++) {
    //             var key = events[j];
    //             $btn.on(key, button.events[key]);
    //           }
    //         }
    //       })(i);
    //     }
    //   }

    //   modalBody.width(modalWidth);
    //   modalBody.height(modalHeight - modal.find('.rfModalHeader').height() - modal.find('.rfModalFooter').height());
    //   // debugger
    // };


    // var reposition = function () {

    //   calculateDimensions();

    //   modalWindow.css({
    //     left: left,
    //     top: top,
    //     width: modalWidth,
    //     height: modalHeight
    //   });

    //   modalWindow.hide();
    //   modalBody.width(modalWidth);
    //   modalBody.height(modalHeight - modal.find('.rfModalHeader').height() - modal.find('.rfModalFooter').height());
    //   modalWindow.show();
    // };

    // redraw();

    // if (options.shown) {
    //   options.shown(modalBody);
    // }

    // modal.find('.closeButton').on('click', function () {
    //   modal.hide();
    //   modal.remove();

    //   $(window).off('resize.modal');

    //   if (options.hidden) {
    //     options.hidden();
    //   }
    // });

    // self.close = function () {
    //   modal.hide();
    //   modal.remove();
    //   $('body').unbind('keydown.modal');

    //   $(window).off('resize.modal');

    //   if (options.hidden) {
    //     options.hidden();
    //   }
    // };

    // var redrawDebounced = _.debounce(function () {
    //   reposition();
    // }, 150);


    // $(window).on('resize.modal', function () {
    //   var h = $(window).height(), w = $(window).width();
    //   options.animate = '';
    //   if (h !== screenHeight || w !== screenWidth) {
    //     redrawDebounced();
    //   }
    // });
    // 
  };

  return RFModal;
});

define ('utils/assert',['vendor/lodash'], function (_) {
  var assert = {
    isType: function (obj, typeName, name, type, errorTrap) {
      var validFlag = false;
      switch(typeName) {
        case 'string':
          validFlag = _.isString(obj);
          break;
        case 'array':
          validFlag = _.isArray(obj);
          break;
        case 'number':
          validFlag = _.isNumber(obj) && !_.isNaN(obj);
          break;
        case 'object':
          validFlag = _.isObject(obj);
          break;
        case 'identifier_string':
          validFlag = (_.isString(obj) && !!obj.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/));
          break;
      }
      if(!validFlag) {
        if(typeof(errorTrap.pro) !== "undefined") {
          if(typeof(errorTrap.pro.handleError) !== "undefined") {
            errorTrap.pro.handleError("Expected parameter '" + name + "' to be '" + typeName + "'. Got '" + typeof(obj) + "' instead.", type, 'assert');
          }
        }
      }
    },

    isString: function (obj, name, type, errorTrap) {
      assert.isType (obj, 'string', name, type, errorTrap);
    },
    isArray: function (obj, name, type, errorTrap) {
      assert.isType (obj, 'array', name, type, errorTrap);
    },
    isNumber: function (obj, name, type, errorTrap) {
      assert.isType (obj, 'number', name, type, errorTrap);
    },
    isIDString: function (obj, name, type, errorTrap) {
      assert.isType (obj, 'identifier_string', name, type, errorTrap);
    }
  };

  return assert;
});

define ('utils/resizewatcher',[
	"constants/componentconstants"
], function (ComponentConstants) {
	var callBacks = [],
		currentWidths = [],
		containers = [],
		isResizeWatcher = false,
		resizeWatchDelay = ComponentConstants.dashboard.resizeDelay,
		newWidth = 0,

		ResizeWatcher = {
			require: function () {
				for (var i = 0; i < containers.length; i++) {
					newWidth = containers[i].width();
					if (currentWidths[i] !== newWidth) {
						currentWidths[i] = newWidth;
						callBacks[i]();
					}
				}

				_.defer(function () {
		          _.delay(ResizeWatcher.require, resizeWatchDelay);
		        });
			},

			checkResize: function () {
				if (!isResizeWatcher) {
					ResizeWatcher.require();
					isResizeWatcher = true;
				}
			},

			register: function (container, cWidth, cb) {
				containers.push(container);
				currentWidths.push(cWidth);
				callBacks.push(cb);
			},

			dispose: function () {
				containers = [];
				currentWidths = [];
				callBacks = [];
			}
		};

	return ResizeWatcher;
});

define('messages/errormessages',[], function () {
  return {
    "1000": "Please add a series with addSeries",
    "1001": "Please set the labels with setLabels",
    "1002": "Please lock component before unlocking it",
    "1003": "Please set dimension with setDimensions",
    "1004": "Please add column with addColumn",
    "1006": "Array size doesnot match"
  };
});

define('utils/errorutils',["messages/errormessages"], function (ErrorMessages) {
	var errorUtils = {
		getError: function (code) {
			code = "" + (+code);
			if(ErrorMessages.hasOwnProperty(code)) {
				return "Error " + code + ":" + ErrorMessages[code];
			}
			return "Error: " + code;
		}
	};

	return errorUtils;
});
define('utils/valueoverrider',['vendor/lodash'], function(_) {

    var valueoverrider = {

      validate: function(cObj) {

       if(cObj.type === 'ChartComponent') {
        validations.run('chartComponent', cObj);
       } 

      }

    };

    var validations = {

      chartComponent: {

        series: function(componentObj) {

          // Overrides string values in series data to be null
          var series = componentObj.props.chart.series;
          var tempData;
          var dataIncorrect;
          for(var key in series) {
            tempData = _.pluck(componentObj.data, key);
            _.each(tempData, function(value, index) {
              if(_.isString(value)) {
                dataIncorrect = componentObj.data[index][key];
                componentObj.data[index][key] = null;

              }
            });
          }

        }

      },

      run: function(key, cObj) {
        for(var i in validations[key]) {
          validations[key][i](cObj);
        }
      }

    };

    return valueoverrider;
});

/*jshint -W083 */
define('components/component',[
  "core/rfclass",
  "data/datasource",
  "utils/media",
  "utils/modalutils",
  "utils/componentutils",
  "utils/assert",
  "utils/positionutils",
  "utils/resizewatcher",
  "utils/ajaxwrapper",
  "helpers/mediahelper",
  "utils/errorutils",
  "vendor/lodash",
  "utils/valueoverrider"
], function (RFClass, DataSource, MediaUtils, ModalUtils, componentUtils, Assert, positionUtils, ResizeWatcher, AjaxWrapper, MediaHelper, errorUtils, _, ValueOverrider) {
  /**
   * Base Component Class containing functions shared across all components.
   *
   * **This is an abstract class. You cannot create instances of this.**
   * @class  Component
   */
  function Component(_id) {
    RFClass.call(this);
    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        _bp = {},
        pro = self.pro,
        id = _id || componentUtils.idGen(),
        currentWidth = null,
        componentModal = null;
        
    Public = {
      /**
       * Sets the location of the component in the dashboard
       * @access private
       * 
       * @param  {Number} x x position
       * @param  {Number} y y position
       * @param  {Number} w width
       * @param  {Number} h height
       */
      setLocation: function (x, y, w, h) {
        if (typeof x !== "number" && typeof x === 'object' && typeof y === 'undefined') {
          pro.pb.setObjectAtPath('core.location', x);
          return;
        }

        pro.pb.setObjectAtPath('core.location', {
          lg: {
            x: x || 0,
            y: y || 0,
            w: w || 0,
            h: h || 0
          }
        });
      },

      /**
       * Set the dimensions of the component. The dimensions are based on a 12-column grid
       * @method  setDimensions
       * @param  {Number} w width of the component in units
       * @param  {Number} h height of the component in units
       */
      setDimensions: function (w, h) {
        self.setLocation(0, 0, w, h);
      },

      /**
       * Set the caption of this component which is the text displayed on top of the component.
       * @method setCaption
       * @param {String} captionString caption text to be displayed on the component
       */
      setCaption: function (captionString) {
        pro.pb.setValue("core.caption", captionString);
      },

      setComponentIcon: function(id, props) {
        pro.pb.setValue("core.icon", id);
        pro.pb.setValue("core.iconprops", JSON.stringify(props || {}));
      },

      /**
      * Sets the index of the component on the dashboard. The component order on the dashboard is based on this index.
      * @method overrideDisplayOrderIndex
      * @param {Number} idx The index for this component
      */
      overrideDisplayOrderIndex: function(idx) {
        pro.pb.setValue("core.index", idx);
      },

      /**
       * Set the value to the key passed for the particular component.
       * @method setOption
       * @param {String} key variable which needs to be assigned
       * @param {Object} value value to be assigned to the key
       */
      setOption: function (key, value) {
        if(key === "breadcrumbStartString") {
          pro.pb.setValue("core.breadcrumbStartString", value);
          return true;
        }

        if(pro.cobjSetOption (key, value)) {
          return true;
        }
        return false;
      },

      /**
       * Temporarily pauses all changes to the component and displays a 'loading' spinner.
       * Use 'unlock' to resume drawing the component.
       * All functions that you call on this component will only take affect when 'unlock' is called.
       * @method lock
       */
      lock: function () {
        pro.lockedFlag = true;
        pro.showLoadingScreen();
      },

      /**
       * Continue normal behaviour of the component.
       * Any changes made during the component is locked is now applied.
       * @method unlock
       */
      unlock: function () {
        if (pro.lockedFlag  === true) {
          pro.lockedFlag = false;
          pro.hideLoadingScreen();
          if (pro.needsRedrawFlag === true) {
            pro.redraw();
          }
        }
        else {
          pro.lockedFlag = false;
          pro.handleWarning("Unlock called before locking");
          return;
        }
      },

      /**
       * Add a simple Key Performance Indicator (KPI/Metric) attached to the
       * bottom of the component.
       * 
       * @param {String} id A unique ID to identify the component KPI
       * @param {ComponentKPIProperties} options caption text to be displayed on the component
       * 
       * @method addComponentKPI
       */
      addComponentKPI: function (_id, opts) {
        opts = opts || {};
        _id = id + _id;
        pro.pb.addItemToList('kpis', _id, opts);
      },


      /**
       * Update the component KPI
       *
       * @param {String} id A unique ID to identify the component KPI. This has to be the same as the one used to add the component kpi
       * @method updateComponentKPI
       */
      updateComponentKPI: function (_id, opts) {
        opts = opts || {};
        _id = id + _id;
        var kpis = pro.pb.getObjectAtPath('kpis'),
            kpi = kpis[_id];
        opts.caption = kpis[_id].caption;
        opts = _.extend(kpi, opts);
        pro.pb.addItemToList('kpis', _id, opts);
      },

      /**
       * Update the component KPI
       *
       * @param {String} id A unique ID to identify the component KPI. This has to be the same as the one used to add the component kpi
       * @method removeComponentKPI
       */
      removeComponentKPI: function (_id) {
        var list = pro.pb.getObjectAtPath('kpis');
        _id = id + _id;
        list[_id] = undefined;
        delete list[_id];
        pro.pb.emptyList('kpis');
        pro.pb.setObjectAtPath('kpis', list);
      },

      /**
       * Check if the component is locked
       * @method isLocked
       * @returns {boolean|*}
       */
      isLocked: function () {
        return pro.lockedFlag;
      },

      /**
       * Reset the state of the component except the position/location
       * @method reset
       */
      reset: function () {

      },
      /**
       * Set the id for this component
       * @method setID
       * @param  {String} _id a unique string which represents the component in a dashboard
       */
      setID: function (_id) {
        id = _id;
      },
      /**
       * Get the id for this component
       * @method getID
       * @returns  {String} _id The id which is set
       */
      getID: function () {
        return id;
      },
      /**
       * Removes this component from the dashboard
       */
      removeFromDashboard: function() {
        pro.db.removeComponent(self);
      },

      renderTo: function ($jqDiv) {
        var dbWidth, cssObj = {}, cContainer,
            _$jqDiv = $("#" + $jqDiv);
        pro.showCaption = false;
        pro.init();
        pro.setTargetContainer(_$jqDiv);
        cContainer = pro.$container;
        pro.integratedFlag = true;
        pro.render();
        pro.resize(cContainer.width(), cContainer.height());
        currentWidth = cContainer.width();
        resizeWatcherLocal();
      },

     /**
     * Hides a component from the dashboard
     * @method hideComponent
     */
      hideComponent: function() {
        pro.pb.setValue("core.isHidden", true);
      },

     /**
     * Show a hidden component in a modal
     * @method showAsModal
     */
      showAsModal: function() {
        pro.pb.setValue("core.showModal", true);
      }
    };

    Protected = {
      /**
       * The propertybase object for this component
       */
      pb: null,

      firstRender: true,

      /**
       * The datasource for this component
       */
      ds: null,
      /**
       * The dashboard that's containing this component
       */
      db: null,
      /**
       * The container div that will be used to render the container
       */
      $container: null,

      /**
       * The core div of the component to render to
       */
      $core: null,

      /**
       * An instance of the renderer.
       */
      renderer: null,

      /**
       * A snapshot of the properties of the component for reference.
       */
      props: {},

      /**
       * A list of all of the listneres to specific propertybase
       * options.
       */
      propListeners: [],

      /**
       * Flag to indicate whether the component is locked or not.
       */
      lockedFlag: false,

      /**
       * Flag to indicate whether the component is locked or not.
       */
      needsRedrawFlag: false,

      maximized: false,

      showCaption: true,

      integratedFlag: false,

      error: {
        state: false,
        message: []
      },

      rawComponentFlag: false,

      errMsg: [],

      overriddenDimensions: {
        'sm': {
          w: 12,
          h: 7
        },
        'xs': {
          w: 12,
          h: 12
        },
        'md': {
          w: 6,
          h: 6
        },
        'lg': {
          w: 6,
          h: 6
        }
      },
      /**
       * This function is called only ONCE in the component's lifecycle
       *
       * This function can be used to set up.
       */
      init: function () {
        pro.pb.linkToComponent(self);
        pro.addListeners();
        if(!pro.rawComponentFlag) {
          pro.validate ();
        }
        pro.props = pro.pb.getRootObject ();
        self.trigger("componentOnInitialize");
      },

      showLoadingScreen: function () {
        if (pro.renderer) {
          pro.renderer.showLoadingScreen();
        }
      },

      hideLoadingScreen: function () {
        if (pro.renderer) {
          pro.renderer.hideLoadingScreen();
        }
      },

      /**
       * This simply sets the target div for the component to render to
       */
      setTargetContainer: function ($container) {
        pro.$container = $container;
      },

      applyPatches: function (patches) {
        var props = patches.props,
            data = patches.data;

        // TODO: This is a hack for drilldown functionality for server-side support
        // Needs a better solution
        if(self._raw.className === 'ChartComponent') {
          if(self.pro.isDrillDownable) {
            self.pro.configureRemoteDrilldown();
          }
        }

        for(var i = 0; i < props.length; i++) {
          pro.pb.applyPatch(props[i]);
        }
        if(pro.onApplyPatch) {
          pro.onApplyPatch();
        }
        self.ds.applyPatches(data);
        pro.requestRedraw ();
      },

      requestRedraw: function () {
        pro.needsRedrawFlag = true;
      },

      applyChange: function (type, path, newValue, oldValue, parts) {
        if (pro.lockedFlag) {
          // We cannot apply any change when it's locked.
          // So we simply ignore it and mark that it needs a redraw

          pro.needsRedrawFlag = true;

          if(!pro.pb.getValue('core.isHidden')) {
            return;
          }
        }

        var needsRedraw = true;
        // First, check if any of the paths match the subscribers
        for (var i = 0; i < pro.propListeners.length; i++) {
          var item = pro.propListeners[i];
          var regex = new RegExp(item.path),
              result = regex.exec(path);
          if(result) {
            needsRedraw = item.callback(newValue, oldValue, result);
          }
        }        
        if (needsRedraw) {
          pro.redraw();
        }
      },

      redraw: function () {
        self.trigger("beforeRedraw");
        if (!pro.rawComponentFlag) {
          pro.validate();
        }
        if(pro.renderer) {
          pro.renderer.dispose();
        }
        if(pro.$container) {
          pro.$container.empty();
          pro.render();
          pro.resize();
          self.trigger("redraw");
        }
      },

      addListeners: function () {
        pro.pushListeners([
          {
            path: 'core.showModal',
            callback: showAsModal
          }
        ]);
      },

      pushListeners: function (items) {
        for (var i = 0; i < items.length; i++) {
          pro.propListeners.push(items[i]);
        }
      },

      render: function () {
        if (pro.firstRender) {
          self.trigger("beforeFirstRender");
        }
        self.trigger("beforeRender");
        if (pro.renderer !== null) {
          pro.renderer.dispose();
        }
        var dataError = self.ds.getErrorStatus();
        if(dataError.status) {
          pro.handleError(dataError.msg);
        }
        pro.createRenderer();
        pro.renderer.init({
          shell: self,
          overriddenDimensions: pro.overriddenDimensions,
          props: pro.pb.getRootObject(),
          container: pro.$container,
          locked: pro.lockedFlag,
          error: pro.error.state,
          handleMaximize: handleMaximize,
          maximizeFlag: pro.maximized,
          showCaption: pro.showCaption,
          integratedFlag: pro.integratedFlag
        });

        pro.$core = pro.renderer.renderContainer();

        // The component is locked so set the needsRedrawFlag and return
        if(pro.lockedFlag){
          pro.needsRedrawFlag = true;
          return;
        }

        // This calls the render core function on the CHILD class of COMPONENT not
        // the renderer.
        if(pro.error.state === true) {
          pro.renderer.showErrorMessage (pro.error.message);
        }
        else {
          pro.renderer.hideErrorMessage();
          pro.renderCore();
        }
        if (pro.firstRender) {
          self.trigger("firstRender");
        }
        self.trigger("render");
        pro.firstRender = false;
      },

      validate: function () {
        // TODO validate component level stuff
        var errorCodes = pro.getErrorCodes ();

        if(errorCodes.length > 0) {
          var errorMessages = [];
          for(var i = 0; i < errorCodes.length; i++) {
            errorMessages.push({
              msg: errorUtils.getError(errorCodes[i]),
              type: 'validate'
            });
          }
          pro.showError(errorMessages);
        } else {
         pro.hideError ('validate');
       }
     },

      getErrorCodes: function () {
        return [];
      },

      handleError: function (_msg, type, source) {
        if (type === 'warn') {
          pro.handleWarning(_msg);
          return;
        }
        var errMsg = pro.error.message;
        errMsg.push({
          type: source,
          msg: _msg
        });
        pro.showError (errMsg);
      },

      showError: function (_msg) {
        pro.error.state = true;
        pro.error.message.concat (_msg);
      },

      hideError: function (type) {        
        var newArr = [];
        for(var i=-1; ++i<pro.error.message.length;) {
          if(pro.error.message[i].type != type) {
            newArr.push (pro.error.message[i]);
          }  
        }
        pro.error.message = newArr;
        pro.error.state = !!newArr.length;
      },

      resize: function (width, height) {
        self.trigger("beforeResize");
        pro.renderer.resizeContainer();
        var coreWidth = pro.$core.width(), coreHeight = pro.$core.height();
        
        // The component is locked, so return, don't resize core because core may not exist.
        pro.resizeCore(coreWidth, coreHeight);
        if(pro.lockedFlag || pro.error.state ){
          return;
        }
        pro.resizeCore(coreWidth, coreHeight);
        self.trigger("resize");
      },
      convertToObject: function (_source) {
        var source = _source ? true : false;

        if (pro.preSerialize) {
          pro.preSerialize();
        }
        return {
          props: pro.pb.getRootObject(),
          data: self.ds.getRawData(),
          type: raw.className,
          source: source
        };
      },

      buildFromObject: function (cObj) {
        var isEventSubscribed = !!_.where(cObj.props.events, {"type": "itemClick"}).length;
        if(isEventSubscribed) {
          self.isEventSubscribed = true;
        }

        // Value overriding for certain data for wrappers.
        // May be use this for the js api as well?
        ValueOverrider.validate(cObj);

        pro.pb.setRootObject(cObj.props);
        self.ds.setRawData(cObj.data);

        pro.rawComponentFlag = true;
      },
      onRendererCreate: function() {
        if(self.isEventSubscribed && self._raw.className === "ChartComponent") {
          pro.renderer.itemClickSubscribed();
        }
        
        pro.renderer.linkToDashboard(pro.db);
      },
      _maximize: function (maximizeButton) {
        self.trigger("beforeMaximize");
        if(pro.lockedFlag || pro.error.state) {
          return;
        }

        oldContainer = pro.$container;
        pro.maximized = true;
        var modal = new ModalUtils({
          core: pro.db._getModalDiv(),
          title: pro.pb.getValue('core.caption'),
          fullscreen: pro.getMediaHelper().mediaSelect({"sm+xs":true}, false),
          shown: function (modalBody) {
            pro.$container = modalBody;
            pro.redraw();
          },
          hidden: function () {
            pro.$container = oldContainer;
            pro.maximized = false;
            oldContainer = null;
            pro.redraw();
          }
        });
        self.trigger("maximize");
        self.trigger("componentMaximize");
      },

      handleComponentEvent: function (name, params, index) {
        // TODO: check for local events. Inside the javascript
        var events = pro.pb.getObjectAtPath("events"),
            i=0;

        if(index !== undefined) {
          
          var noItemClickEvents = _.reject(events, function(e) { return e.type === 'itemClick'; });
          var currentItemClick = _.findWhere(events, function(e, i) { return ( e.type === 'itemClick' && index === i ); });
          noItemClickEvents.push(currentItemClick);
          events = noItemClickEvents;
        }

        for (i = 0; i < events.length; i++) {
          var ev = events[i];
          // First, pluck the "id" key from affected components to get a list of ids that are affected
          // Then, for each of the ids, pass it to db.pro.getComponentByID and return this
          // ultimately, it'll return a list of component objects
          var affectedComponents = _.map(_.pluck(ev.affectedComponents, 'id'), pro.db.pro.getComponentByID);
          _.each(affectedComponents, function (val) { 
            val.lock();
           });

          // The postback is an object describing the interesting portion of the dashboard.
          var postback = {'components': {}};
          for(i = 0; i < affectedComponents.length; i++) {
            var cobj = affectedComponents[i];
            var source = (cobj === self) ? true : false;
            postback['components'][cobj.getID()] = cobj.pro.convertToObject(source);
          }
          if(!(_.findWhere(affectedComponents, function(c) { return c === self; }))) {
            postback['components'][self.getID()] = self.pro.convertToObject(true);
          }

          var rfAjax = new AjaxWrapper();
          rfAjax.ajax({
            type: "POST",
            url: ev.url,
            renderer: pro.renderer,
            db: pro.db,
            data: {
              postback: JSON.stringify(postback),
              params: JSON.stringify(params),
              context: ev.context
            },
            success: function(data) {
              if(_.isString(data)) {
                data = JSON.parse(data);
              }
              if(data.patches) {
                for (var key in data.patches) {
                  if(data.patches.hasOwnProperty(key)) {
                    var cobj = pro.db.pro.getComponentByID(key);
                    cobj.pro.applyPatches (data.patches[key]);
                  }
                }
              }

              _.each(affectedComponents, function (val) {
                if(val.pro.lockedFlag) {
                  val.unlock();
                }
              });
            }
          });
        }
      },

      linkToDashboard: function (db) {
        pro.db = db;
      },

      dispose: function () {
        if(pro.renderer) {
          pro.renderer.dispose ();
        }
      },

      getMediaHelper: function () {
        if(pro.db) {
          return pro.db.pro.getMediaHelper();
        }
        return new MediaHelper ();
      }
    };

    var handleMaximize = function () {
      self.pro._maximize (this);
    };

    var construct = function () {
      self.ds = new DataSource();
    };

    var resizeWatcherLocal = function () {
      ResizeWatcher.register(pro.$container, currentWidth, function () {
        pro.resize(pro.$container.width(), pro.$container.height());
      });
      ResizeWatcher.checkResize();
    };

    var showAsModal = function() {

      // Don't show modal if its a mobile
      // if(Modernizr.touch && pro.getMediaHelper().getCurrentMedia() === 'xs'){
      //   return;
      // }

      pro.showCaption = false  ;
      componentModal = new ModalUtils({
        core: pro.db._getModalDiv(),
        title: pro.pb.getValue('core.caption'),
        shown: function (modalBody) {
          pro.$container = modalBody;
          pro.integratedFlag = true;
          pro.redraw();
        },
        hidden: function () {
          pro.$container = null;
          componentModal.destroy();
        }
      });
    };



    raw._registerClassName("Component");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    construct();
  }

  return Component;
});

define('utils/internallayoutmanager',["utils/positionutils", 'vendor/lodash'], function (posUtils, _) {
  var InternalLayoutManager = function (layouts, values) {
    var self = this,
        core = null,
        width = null,
        height = null;

    self.manageElement = function (c) {
      core = c;
      width = core.outerWidth();
      height = core.height();


      for (var i = -1; ++i < layouts.length;) {
        var layout = layouts[i],
            el = $('<div/>'),
            value = values[layout.className],
            elementCssProps = getElementCssProperties(layout),
            elLeft = elementCssProps.elLeft,
            elTop = elementCssProps.elTop,
            elWidth = elementCssProps.elWidth,
            elHeight = elementCssProps.elHeight,
            lines = elementCssProps.lines,
            fontScale = elementCssProps.fontScale,
            maxFontSize = (elHeight * fontScale) / lines,
            minFontSize = elHeight * 0.7,
            cssObj = null;

            _.extend(elementCssProps, {fontSize: maxFontSize});
            cssObj = setCssObj(elementCssProps);

        if (value) {
          adjustCssProps(value, elementCssProps, cssObj);
        }

        el.addClass(layout.className);
        el.css(cssObj);

        el.attr('data-lines', lines);
        el.attr('data-fontScale', fontScale);
        core.append(el);
      }
    };

    self.handleResize = function(w, h){
      width = w;
      height = h;
      for (var i = -1; ++i < layouts.length;) {
        var layout = layouts[i],
          el = core.find("." + layout.className),
          value = values[layout.className],
          elementCssProps = getElementCssProperties(layout),
          elHeight = elementCssProps.elHeight,
          fontScale = elementCssProps.fontScale,
          lines = elementCssProps.lines,
          maxFontSize = (elHeight * fontScale) / lines,
          minFontSize = elHeight * 0.7,
          cssObj = null;

          _.extend(elementCssProps, {fontSize: maxFontSize});
          cssObj = setCssObj(elementCssProps);

        adjustCssProps(value, elementCssProps, cssObj);

        el.css(cssObj);

      }
    };


    self.setValues = function () {
      for (var key in values) {
        if(values.hasOwnProperty(key)){
          core.find("." + key).text(values[key]);
        }
      }
    };

    var setCssObj = function(elementCssProps){
       obj = {
        position: 'absolute',
        top: elementCssProps.elTop,
        left: elementCssProps.elLeft,
        width: elementCssProps.elWidth,
        height: elementCssProps.elHeight,
        textAlign: 'center',
        verticalAlign: 'middle',
        overflow: 'hidden'
      };
      if(!elementCssProps.isGauge) {
        obj.fontSize = elementCssProps.fontSize;
        obj.lineHeight = (elementCssProps.elHeight / elementCssProps.lines) + 'px';
      }
      return obj;
    };

    var getElementCssProperties = function(layout){
      width = core.outerWidth();
      var elWidth = posUtils.unitsToPixels(layout.w, width),
          elHeight = posUtils.unitsToPixels(layout.h, height),
          fontScale = layout.fontScale || 0.7,
          lines = layout.lines || 1;

      return {
        isGauge: layout.className === 'rfKPIGauge',
        elLeft: posUtils.unitsToPixels(layout.x, width),
        elTop: posUtils.unitsToPixels(layout.y, height),
        elWidth: elWidth,
        elHeight: elHeight,
        lines: lines,
        fontScale: fontScale,
        maxFontSize: (elHeight * fontScale) / lines,
        minFontSize: elHeight * 0.7
      };     
    };

    var adjustCssProps = function(value, elementCssProps, cssObj){
          // var tmp = $('<span/>').text(value).css({
          //   fontSize: elementCssProps.maxFontSize,
          //   'white-space': 'nowrap'
          // }), ratio = null;
          // core.append(tmp);

          // if (elementCssProps.lines > 1) {
          //   if (tmp.width() < elementCssProps.elWidth) {
          //     ratio = elementCssProps.elWidth / tmp.width();
          //     ratio = ratio > 1.2 ? 1.2 : ratio;
          //     elementCssProps.fontScale = ratio;
          //     cssObj.fontSize = Math.floor(((elementCssProps.elHeight * ratio) / elementCssProps.lines) * 0.8);
          //     tmp.css('font-size', cssObj.fontSize);
          //     if (tmp.width() < elementCssProps.elWidth) {
          //       cssObj.lineHeight = Math.floor((cssObj.fontSize * 2.4)) + 'px';
          //     } else {
          //       cssObj.lineHeight = Math.floor((cssObj.fontSize * 1.1)) + 'px';
          //     }
          //   }
          // } else {
          //   if (tmp.width() > elementCssProps.elWidth) {
          //     ratio = elementCssProps.elWidth / tmp.width();
          //     ratio = ratio < 0.5 ? 0.5 : ratio;
          //     cssObj.fontSize = Math.floor((elementCssProps.maxFontSize * ratio));
          //     cssObj.lineHeight = elementCssProps.elHeight + 'px';
          //   } else {
          //     ratio = elementCssProps.elWidth / tmp.width();
          //     ratio = ratio > 1.2 ? 1.2 : ratio;
          //     cssObj.fontSize = Math.floor((elementCssProps.maxFontSize * ratio));
          //     cssObj.lineHeight = elementCssProps.elHeight + 'px';
          //   }
          // }
          // tmp.remove();
    };

  };
  return InternalLayoutManager;
});

define('constants/kpilayoutconstants',[], function () {
  var basicKPI = {
    'portrait': [
      {
        x: 1,
        y: 2,
        w: 10,
        h: 3,
        lines: 2,
        fontScale: 0.7,
        className: 'rfKPICaption',
        aspectAdjust: true
      },
      {
        x: 0,
        y: 5,
        w: 12,
        h: 5,
        fontScale: 0.5,
        className: 'rfKPIValue',
        aspectAdjust: true,
        verticalAlign: 'center'
      }
    ],
    'landscape': [
      {
        x: 1,
        y: 2,
        w: 10,
        h: 3,
        lines: 2,
        fontScale: 1,
        className: 'rfKPICaption',
        aspectAdjust: true
      },
      {
        x: 1,
        y: 5,
        w: 10,
        h: 5,
        fontScale: 0.5,
        className: 'rfKPIValue',
        aspectAdjust: true,
        verticalAlign: 'center'
      }
    ],
    'mobile': [
      {
        x: 4.5,
        y: 4.7,
        w: 7.5,
        h: 6,
        lines: 2,
        className: 'rfKPICaption'
      },
      {
        x: 0.5,
        y: 3.5,
        w: 4,
        h: 6,
        fontScale: 0.64,
        className: 'rfKPIValue'
      }
    ]
  };

  var basicGauge = {
    'portrait': [
      {
        x: 1,
        y: 1,
        w: 10,
        h: 3,
        lines: 2,
        fontScale: 1,
        className: 'rfKPICaption'
      },
      {
        x: 2,
        y: 4,
        w: 8,
        h: 8,
        className: 'rfKPIGauge'
      }
    ],
    'landscape': [
      {
        x: 2,
        y: 1,
        w: 8,
        h: 3,
        lines: 2,
        fontScale: 1,
        className: 'rfKPICaption'
      },
      {
        x: 2,
        y: 4,
        w: 8,
        h: 8,
        className: 'rfKPIGauge'
      }
    ],
    'mobile': [
      {
        x: 0.5,
        y: 1,
        w: 4,
        h: 10,
        className: 'rfKPIGauge'
      },
      {
        x: 5,
        y: 4,
        w: 6.5,
        h: 7,
        lines: 2,
        className: 'rfKPICaption'
      }

      // {
      //   x: 5,
      //   y: 6,
      //   w: 6.5,
      //   h: 6,
      //   className: 'rfKPIValue'
      // }
    ]
  };

  var kpiWithSpark = {
    'portrait': [
      {
        x: 1,
        y: 1,
        w: 10,
        h: 3,
        lines: 2,
        fontScale: 1,
        className: 'rfKPICaption'
      },
      {
        x: 2,
        y: 4,
        w: 8,
        h: 4,
        fontScale: 0.7,
        verticalAlign: 'center',
        aspectAdjust: true,
        className: 'rfKPIValue'
      },
      {
        x: 0,
        y: 8.5,
        w: 12,
        h: 3.5,
        className: 'rfKPISpark'
      }

    ],
    'landscape': [
      {
        x: 1,
        y: 1,
        w: 10,
        h: 3,
        lines: 2,
        fontScale: 1,
        className: 'rfKPICaption'
      },
      {
        x: 2,
        y: 4,
        w: 8,
        h: 5,
        className: 'rfKPIValue'
      },
      {
        x: 0,
        y: 9,
        w: 12,
        h: 3,
        className: 'rfKPISpark'
      }
    ],
    'mobile': [
      {
        x: 6.5,
        y: 2,
        w: 5,
        h: 4,
        lines: 2,
        className: 'rfKPICaption'
      },

      {
        x: 0.5,
        y: 3.5,
        w: 4,
        h: 6,
        className: 'rfKPIValue'
      },
      {
        x: 6.5,
        y: 6,
        w: 5,
        h: 6,
        className: 'rfKPISpark'
      }
    ]
  };


  return {
    'basicKPI': basicKPI,
    'basicGauge': basicGauge,
    'kpiWithSpark': kpiWithSpark
  };
});
!function (name, context, definition) {
  if (typeof define == 'function') define('vendor/klass',definition)
  else if (typeof module != 'undefined') module.exports = definition()
  else context[name] = definition()
}('klass', this, function () {
  var context = this
    , f = 'function'
    , fnTest = /xyz/.test(function () {xyz}) ? /\bsupr\b/ : /.*/
    , proto = 'prototype'

  function klass(o) {
    return extend.call(isFn(o) ? o : function () {}, o, 1)
  }

  function isFn(o) {
    return typeof o === f
  }

  function wrap(k, fn, supr) {
    return function () {
      var tmp = this.supr
      this.supr = supr[proto][k]
      var undef = {}.fabricatedUndefined
      var ret = undef
      try {
        ret = fn.apply(this, arguments)
      } finally {
        this.supr = tmp
      }
      return ret
    }
  }

  function process(what, o, supr) {
    for (var k in o) {
      if (o.hasOwnProperty(k)) {
        what[k] = isFn(o[k])
          && isFn(supr[proto][k])
          && fnTest.test(o[k])
          ? wrap(k, o[k], supr) : o[k]
      }
    }
  }

  function extend(o, fromSub) {
    // must redefine noop each time so it doesn't inherit from previous arbitrary classes
    function noop() {}
    noop[proto] = this[proto]
    var supr = this
      , prototype = new noop()
      , isFunction = isFn(o)
      , _constructor = isFunction ? o : this
      , _methods = isFunction ? {} : o
    function fn() {
      if (this.initialize) this.initialize.apply(this, arguments)
      else {
        fromSub || isFunction && supr.apply(this, arguments)
        _constructor.apply(this, arguments)
      }
    }

    fn.methods = function (o) {
      process(prototype, o, supr)
      fn[proto] = prototype
      return this
    }

    fn.methods.call(fn, _methods).prototype.constructor = fn

    fn.extend = arguments.callee
    fn[proto].implement = fn.statics = function (o, optFn) {
      o = typeof o == 'string' ? (function () {
        var obj = {}
        obj[o] = optFn
        return obj
      }()) : o
      process(this, o, supr)
      return this
    }

    return fn
  }

  return klass
});
define('utils/numberformatter',["vendor/lodash", "vendor/klass"], function (_, klass) {

  var NumberFormatter = klass({
    numberPrefix: "",
    numberSuffix: "",
    numberHumanize: null,
    numberThousandsSeparator: null,
    numberDecimalsSeparator: null,
    numberForceDecimals: null,
    numberDecimalPoints: null,

    setConfig: function (c) {
      var config = c;
      if (config.numberFormatFlag === true && config.dataType === "number") {
        if (typeof(config.numberPrefix) === 'string') {
          this.numberPrefix = config.numberPrefix;
        }
        if (typeof(config.numberSuffix) === 'string') {
          this.numberSuffix = config.numberSuffix;
        }
        if (typeof(config.numberHumanize) === 'boolean') {
          this.numberHumanize = config.numberHumanize;
        }
        if (typeof(config.numberThousandsSeparator) === 'string' && !this.numberHumanize) {
          this.numberThousandsSeparator = config.numberThousandsSeparator;
        }
        if (typeof(config.numberDecimalsSeparator) === 'string') {
          this.numberDecimalsSeparator = config.numberDecimalsSeparator;
        }
        if (typeof(config.numberForceDecimals) === 'boolean') {
          this.numberForceDecimals = config.numberForceDecimals;
        }
        if (typeof(config.numberDecimalPoints) === 'number') {
          this.numberDecimalPoints = config.numberDecimalPoints;
        }
      }
    },

    formatValue: function (value) {
      var decimalZeroes = '';

      value = value.toString();

      value = this.numberThousandsSeparator ? this._numberThousandsSeperator(value, this.numberThousandsSeparator, this.numberDecimalsSeparator) : value;
      value = this.numberHumanize ? this._numberHumanize(value) : value;

      for (var i = 0; i < this.numberDecimalPoints; i++) {
        decimalZeroes += '0';
      }
      if(this.numberForceDecimals) {
        if(value.indexOf(this.numberDecimalsSeparator) < 0) {
          value = value + this.numberDecimalsSeparator + decimalZeroes;
        } else {
          var decimalSize = value.split(this.numberDecimalsSeparator)[1].length;
          
          if(decimalSize < this.numberDecimalPoints) {
            value = value + decimalZeroes.slice(0, this.numberDecimalPoints - decimalSize);
          }
        }
      }

      return this.numberPrefix + value + this.numberSuffix;
    },

    formatArray: function (array) {
      var result = [];
      var arrayLen = array.length;
      for (var i = 0; i < arrayLen; i++) {
        result.push(this.formatValue(array[i]));
      }

      return result;
    },

    formatColumn: function (data, key) {
      var rowLen = data.length;
      for (var i = 0; i < rowLen; i++) {
        data[i][key] = this.formatValue(data[i][key]);
      }

      return data;
    },

    splitDecimals: function (value) {
      var num = value.split('.')[0],
          decimal = value.split(',')[1],
          decimalVal = (+decimal) ? ( this.numberDecimalPoints > 0 ? this.numberDecimalsSeparator + decimal.split('').slice(0, this.numberDecimalPoints).join('') : '' )  : '';

      return num + decimalVal;
    },

    _numberHumanize: function (value) {
      var result = '',
          temp = '',
          negative = value < 0;

      value = (Math.floor(Math.abs(+value))).toString();

      if (value === 'NaN') {
        console.error('value is not a number');
        return;
      }

      if (value.length < 4) {
        return value;
      } else if (value.length < 7) {
        temp = (+value / 1000).toString();

        result = this.splitDecimals(temp) + 'K';

      } else if (value.length < 10) {
        temp = (+value / 1000000).toString();

        result = this.splitDecimals(temp) + 'M';
      } else {
        temp = (+value / 1000000000).toString();

        result = this.splitDecimals(temp) + 'B';
      }

      return negative ? '-' + result : result;
    },

    _numberThousandsSeperator: function (value, separator, decimalSeparator) {
      var result = '',
          negative = value < 0,
          temp = (Math.abs(+value)).toString().split('.')[0].split('').reverse().join(''),
          decimal = (Math.abs(+value)).toString().split('.')[1];


      if (temp === 'NaN') {
        console.error('value is not a number');
        return;
      }

      if (value.length < 4) {
        return value;
      }

      while (temp.length >= 4) {
        var tArr = temp.split('');
        result += tArr.splice(0, 3).join('') + separator;

        temp = tArr.join('');
      }

      result += temp;

      result = result.split('').reverse().join('') + ((decimal) ? decimalSeparator + decimal.split('').slice(0, this.numberDecimalPoints).join('') : '');

      return negative ? '-' + result : result;
    }
  })
  .statics({
    pickFirstValid: function (items) {
      var isValid = function (item) {
        var defaults = {
          'numberFormatFlag':true,
          'numberHumanize':false,
          'numberPrefix':null,
          'numberSuffix':null,
          'numberThousandsSeparator':".",
          'numberDecimalsSeparator':",",
          'numberForceDecimals':false,
          'numberDecimalPoints':2
        };
        // FIXME: If any of the defaults are changed this will fail catastrophically.
        // return true if ANY of the items is not the default value
        return _.any(item, function (val, key) {
          return typeof(defaults[key]) !== "undefined" && val !== defaults[key];
        });
      };

      // Return the first item that's determined as valid.
      var result = _.find(items, isValid);
      if(!result) {
        return items[0];
      }
      return result;
    }
  });

  return NumberFormatter;
});

define('razorcharts/utils/colorUtils',['vendor/lodash'], function(_) {
    var colorUtils = {
        darken: function(_color, intensity) {
          var color = Raphael.color(_color);
          return Raphael.hsl(color.h, color.s, color.l * ((100 - intensity) / 100));
        }
    };

    return colorUtils;
});
define('razorcharts/renderers/column',['razorcharts/utils/colorUtils', 'vendor/lodash'], function(colorUtils, _) {
    var ColumnChart = function() {
        // Constants
        var SERIES_PADDING = 0.4,
            COLUMN_PADDING = 0.0,
            paper = null,
            core = null;

        var self = this,    
            options = null,
            columnCore = null,
            seriesGroups = [],
            styles = [
                {
                    fill: '#ff0'
                },
                {
                    fill: '#f0f'
                },
                {
                    fill: '#0ff'
                }
            ],
            seriesPlotItems = [],
            totalLabels = [],
            width = null,
            height = null,
            eventManager = null;

        self.config = function(_options) {
            options = _options;
            eventManager = options.eventManager;

            eventManager.register('plotItemClick');
            eventManager.register('plotItemMouseOver');
            eventManager.register('plotItemMouseOut');
            eventManager.register('plotItemActivate');
        };

        self.renderTo = function (_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            draw(true, true && options.animateOnRender);
            for(var i=-1; ++i<seriesPlotItems.length;) {
                options.tooltip.addSeriesItems(options.series[i].seriesIndex, seriesPlotItems[i]);
            }
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            draw(false, false);
        };

        self.updateSeries = function(w, h) {
            width = w;
            height = h;
            draw(false, true);
        };

        var draw = function (create, animate) {
             var series = options.series,
                dataLength = _.max(_.pluck(_.pluck(series, 'data'), 'length')),
                seriesWidth = (width / dataLength),
                actualSeriesWidth = seriesWidth - seriesWidth * SERIES_PADDING,
                columnWidth = options.stacked ? actualSeriesWidth : (actualSeriesWidth / series.length),
                yScale = options.yScale,
                labels = options.labels,
                padding = columnWidth * COLUMN_PADDING;
            if(create) {
                columnCore = paper.group('rc-column-chart', core);
                columnCore.node.setAttribute('class', 'rc-column-chart');
            }
            for(var i=-1; ++i<series.length;) {
                var data = series[i].data;
                if(create) {
                    seriesGroups[i] = paper.group('column-series-' + (i+1), columnCore);
                    seriesGroups[i].node.setAttribute('class', 'rc-series-' + (series[i].seriesIndex));
                    if(!seriesPlotItems[i]) {
                        seriesPlotItems[i] = [];
                    }
                }
                for(var j=-1; ++j<data.length;) {
                    if(options.dualAxis) {
                        yScale = options.yScale[series[i].yAxis || 'left'];
                    }
                    var _x, _y, _w, _h;
                    _x = (options.stacked) ? (seriesWidth * j) + (seriesWidth / 2) - (columnWidth / 2) + padding  : seriesWidth * j + columnWidth * i + ((seriesWidth * SERIES_PADDING / 2) + padding);
                    if(data[j] > 0) {
                        if(options.stacked) {
                            if(i!==0 && prevIndexTotal(i, j) !== yScale.min()) {
                                _y = ((i - 1 < 0 ) ? height - yScale.calc(data[j] + yScale.min()) : height - yScale.calc(prevIndexTotal(i, j)) - Math.abs(yScale.calc(data[j] + yScale.min()) - yScale.calc(yScale.min())));
                            } else {
                                _y = ((i - 1 < 0 ) ? height - yScale.calc(data[j]) : height - yScale.calc(prevIndexTotal(i, j)) - Math.abs(yScale.calc(data[j]) - yScale.calc(yScale.min())));
                            }
                            
                        } else {
                            _y = height - yScale.calc(data[j]);    
                        }
                        
                    } else {
                        _y = height - yScale.calc(0) + (options.stacked ? Math.abs(yScale.calc(prevIndexTotal(i, j)) - yScale.calc(0)) : 0);
                    }
                    
                    _w = columnWidth - padding * 2;
                    var minTick = yScale.min() < 0 ? yScale.calc(0) : yScale.calc(yScale.min());
                    _h = Math.abs(yScale.calc(data[j]) - minTick);
                    if(options.stacked) {
                        if(i!==0 && prevIndexTotal(i, j) !== yScale.min()) {
                            _h = Math.abs(yScale.calc(data[j] + yScale.min()));
                        }
                    }
                    
                    // if(options.stacked && i !== 0 && data[j] === 59) debugger;
                    var rect = null,
                        classes = (series[i].color === 'auto' ? ' rc-series-' + series[i].seriesIndex + ' rc-plot-item' : '') + ' ' + (options.plotItemClasses || '');

                    if(create) {
                        rect = paper.rect(_x, height - yScale.calc(yScale.min()), _w, 0, seriesGroups[i]);
                        seriesPlotItems[i][j] = rect;
                        rect.node.setAttribute('class', (series[i].classed || '') + classes);
                        var params = {
                            seriesIndex: series[i].seriesIndex,
                            labelIndex: j,
                            value: data[j],
                            label: labels[j]
                        }, extraParams = {
                            color: series[i].color
                        };

                        if(series[i].color !== 'auto') {
                            rect.attr({
                                fill: series[i].color,
                                stroke: 'none'
                            });
                        }
                        rect.click(createClickCallback(params, rect));
                        rect.mouseover(createOverCallback(params, rect, extraParams));
                        rect.mouseout(createOutCallback(params, rect, extraParams));
                    } else {
                        rect = seriesPlotItems[i][j];
                    }

                    // rect.attr(styles[i]);
                    
                    rect.animate({
                        x: _x,
                        y: _y,
                        width: _w,
                        height: _h
                    }, animate ? 500 : 0);
                }
            }
            if(options.stacked && options.stackedTotalDisplay) {
                for(i=0; i<dataLength; i++) {
                    var totalData = indexTotal(i);
                    var labelPadding = totalData.value > 0 ? -10 : 10;
                    var label;
                    _x = (seriesWidth * i) + (seriesWidth / 2);
                    _y = height - yScale.calc(totalData.value) + labelPadding;
                    if(create) {
                        label = paper.text (_x, height, totalData.label, columnCore);
                        totalLabels[i] = label;
                    } else {
                        label = totalLabels[i];
                    }
                    label.animate({
                        x: _x,
                        y: _y
                    }, animate ? 500 : 0);
                }
            }
        };

        var createClickCallback = function (params, $el) {
            return function() {
                eventManager.trigger('plotItemClick', params);
                eventManager.trigger('plotItemActivate', params);
            };
        };
        var createOverCallback = function (params, $el, extraParams) {
            return function() {
                if(params.seriesIndex <= 9 && extraParams.color === 'auto') {
                    var attr = $el.node.getAttribute('class');
                    $el.node.setAttribute('class', attr + ' highlight');    
                } else {
                    var newColor = colorUtils.darken(extraParams.color, 20);
                    $el.attr({
                        fill: newColor
                    });
                }
                eventManager.trigger('plotItemMouseOver', params);
            };
        };
        var createOutCallback = function (params, $el, extraParams) {
            return function() {
                if(params.seriesIndex <= 9 && extraParams.color === 'auto') {
                    var attr = $el.node.getAttribute('class');
                    attr = attr.replace(' highlight', '');
                    $el.node.setAttribute('class', attr);
                } else {
                    $el.attr({
                        fill: extraParams.color
                    });
                }
                    
                eventManager.trigger('plotItemMouseOut', params);
            };
        };

        var prevIndexTotal = function(currentSeriesIndex, dataIndex) {
            var series = options.series;
            var num = 0, negative = series[currentSeriesIndex].data[dataIndex] < 0;
            for(var i=currentSeriesIndex - 1; i >= 0; --i) {
                var val = series[i].data[dataIndex];
                num += negative ? (val < 0) ? val : 0 : (val > 0) ? val : 0;
            }
            return num;
        };

        var indexTotal = function (dataIndex) {
            var series = options.series;
            var sum = 0, neg = 0, pos = 0;
            for(var i=0; i<series.length; i++) {
                var data = series[i].data[dataIndex];
                sum += data;
                if(data >= 0) {
                    pos += data;
                } else {
                    neg += data; 
                }
            }
            if(pos === 0) {
                return { 
                    value: neg,
                    label: neg
                };
            } else {
                return {
                    value: pos,
                    label: sum
                }
            }
        };
    };

    return ColumnChart;
});

define('razorcharts/renderers/line',['vendor/lodash'], function(_) {
    var LineChart = function() {
        var CIRCLE_RADIUS = 4,
            CIRCLE_ANIMATE_RADIUS = 6,
            CIRCLE_EVENT_RADIUS = 12;
        var self = this,
            paper = null,
            core = null,
            lineCore = null,
            options = null,
            width = null,
            height = null,
            plotItemsCircle = [],
            plotItemsEventCircle = [],
            plotItemsLine = [],
            seriesGroups = [],
            eventManager;


        self.config = function(_options) {
            options = _options;
            eventManager = options.eventManager;
            if(eventManager) {
                eventManager.register('plotItemClick');
                eventManager.register('plotItemMouseOver');
                eventManager.register('plotItemMouseOut');
                eventManager.register('plotItemActivate');
            }
        };

        self.setEventManager = function (_eventManager) {
            eventManager = _eventManager;
        };

        self.renderTo = function(_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            draw(true, true && options.animateOnRender);
            for(var i=-1; ++i<plotItemsCircle.length;) {
                options.tooltip.addSeriesItems(options.series[i].seriesIndex, plotItemsEventCircle[i]);
            }
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            draw(false, false);
        };

        self.updateSeries = function(w, h) {
            width = w;
            height = h;
            draw(false, true);
        };

        var draw = function(create, animate) {
            var series = options.series,
                yScale = options.yScale,
                dataLength = _.max(_.pluck(_.pluck(series, 'data'), 'length')),
                seriesWidth = (width / dataLength);
            if(create) {
                lineCore = paper.group('rc-line-chart', core);
                lineCore.node.setAttribute('class', 'rc-line-chart');
            }
            for(var i=-1; ++i<series.length;) {
                var data = series[i].data,
                    classes = series[i].color === 'auto' ? ' rc-series-' + series[i].seriesIndex + ' rc-plot-item' : '';
                if(create) {
                    seriesGroups[i] = paper.group('line-series-' + (i+1), lineCore);
                    seriesGroups[i].node.setAttribute('class', 'rc-series-' + series[i].seriesIndex);
                    plotItemsCircle[i] = [];
                    plotItemsLine[i] = [];
                    plotItemsEventCircle[i] = [];
                }
                for(var j=-1; ++j<data.length;) {
                    var circle = null,
                        line = null,
                        eventCircle = null;

                    if(options.dualAxis) {
                        yScale = options.yScale[series[i].yAxis || 'left'];
                    }
                    if(j !== data.length - 1) {
                        if(create) {
                            line = plotItemsLine[i][j] = paper.path('M' + ((seriesWidth * j) + seriesWidth / 2) + ',' + height + 
                                                        'L' +  ((seriesWidth * (j+1)) + seriesWidth / 2) + ',' + height, seriesGroups[i]);    
                            line.node.setAttribute('class', (series[i].classed || '') + classes);
                            if(!classes) {
                                line.attr({
                                    stroke: series[i].color,
                                    fill: 'none'
                                });
                            }
                        } else {
                            line = plotItemsLine[i][j];
                        }
                        if(typeof data[j] === "number" && data[j].toString() !== 'NaN'  && typeof data[j+1] === "number" && data[j+1].toString() !== 'NaN') {
                            line.attr('opacity', 1);
                        } else {
                            line.attr('opacity', 0);
                        }
                        var d = (typeof data[j] === 'number' && data[j].toString() !== 'NaN') ? data[j] : 0;
                        var d1 = (typeof data[j + 1] === 'number' && data[j + 1].toString() !== 'NaN') ? data[j+1] : 0;
                        line.animate({
                            path: 'M' + ((seriesWidth * j) + seriesWidth / 2) + ',' + (height - yScale.calc(d)) + 
                                                        'L' +  ((seriesWidth * (j+1)) + seriesWidth / 2) + ',' + (height - yScale.calc(d1))
                        }, animate ? 500 : 0);
                    }
                    if(create) {
                        circle = plotItemsCircle[i][j] = paper.circle((seriesWidth * j) + seriesWidth / 2, height, CIRCLE_RADIUS, seriesGroups[i]);
                        circle.node.setAttribute('class', (series[i].classed || '') + classes);
                        var params = {
                            seriesIndex: series[i].seriesIndex,
                            labelIndex: j,
                            value: data[j],
                            label: labels[j]
                        };
                        circle.click(createClickCallback(params));
                        circle.mouseover(createOverCallback(params, circle));
                        circle.mouseout(createOutCallback(params, circle));
                        if(!classes) {
                            circle.attr({
                                stroke: series[i].color,
                                fill: '#FFF'
                            });
                        }
                        eventCircle = plotItemsEventCircle[i][j] = paper.circle((seriesWidth * j) + seriesWidth / 2, height, CIRCLE_EVENT_RADIUS, seriesGroups[i]);
                        eventCircle.node.setAttribute('class', (series[i].classed || '') + ' rc-series-' + i + ' rc-plot-item' + ' ' + (options.plotItemClasses || ''));
                        eventCircle.attr({opacity: 0});
                        eventCircle.click(createClickCallback(params));
                        eventCircle.mouseover(createOverCallback(params, circle));
                        eventCircle.mouseout(createOutCallback(params, circle));
                        !function(circle) {
                            eventCircle.mouseover(function() {
                                circle.animate({
                                    r: CIRCLE_ANIMATE_RADIUS
                                }, 100);
                            });
                            eventCircle.mouseout(function() {
                                circle.animate({
                                    r: CIRCLE_RADIUS
                                }, 100);
                            });
                        }(circle);
                            
                    } else {
                        circle = plotItemsCircle[i][j];
                        eventCircle = plotItemsEventCircle[i][j];
                    }
                    if(typeof data[j] === "number" && data[j].toString() !== 'NaN') {
                        circle.attr('opacity', 1);
                        eventCircle.node.style.pointerEvents = '';
                    } else {
                        circle.attr('opacity', 0);
                        eventCircle.node.style.pointerEvents = 'none';
                    }
                    var d = (typeof data[j] === 'number' && data[j].toString() !== 'NaN') ? data[j] : 0;
                    circle.animate({
                        cx: (seriesWidth * j) + seriesWidth / 2,
                        cy: height - yScale.calc(d)
                    }, animate ? 500 : 0);

                    eventCircle.attr({
                        cx: (seriesWidth * j) + seriesWidth / 2,
                        cy: height - yScale.calc(d)
                    });
                }
            }
        };

        var createClickCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemClick', params);
                eventManager.trigger('plotItemActivate', params);
            };
        };
        var createOverCallback = function (params, $el) {
            return function() {
                var attr = $el.node.getAttribute('class');
                $el.node.setAttribute('class', attr + ' highlight');
                eventManager.trigger('plotItemMouseOver', params);
            };
        };
        var createOutCallback = function (params, $el) {
            return function() {
                var attr = $el.node.getAttribute('class');
                attr = attr.replace(' highlight', '');
                $el.node.setAttribute('class', attr);
                eventManager.trigger('plotItemMouseOut', params);
            };
        };
    };

    return LineChart; 
});
define('razorcharts/renderers/area',['razorcharts/renderers/line', 'vendor/lodash'], function(Line, _) {
    var AreaChart = function() {

        var self = this,
            paper = null,
            core = null,
            areaCore = null,
            options = null,
            width = null,
            height = null,
            plotItemsLine = [],
            seriesGroups = [],
            styles = [
                {
                    fill: '#ff0',
                    opacity: 0.5
                },
                {
                    fill: '#f0f',
                    opacity: 0.5
                },
                {
                    fill: '#0ff',
                    opacity: 0.5
                }
            ], subLineCharts = [];


        self.config = function(_options) {
            options = _options;
            var opts = _.cloneDeep(options);
            if(options.stacked) {
                var series = opts.series;

                for(var i=0; ++i<series.length;) {
                    var data = series[i].data;

                    for(var j=-1; ++j<data.length;) {
                        data[j] = prevIndexTotal(i+1, j);
                    }
                    opts.series[i].data = data;
                }

            }
            eventManager = options.eventManager;
            eventManager.register('plotItemClick');
            eventManager.register('plotItemMouseOver');
            eventManager.register('plotItemMouseOut');
            eventManager.register('plotItemActivate');
        };

        self.renderTo = function(_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            draw(true, true && options.animateOnRender);
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            draw(false, false);
            for(var i=-1; ++i<subLineCharts.length;) {
                subLineCharts[i].resizeTo(w, h);
            }
        };

        self.updateSeries = function(w, h) {
            width = w;
            height = h;
            draw(false, true);
            for(var i=-1; ++i<subLineCharts.length;) {
                subLineCharts[i].updateSeries(w, h);
            }
        };

        var draw = function(create, animate) {
            var series = options.series,
                yScale = options.yScale,
                dataLength = _.max(_.pluck(_.pluck(series, 'data'), 'length')),
                seriesWidth = (width / dataLength),
                j;
            if(create) {
                areaCore = paper.group('rc-area-chart', core);
                areaCore.node.setAttribute('class', 'rc-area-chart');
            }
            for(var i=-1; ++i<series.length;) {
                var data = series[i].data;
                var pathObj = null;
                var path, animPath;
                var classes = series[i].color === 'auto' ? ' rc-series-' + series[i].seriesIndex + ' rc-plot-item area-path' : '';
                if(create) {
                    seriesGroups[i] = paper.group('area-series-' + (i+1), areaCore);
                    seriesGroups[i].node.setAttribute('class', 'rc-series-' + series[i].seriesIndex);
                }
                if(options.dualAxis) {
                    yScale = options.yScale[series[i].yAxis || 'left'];
                }
                var _x, _y;
                _y = options.stacked ? (height - yScale.calc(prevIndexTotal(i, 0))) : (height - yScale.calc(0));
                path = 'M' + seriesWidth / 2 + ',' + (height - yScale.calc(0));
                animPath = 'M' + seriesWidth / 2 + ',' + _y;
                for(j=-1; ++j<data.length;) {
                    var circle, line;

                    path += ' L' +  ((seriesWidth * j) + seriesWidth / 2) + ',' + (height - yScale.calc(0));
                    _y = options.stacked ? (height - yScale.calc(prevIndexTotal(i, j) + data[j])) : (height - yScale.calc(data[j]));
                    if(typeof data[j] === 'number' && data[j].toString() !== 'NaN') {
                        animPath += ' L' +  ((seriesWidth * j) + seriesWidth / 2) + ',' + _y;
                    } else {
                        if(j - 1 >= 0) {
                            animPath += ' L' +  ((seriesWidth * (j - 1)) + seriesWidth / 2) + ',' + height;
                        }
                        if(j + 1 < data.length) {
                            animPath += ' M' +  ((seriesWidth * (j + 1)) + seriesWidth / 2) + ',' + height;
                        }
                    }            
                }
                if(options.stacked) {
                    for(j=data.length-1; j>=0; j--) {
                        _x = ((seriesWidth * j) + seriesWidth / 2);
                        _y = options.stacked ? (height - yScale.calc(prevIndexTotal(i, j))) : (height - yScale.calc(0));

                        path += 'L' + _x + ',' + (height - yScale.calc(0));
                        animPath += 'L' + _x + ',' + _y;
                    }
                } else {
                    path += 'L' + (seriesWidth * (dataLength -1) + seriesWidth / 2) + ',' + (height - yScale.calc(0));
                    animPath += 'L' + (seriesWidth * (dataLength -1) + seriesWidth / 2) + ',' + (height - yScale.calc(0));    
                }

                if(create) {
                    pathObj = plotItemsLine[i] = paper.path(path, seriesGroups[i]);
                    pathObj.node.setAttribute('class', (series[i].classed || '') + classes);
                    var opts = _.cloneDeep(options);
                    delete opts.eventManager;
                    opts.series = [];
                    opts.series[0] = _.cloneDeep(options.series[i]);
                    if(!classes) {
                        pathObj.attr({
                            fill: series[i].color,
                            stroke: series[i].color,
                            opacity: 0.8
                        });
                    }
                    if(options.stacked && i !== 0) {
                        for(j=-1; ++j<options.series[i].data.length;) {
                            opts.series[0].data[j] = prevIndexTotal(i+1, j);
                        }
                    }
                    subLineCharts[i] = new Line();
                    subLineCharts[i].config(opts);
                    subLineCharts[i].setEventManager (options.eventManager);
                    subLineCharts[i].renderTo(paper, seriesGroups[i], width, height);
                } else {
                    pathObj = plotItemsLine[i];
                }
                // pathObj.attr(styles[i]);

                
                pathObj.animate({
                    path: animPath
                }, animate ? 500 : 0);
            }
        };

        var prevIndexTotal = function(currentSeriesIndex, dataIndex) {
            var series = options.series;
            var num = 0;
            for(var i=currentSeriesIndex - 1; i >= 0; --i) {
                num += series[i].data[dataIndex];
            }
            return num;
        };

    };

    return AreaChart; 
});
define('razorcharts/scales/linearscale',['vendor/lodash'], function(_) {
    var LinearScale = function scale(_domain, _range) {
        var self = this,
            domain = _domain || [0, 1],
            range = _range || [0, 1];

        self.type = 'linear';

        self.domain = function(val) {
            if(val) {
                domain = val;
            }
            else {
                return domain;
            }
        };

        self.range = function(val) {
            if(val) {
                range = val;
            }
            else {
                return range;
            }
        };

        self.calc = function(val) {
            var percent = (val - domain[0]) / (domain[1] - domain[0]);
            
            return +((range[1] - range[0]) * percent + range[0]);
        };

        self.min = function () {
            return domain[0];
        };

        self.max = function () {
            return domain[1];
        };
         
    };

    return LinearScale;
}); 
define('razorcharts/scales/ordinalscale',['vendor/lodash'], function(_) {
    var OrdinalScale = function scale(_domain, _range) {
        var self = this,
            domain = _domain || [],
            range = _range || [0, 1];

        self.type = 'ordinal';

        self.domain = function(val) {
            if(val) {
                domain = val;
            }
            else {
                return domain;
            }
        };

        self.range = function(val) {
            if(val) {
                range = val;
            }
            else {
                return range;
            }
        };

        self.calc = function(val) {
            var idx = domain.indexOf(val),
                length = domain.length;

            var percent = idx / length;
            
            return (range[1] - range[0]) * percent + range[0];
        };

        self.min = function () {
            return domain[0];
        };

        self.max = function () {
            return domain[1];
        };
         
    };

    return OrdinalScale;
}); 
define('razorcharts/scales/scale',['razorcharts/scales/linearscale', 'razorcharts/scales/ordinalscale', 'vendor/lodash'], function(LinearScale, OrdinalScale, _) {
    var Scale = {
        linear: LinearScale,
        ordinal: OrdinalScale
    };

    return Scale;
});
define('razorcharts/utils/graphutils',['vendor/lodash'], function (_) {
  var graphUtils = {
    /**
     * Takes an input domain and prettifies it
     * @param  Number min lowest number in the domain
     * @param  Number max highest number in the domain
     * @return Object output domain
     */
    prettyDomain: function (min, max, dontExtend) {

      if(min < 0 && max === 0) {
        max = -1;
      }

      var negateFlag = false,
          negateInvert = false;

      min = typeof min === "undefined" ? 0 : min;
      max = typeof max === "undefined" ? 100 : max;

      function log10(val) {
        return Math.log(val) / Math.LN10;
      }

      var newMin = min,
          newMax = max,
          exponent = Math.floor(log10(newMax)),
          magnitude = Math.pow(10, exponent),
          u = [1.25, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10],
          m = newMax / magnitude,
          nu = 0,
          _2 = [],
          _5 = [],
          unit = null,
          uo = null,
          ticks = [],
          i = 0,
          val = 0;

      function getNewMax(newMax, m, u) {
        for (i = 0; i < u.length; i++) {
          if (m <= u[i]) {
            nu = u[i];
            if (u[i] - m <= 0.2 && !dontExtend) {
              var nextU = u[i + 1];
              if (!u[i + 1]) {
                nextU = u[0] * 10;
              }
              nu = nextU;

            }
            newMax = nu * magnitude;
            return newMax;
          }
        }
      }

      if (min < 0) {
        if (-min > max) {
          exponent = Math.floor(log10(-min));
          magnitude = Math.pow(10, exponent);
          m = -min / magnitude;

          newMin = -newMax;
          newMax = getNewMax(-min, m, u);
          negateInvert = true;
          negateFlag = true;
        } else {
          newMin = min;
          newMax = getNewMax(newMax, m, u);
          negateFlag = true;
        }
      } else {
        newMax = getNewMax(newMax, m, u);
      }


      for (i = 3; i <= 6; i++) {
        unit = ((nu / i) * magnitude) / 10;
        var mul = 10;

        if (unit < 0.1) {
          unit *= 1000;
          mul = 0.01;
        }
        else if (unit < 1) {
          unit *= 100;
          mul = 0.1;
        } else if (unit <= 2.5) {
          unit *= 10;
          mul = 1;
        }
        if (nu > 10) {
          unit *= 10;
          mul = 1;
          if (magnitude === 10) {
            mul = 0.1;
          }

        }

        if (unit % 5 === 0) {
          _5.push({
            unit: unit * mul,
            num: i
          });
        } else if (unit % 2 === 0) {
          _2.push({
            unit: unit * mul,
            num: i
          });
        }
      }

      if (_5.length) {
        uo = _.min(_5, function (d) {
          return d.unit;
        });
      } else {
        uo = _.min(_2, function (d) {
          return d.unit;
        });
      }

      if (negateFlag) {
        if (negateInvert) {

          for (i = uo.num; i >= 0; i--) {
            ticks.push(i * uo.unit * -1);
          }
          val = 0;

          while (val <= -newMin) {
            val += uo.unit;
            ticks.push(val);
          }
        } else {
          val = 0;
          while (val <= -newMin) {
            val += uo.unit;
            ticks.push(val * -1);
          }
          ticks = ticks.reverse();
          for (i = 0; i < uo.num + 1; i++) {
            ticks.push(i * uo.unit);
          }
        }
      } else {
        for (i = 0; i < uo.num + 1; i++) {
          ticks.push(min + (i * uo.unit));
        }
      }
      return {
        min: ticks[0],
        max: ticks[ticks.length - 1],
        numTicks: ticks.length,
        unit: uo.unit,
        ticks: ticks
      };
    },

    dualAxisDomain: function(lDomain, rDomain) {
      var prettyLDomain = graphUtils.prettyDomain(lDomain[0], lDomain[1]),
          prettyRDomain = graphUtils.prettyDomain(rDomain[0], rDomain[1]),
          i, numNegativeTicks, totalTicks, numPoistiveTicks, diff;

      if(prettyLDomain.ticks.indexOf(0) < prettyRDomain.ticks.indexOf(0)) {
        numNegativeTicks = prettyRDomain.ticks.indexOf(0) - prettyLDomain.ticks.indexOf(0);
        totalTicks = numNegativeTicks + prettyLDomain.numTicks;
        numPoistiveTicks = totalTicks < prettyRDomain.numTicks ? prettyRDomain.numTicks - totalTicks : 0;
        var newLDomain = [];
        for(i=-1; ++i<numNegativeTicks;) {
          newLDomain.push(prettyLDomain.min + prettyLDomain.unit * -(i+1));
        }
        newLDomain = newLDomain.reverse().concat(prettyLDomain.ticks);
        for(i=-1; ++i<numPoistiveTicks;) {
          newLDomain.push(prettyLDomain.max + prettyLDomain.unit * (i + 1));
        }
        if(prettyRDomain.numTicks < newLDomain.length) {
          diff = newLDomain.length - prettyRDomain.numTicks;
          for(i=-1; ++i<diff;) {
            prettyRDomain.ticks.push((i + 1) * prettyRDomain.unit + prettyRDomain.max);
          }
        }

        prettyLDomain.ticks = newLDomain;
        prettyLDomain.numTicks = newLDomain.length;
      } else {
        numNegativeTicks = prettyLDomain.ticks.indexOf(0) - prettyRDomain.ticks.indexOf(0);
        totalTicks = numNegativeTicks + prettyRDomain.numTicks;
        numPoistiveTicks = totalTicks < prettyLDomain.numTicks ? prettyLDomain.numTicks - totalTicks : 0;
        var newRDomain = [];
        for(i=-1; ++i<numNegativeTicks;) {
          newRDomain.push(prettyRDomain.min + prettyRDomain.unit * -(i+1));
        }
        newRDomain = newRDomain.reverse().concat(prettyRDomain.ticks);
        for(i=-1; ++i<numPoistiveTicks;) {
          newRDomain.push((prettyRDomain.unit * (i + 1)) + prettyRDomain.max);
        }
        if(prettyLDomain.numTicks < newRDomain.length) {
          diff = newRDomain.length - prettyLDomain.numTicks;
          for(i=-1; ++i<diff;) {
            prettyLDomain.ticks.push((i + 1) * prettyLDomain.unit + prettyLDomain.max);
          }
        }
        prettyRDomain.ticks = newRDomain;
        prettyRDomain.numTicks = newRDomain.length;
      }
      return {lDomain: prettyLDomain, rDomain: prettyRDomain};
    }
  };

  return graphUtils;
});
define('razorcharts/utils/pathgen',[], function() {
    var PathGen = function () {
        var self = this,
            path = '';

        self.moveTo = function(x, y) {
            path += 'M' + x + ',' + y + ' ';
            return self;
        };

        self.lineTo = function(x, y) {
            path += 'L' + x + ',' + y + ' ';
            return self;
        };

        self.qTo = function(x, y, dx, dy) {
            path += 'Q' + x + ',' + y + ' ' + dx + ',' + dy + ' ';
            return self;
        };

        self.path = function() {
            return path;
        };

        self.clear = function() {
            path = '';
        };
    };

    return PathGen;
});
define('razorcharts/utils/tooltip',['razorcharts/utils/pathgen', 'vendor/lodash'], function(pathGen, _) {
    var Modernizr = {touch: false};
    var TOOLTIP_HIDE_TIMEOUT = 1000;
    var Tooltip = function () {
        var self = this,
            options = null,
            paper = null,
            core = null,
            container = null,
            width = null,
            height = null,
            xOffset =  null,
            yOffset = null,
            parts = [],
            currentPart = -1,
            tooltip = null,
            tooltipWidth = 100,
            tooltipHeight = 80,
            tooltipPath = null,
            tooltipStruct = {
            },
            tooltipValues = {

            },
            partWidth,
            partHeight,
            items = [];
        
        self.config = function(_options) {
            options = _options;
        };

        self.renderTo = function(_paper, _core, w, h, xoff, yoff) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            container = paper.group('rc-tooltip-container', core);
            container.toBack();
            xOffset = xoff || 0;
            yOffset = yoff || 0;
            init(true);
            if(options.display !== 'custom') {
                draw(true);    
            }
        };

        var draw = function(create) {
            var xPadding = 6, yPadding = 10, labelYPadding = 8;
            var mainLabel, line, paddingTop, pathgen, pathString;
            if(create) {
                tooltip = paper.group('tooltip', core);
                tooltip.node.setAttribute('class', 'rc-tooltip');
                var rect = paper.rect(0,0, tooltipWidth, tooltipHeight, tooltip);
                rect.node.setAttribute('class', 'rect');
                if(options.popup) {
                    pathgen = new pathGen();
                    pathString;
                    if(options.popupType === 'top') {
                        pathString = pathgen.moveTo(0, 0).lineTo(tooltipWidth, 0).lineTo(tooltipWidth, tooltipHeight).lineTo((tooltipWidth / 2) + 10, tooltipHeight)
                                    .lineTo(tooltipWidth / 2, tooltipHeight + 10).lineTo(tooltipWidth/2 - 10, tooltipHeight).lineTo(0, tooltipHeight).path();    
                        // pathString = pathgen.moveTo(5, 0).lineTo(tooltipWidth - 5, 0).qTo(tooltipWidth, 0, tooltipWidth, 5).lineTo(tooltipWidth, tooltipHeight - 5).qTo(tooltipWidth, tooltipHeight, tooltipWidth-5, tooltipHeight).lineTo((tooltipWidth / 2) + 5, tooltipHeight)
                        //             .lineTo(tooltipWidth / 2, tooltipHeight + 5).lineTo(tooltipWidth/2 - 5, tooltipHeight).lineTo(5, tooltipHeight).qTo(0, tooltipHeight, 0, tooltipHeight - 5). lineTo(0, 5).qTo(0, 0, 5, 0).path();
                    } else if(options.popupType === 'left') {
                        pathString = pathgen.moveTo(0, tooltipHeight / 2).lineTo(10, tooltipHeight / 2 - 10).lineTo(10, 0).lineTo(tooltipWidth, 0).lineTo(tooltipWidth, tooltipHeight)
                                        .lineTo(10, tooltipHeight).lineTo(10, tooltipHeight / 2 + 10).lineTo(0, tooltipHeight / 2).path();
                    }
                    
                    pathString += ' z';
                    tooltipPath = paper.path(pathString, tooltip);
                    tooltipPath.node.setAttribute('class', 'rect');    
                }

                mainLabel = paper.text(0,0, 'placeholder-main-label', tooltip);
                mainLabel.attr({
                    x: xPadding,
                    y: mainLabel.getBBox().height / 2 + labelYPadding,
                    'text-anchor': 'start'
                });
                mainLabel.node.setAttribute('class', 'mainLabel');
                var _y = mainLabel.getBBox().height + mainLabel.getBBox().height / 2 + labelYPadding;
                line = paper.path('M' + xPadding + ',' + _y + ' L' + (tooltipWidth - xPadding) + ',' + _y, tooltip);
                line.node.setAttribute('class', 'rc-tooltip-dash');
                tooltipStruct['line'] = line;
                tooltipStruct['mainLabel'] = mainLabel;
                tooltipStruct['rect'] = rect;
                paddingTop = mainLabel.getBBox().height;
                tooltipStruct['parts'] = [];
                // debugger
                rect.attr({
                    height: paddingTop * options.numLabels + paddingTop + yPadding * 2 + labelYPadding * options.numLabels
                });
            } else {
                mainLabel = tooltipStruct.mainLabel;
                mainLabel.attr({
                    text: tooltipValues.label
                });
            }
            var maxWidth = 0, i;
            for(i=-1; ++i<options.numLabels;) {
                var label, value;
                if(create) {
                    label = paper.text(0,0, 'pl-1', tooltip);
                    value = paper.text(0,0, 'pv-1', tooltip);
                    tooltipStruct['parts'][i] = {
                        'label': label,
                        'value': value
                    };
                    label.attr({
                        x: 0 + xPadding,
                        y: i * label.getBBox().height + paddingTop + mainLabel.getBBox().height / 2 + yPadding * 2 + labelYPadding * i,
                        'text-anchor': 'start'
                    });
                    value.attr({
                        x: label.getBBox().width + xPadding,
                        y: i * label.getBBox().height + paddingTop + mainLabel.getBBox().height / 2 + yPadding * 2 + labelYPadding * i,
                        'text-anchor': 'end'
                    });
                    label.node.setAttribute('class', 'rf-tooltip-label');
                    
                    value.node.setAttribute('class', 'rf-tooltip-value');
                } else {
                    label = tooltipStruct.parts[i].label;
                    value = tooltipStruct.parts[i].value;
                    label.attr({
                        text: tooltipValues.seriesLabels[i]
                    });
                    value.attr({
                        text: tooltipValues.data[i]
                    });
                    value.attr({
                        x: tooltipWidth - xPadding
                    });
                    var totalWidth = label.getBBox().width + value.getBBox().width;
                    maxWidth = maxWidth < totalWidth ? totalWidth : maxWidth;
                    if(!tooltipValues.label) {
                        label.attr({
                            y: yPadding
                        });
                        value.attr({
                           y: yPadding
                        });
                        tooltipStruct['line'].attr({opacity: 0});
                        tooltipStruct['rect'].attr({height: yPadding * 2});
                    }
                }
            }
            tooltip.attr({
                'opacity': 0
            });
            if(maxWidth > tooltipWidth) {
                tooltipWidth = maxWidth + xPadding * 2 + 10;
                tooltipStruct.rect.attr({
                    width: tooltipWidth
                });
                for(i=-1; ++i<options.numLabels;) {
                    tooltipStruct.parts[i].value.attr({
                        x: maxWidth + 10
                    });
                }
            }
            tooltipHeight = tooltipStruct.rect.getBBox().height;

            if(options.popup) {
                tooltipStruct.rect.attr({'opacity': 0});
                pathgen = new pathGen();
                pathString;
                if(options.popupType === 'top') {
                    pathString = pathgen.moveTo(0, 0).lineTo(tooltipWidth, 0).lineTo(tooltipWidth, tooltipHeight).lineTo((tooltipWidth / 2) + 5, tooltipHeight)
                                .lineTo(tooltipWidth / 2, tooltipHeight + 5).lineTo(tooltipWidth/2 - 5, tooltipHeight).lineTo(0, tooltipHeight).path();    
                    // pathString = pathgen.moveTo(5, 0).lineTo(tooltipWidth - 5, 0).qTo(tooltipWidth, 0, tooltipWidth, 5).lineTo(tooltipWidth, tooltipHeight - 5).qTo(tooltipWidth, tooltipHeight, tooltipWidth-5, tooltipHeight).lineTo((tooltipWidth / 2) + 5, tooltipHeight)
                    //                 .lineTo(tooltipWidth / 2, tooltipHeight + 5).lineTo(tooltipWidth/2 - 5, tooltipHeight).lineTo(5, tooltipHeight).qTo(0, tooltipHeight, 0, tooltipHeight - 5). lineTo(0, 5).qTo(0, 0, 5, 0).path();
                } else if(options.popupType === 'left') {
                    pathString = pathgen.moveTo(0, tooltipHeight / 2).lineTo(10, tooltipHeight / 2 - 10).lineTo(10, 0).lineTo(tooltipWidth, 0).lineTo(tooltipWidth, tooltipHeight)
                                    .lineTo(10, tooltipHeight).lineTo(10, tooltipHeight / 2 + 10).lineTo(0, tooltipHeight / 2).path();
                }
                pathString += ' z';
                tooltipPath.attr({path: pathString});
            } 
        };

        self.resizeTo = function(w, h, xoff, yoff) {
            width = w;
            height = h;
            xOffset = xoff || 0;
            yOffset = yoff || 0;
            var numParts = options.numParts || 1;
            partWidth = width / numParts;
            partHeight = height / numParts;
            init(false);
        };

        self.addItems = function(_items) {
            items[0] = _items;
        };

        self.addSeriesItems = function(seriesIndex, _items) {
            items[seriesIndex-1] = _items;
        };

        self._init = function() {
            init(true);
        };

        var init = function(create) {
            if(options.type === 'area') {
                initializeAreaTooltip(create);
            } else if(options.type === 'item') {
                initializeItemTooltip(create);
            }
        };

        var initializeItemTooltip = function(create) {
            var timeout;
            if(create) {
                for(var i=-1; ++i<items.length;) {
                    if(!items[i]) { continue; }
                    for(var j=-1; ++j<items[i].length;) {
                         !function(seriesIndex, num) {
                            if(options.display === 'custom') {
                                if(options.popup) {
                                    var popupType = options.popupType || 'top';
                                    if(Modernizr.touch) {
                                        items[seriesIndex][num].touchstart(function(ev, x, y) {
                                            var item = items[seriesIndex][num].node.getBoundingClientRect();
                                            var data = options.data(seriesIndex, num);
                                            x = popupType === 'top' ? item.left + item.width / 2 : item.left + item.width;
                                            y = popupType === 'top' ? item.top : item.top + item.height / 2;
                                            options.onShow(x, y, data);
                                            clearTimeout(timeout);
                                        });
                                    } else {
                                        items[seriesIndex][num].mouseover(function(ev, x, y) {
                                            var item = items[seriesIndex][num].node.getBoundingClientRect();
                                            var data = options.data(seriesIndex, num);
                                            x = popupType === 'top' ? item.left + item.width / 2 : item.left + item.width;
                                            y = popupType === 'top' ? item.top : item.top + item.height / 2;
                                            options.onShow(x, y, data);
                                            clearTimeout(timeout);
                                        });
                                    }
                                        
                                } else {
                                    if(Modernizr.touch) {
                                        items[seriesIndex][num].touchstart(function(ev, x, y) {
                                            var newX = ev.touches[0].pageX;
                                            var newY = ev.touches[0].pageY;
                                            var data = options.data(seriesIndex, num);
                                            options.onShow(newX, newY, data);
                                            clearTimeout(timeout);
                                        });
                                    } else {
                                        items[seriesIndex][num].mousemove(function(ev, x, y) {
                                            var data = options.data(seriesIndex, num);
                                            options.onShow(x, y, data);
                                            clearTimeout(timeout);
                                        });
                                    } 
                                        
                                }
                                items[seriesIndex][num].mouseout(function(ev, x, y) {
                                    timeout = setTimeout(function() {
                                        options.onHide();    
                                    }, TOOLTIP_HIDE_TIMEOUT);
                                });
                            } else {
                                if(options.popup) {
                                    var tooltipEvent = function(ev, x, y) {
                                        // var newX = (ev.offsetX ? ev.offsetX : ev.layerX) - xOffset;
                                        // var newY = (ev.offsetY ? ev.offsetY : ev.layerY) - yOffset;
                                        var newX, newY;
                                        if(options.popupType === 'top') {
                                            if(_.isNumber(items[seriesIndex][num].attrs.x)) {
                                                newX = items[seriesIndex][num].attrs.x + (items[seriesIndex][num].getBBox().width / 2 - tooltip.node.getBBox().width / 2);
                                                newY = items[seriesIndex][num].attrs.y - tooltip.node.getBBox().height;    

                                            } else {
                                                newX = items[seriesIndex][num].attrs.cx - tooltip.node.getBBox().width / 2;
                                                newY = items[seriesIndex][num].attrs.cy - tooltip.node.getBBox().height - 10;    
                                            }    
                                        } else if(options.popupType === 'left') {
                                            if(_.isNumber(items[seriesIndex][num].attrs.x)) {
                                                newX = items[seriesIndex][num].attrs.x + items[seriesIndex][num].attrs.width;
                                                newY = items[seriesIndex][num].attrs.y + (items[seriesIndex][num].getBBox().height / 2 - tooltip.node.getBBox().height / 2);

                                            } else {
                                                newX = items[seriesIndex][num].attrs.cx - tooltip.node.getBBox().width / 2;
                                                newY = items[seriesIndex][num].attrs.cy - tooltip.node.getBBox().height - 10;    
                                            }
                                        }
                                        
                                        
                                        var data = options.data(seriesIndex, num);
                                        tooltipValues = data;
                                        draw(false);
                                        var rotation = false;
                                        if(options.popupType === 'top') {
                                            if(newY < 0) {
                                                newY = (items[seriesIndex][num].attrs.y || items[seriesIndex][num].attrs.cy)  + 10;
                                                tooltipPath.transform('r180 t0,10');
                                                rotation = true;
                                            } else {
                                                tooltipPath.transform('r0');
                                            }
                                            if(newX + tooltipWidth > width) {
                                                var nx = newX;
                                                newX = width - tooltipWidth;
                                                var diff = rotation ? tooltipWidth / 2 - (nx - newX) : tooltipWidth / 2 + (nx - newX);
                                                var pathgen = new pathGen();
                                                var pathString = pathgen.moveTo(5, 0).lineTo(tooltipWidth - 5, 0).qTo(tooltipWidth, 0, tooltipWidth, 5).lineTo(tooltipWidth, tooltipHeight - 5).qTo(tooltipWidth, tooltipHeight, tooltipWidth-5, tooltipHeight).lineTo(diff + 5, tooltipHeight)
                                                                .lineTo(diff, tooltipHeight + 5).lineTo(diff - 5, tooltipHeight).lineTo(5, tooltipHeight).qTo(0, tooltipHeight, 0, tooltipHeight - 5). lineTo(0, 5).qTo(0, 0, 5, 0).path();
                                                pathString += ' z';
                                                tooltipPath.attr({path: pathString});
                                                
                                            }
                                        }
                                        tooltip.animate({
                                            transform: 't' + newX + ',' + newY,
                                            opacity: 1
                                        }, 100);
                                        clearTimeout(timeout);
                                    };
                                    if(Modernizr.touch) {
                                        items[seriesIndex][num].touchstart(tooltipEvent);
                                    } else {
                                        items[seriesIndex][num].mouseover(tooltipEvent);
                                    }
                                    
                                } else {
                                    if(Modernizr.touch) {
                                        items[seriesIndex][num].touchstart(function(ev, x, y) {
                                            var newX = (ev.offsetX ? ev.offsetX : ev.layerX) - xOffset;
                                            var newY = (ev.offsetY ? ev.offsetY : ev.layerY) - yOffset - tooltipHeight * 2;
                                            
                                            var data = options.data(seriesIndex, num);
                                            tooltipValues = data;
                                            draw(false);
                                            if(newY < 0) { newY = 0; }
                                            if(newX + tooltipWidth > width) { newX = width - tooltipWidth - 10; }
                                            if(newY + tooltipHeight > height) { newY = height - tooltipHeight - 10; }
                                            tooltip.attr({
                                                transform: 't' + newX + ',' + newY,
                                                opacity: 1
                                            });
                                            clearTimeout(timeout);
                                        });
                                    } else {
                                           items[seriesIndex][num].mousemove(function(ev, x, y) {
                                            var newX = (ev.offsetX ? ev.offsetX : ev.layerX) - xOffset;
                                            var newY = (ev.offsetY ? ev.offsetY : ev.layerY) - yOffset - tooltipHeight * 2;
                                            // var newX = items[seriesIndex][num].node.getBoundingClientRect().left;
                                            // var newY = items[seriesIndex][num].node.getBoundingClientRect().top;
                                            var data = options.data(seriesIndex, num);
                                            tooltipValues = data;
                                            draw(false);
                                            if(newY < 0) { newY = 0; }
                                            if(newX + tooltipWidth > width) { newX = width - tooltipWidth - 10; }
                                            if(newY + tooltipHeight > height) { newY = height - tooltipHeight - 10; }
                                            tooltip.attr({
                                                transform: 't' + newX + ',' + newY,
                                                opacity: 1
                                            });
                                            clearTimeout(timeout);
                                        });
                                    }
                                }

                                items[seriesIndex][num].mouseout(function(ev, x, y) {
                                    timeout = _.delay(function() {
                                        tooltip.animate({
                                            opacity: 0
                                        }, 100);
                                    }, 1000);
                                });
                            }
                        }(i, j);
                    }
                }
            }
        };

        var initializeAreaTooltip = function(create) {
            var surfaceType = options.surfaceType || 'column',
                timeout,
                numParts = options.numParts || 1;
            partWidth = width / numParts;
            partHeight = height / numParts;
            if(create) {
                cover = paper.rect(0, 0, width, height, container);
                cover.attr({
                    fill: '#000',
                    opacity: 0
                });
                if(surfaceType === 'column') {
                    core.mousemove(_.throttle(function(ev, x, y) {
                        // TODO: Simple IE detection here avoid this
                        var newX = (ev.offsetX ? ev.offsetX : ev.layerX) - (!!window.ActiveXObject ? 0 : xOffset);
                        var newY = (ev.offsetY ? ev.offsetY : ev.layerY) - (!!window.ActiveXObject ? 0 : yOffset);
                        var newPart = Math.floor(newX / partWidth);
                        if(newPart !== currentPart && newPart >= 0 && newPart <= numParts) {
                            var data = options.data(newPart);
                            tooltipValues = data;
                            draw(false);
                            if(newX + tooltipWidth > width) { newX = width - tooltipWidth; }
                            if(newY + tooltipHeight > height) { newY = height - tooltipHeight; }
                            tooltip.animate({
                                transform: 't' + newX + ',' + newY,
                                opacity: 1
                            }, 100);
                            if(timeout) { clearTimeout(timeout); }
                            timeout = setTimeout(function() {
                                tooltip.attr({opacity: 0});
                                currentPart = -1;
                            }, 1000);
                        }
                        currentPart = newPart;
                    }, 100));
                } else if(surfaceType === 'row') {
                    core.mousemove(_.throttle(function(ev, x, y) {
                        var newX = (ev.offsetX ? ev.offsetX : ev.layerX) - xOffset;
                        var newY = (ev.offsetY ? ev.offsetY : ev.layerY) - yOffset;
                        var newPart = Math.floor(newY / partHeight);
                        if(newPart !== currentPart && newPart >= 0 && newPart <= numParts) {
                            var data = options.data(newPart);
                            tooltipValues = data;
                            draw(false);
                            if(newX + tooltipWidth > width) { newX = width - tooltipWidth - 10; }
                            if(newY + tooltipHeight > height) { newY = height - tooltipHeight - 10; }
                            tooltip.animate({
                                transform: 't' + newX + ',' + newY,
                                opacity: 1
                            }, 100);
                            if(timeout) { clearTimeout(timeout); }
                            timeout = setTimeout(function() {
                                tooltip.attr({opacity: 0});
                                currentPart = -1;
                            }, 1000);
                        }
                        currentPart = newPart;
                    }, 100));
                }
            } else {
                cover.attr({
                    x: 0,
                    y: 0,
                    width: width,
                    height: height
                });
            }
                
        };
    };

    return Tooltip;
});
define('razorcharts/axes/axis',['razorcharts/scales/scale', 'razorcharts/utils/graphutils', 'razorcharts/utils/tooltip', 'vendor/lodash'], function(Scale, graphUtils, Tooltip, _) {
    var MAX_AXIS_PERCENT = 0.25;
    var TILTED_TICK_TOP_PADDING = 10;
    var MIN_TICK_THRESHOLD = 20;
    var Axis = function () {
        var self = this,
            options = {},
            tickValues = [],
            tickLabels = [],
            numTicks = 6,
            paper = null,
            core = null,
            tickContainer = null,
            ticks = [],
            axisLine = null,
            width = null,
            height = null,
            cachedScaleDomain = null,
            cachedScaleRange = null,
            wordWidths = {},
            labelWidths = {},
            format = null,
            axisLabel = null,
            eventManager = null,
            tooltip = null,
            xOffset = 0,
            yOffset = 0,
            trendLabel = null;

        self.config = function(_options) {
            options = _options;
            eventManager = options.eventManager;
            if (eventManager) {
              eventManager.register('labelActivate');
            }
            format = options.format || nullFormat;
            createTickValues();
        };

        self.setConfigValue = function(key, value) {
            options[key] = value;
        };

        self.renderTo = function(_paper, _core, w, h) {
            var scale = options.scale;
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            if(!options.minValue && !options.maxValue) {
                readjustNumTicks ();
            }
            cachedScaleDomain = scale.domain();
            cachedScaleRange = scale.range();
            core.node.setAttribute('class', 'rc-axis');
            if(options.scale.type === 'ordinal') {
                findLabelWidths(tickValues);
                findWordWidths(tickValues);
            }
            tickContainer = paper.group('tickContainer', core);
            ticks = createTicks(tickValues, options.type);
            createTrendLine ();
            if(options.axisLine) {
                if(options.type === 'left') {
                    axisLine = paper.path('m0,0 l0' + ',' + h, tickContainer);
                } else if(options.type === 'bottom') {
                    axisLine = paper.path('m0,0l' + w + ',0', tickContainer);
                } else if(options.type === 'right') {
                    axisLine = paper.path('m0,0 l0' + ',' + h, tickContainer);
                }
            }
            if(options.label) {
                axisLabel = paper.text(0,0, options.label, core);
                axisLabel.node.setAttribute('class', 'rc-axis-label');
            }
            
            self.resizeTo(w, h);
            // if(options.type === 'left') {
            //     // debugger
            //     core.transform('t' + (core.node.getBBox().width) + ',0');
            // }
        };

        self.resizeTo = function(w, h) {
            var showLabel = shouldLabelBeShown();
            var scale = options.scale,  
                rangeUnit = null, i, g;
            width = w;
            height = h;
            if(!options.minValue && !options.maxValue) {
                readjustNumTicks ();
            }
            cachedScaleDomain = scale.domain();
            cachedScaleRange = scale.range();
            var tilt = false;
            if(options.type === 'left') {
                // paper.path('m0,0 l0,' + h, tickContainer);
                rangeUnit = h / (tickValues.length);
                if(scale.type === 'ordinal') {
                    tilt = shouldWeTilt(tickValues, rangeUnit);    
                }
                for(i=-1; ++i<ticks.length;) {
                    g = ticks[i];
                    if(scale.type === 'ordinal') {
                        // g.transform('t0,' + ((h - rangeUnit * i) - rangeUnit / 2));    
                        g.transform('t0,' + (rangeUnit * i + rangeUnit / 2));    
                    } else if(scale.type === 'linear') {
                        g.transform('t0,' + (h - scale.calc(tickValues[i])));
                    }
                }
                if(options.trendline.enabled) {
                    trendLabel.transform('t0,' + (h - scale.calc(options.trendline.value)));
                }

                if(options.axisLine) {
                    axisLine.attr('path', 'm0,0 l0' + ',' + h);
                }
                var axisLabelHeight = 0;
                if(options.label) {
                    axisLabelHeight = axisLabel.getBBox().width;
                    axisLabel.attr({
                        'text-anchor': 'middle',
                        transform: 't' + (axisLabelHeight/2)  + ',' + (h/2)+' r-90'
                    });
                    axisLabelHeight += 14;
                }
                // drawTrendLine(h, 14000, "Hello");

                tickContainer.transform('t' + (tickContainer.node.getBBox().width + axisLabelHeight) + ',0');             
            } else if(options.type === 'right') {
                rangeUnit = h / (tickValues.length);
                if(scale.type === 'ordinal') {
                    tilt = shouldWeTilt(tickValues, rangeUnit);    
                }
                
                for(i=-1; ++i<ticks.length;) {
                    g = ticks[i];
                    if(scale.type === 'ordinal') {
                        g.transform('t0,' + ((h - rangeUnit * i) - rangeUnit / 2));    
                    } else if(scale.type === 'linear') {
                        g.transform('t0,' + (h - scale.calc(tickValues[i])));
                    }
                }
                if(options.axisLine) {
                    axisLine.attr('path', 'm0,0 l0' + ',' + h);    
                }
                
                if(options.label) {
                    axisLabel.attr({
                        'text-anchor': 'middle',
                        transform: 't' + (tickContainer.node.getBBox().width + 14) + ',' + (h/2)+' r-90'
                    });
                }
                tickContainer.transform('t0,0');
                
            } else if(options.type === 'bottom') {
                if(showLabel) {
                    rangeUnit = w / tickValues.length;
                    if(scale.type === 'ordinal') {
                        tilt = shouldWeTilt(tickValues, rangeUnit);    
                    }
                    for(i=-1; ++i<ticks.length;) {
                        if(ticks[i]) {
                            ticks[i].remove();
                            ticks[i] = null;
                        }
                    }
                    ticks = createTicks(tickValues, options.type);
                    for(i=-1; ++i<tickValues.length;) {
                        g = ticks[i];
                        if(!g) continue;
                        if(scale.type === 'ordinal') {
                            // Check if label needs breaking
                            if(tilt) {
                                    g.remove();
                                    g = ticks[i] = createTiltedTick(tickValues[i], i, rangeUnit, 'bottom');
                            } else {
                                if(labelWidths[tickValues[i]] > rangeUnit) {
                                    var lines = getLines(tickValues[i], rangeUnit);
                                    g.remove();
                                    g = ticks[i] = createMultilineTick(lines.words, i, 'bottom');
                                } 
                            }
                            g.transform('t'+(scale.calc(tickValues[i]) + rangeUnit / 2)  +',0');
                        } else if(scale.type === 'linear') {
                            g.transform('t'+ scale.calc(tickValues[i]) +',0');
                        }
                    }
                    if(options.label) {
                        axisLabel.attr({
                            'text-anchor': 'middle',
                            transform: 't' + (w/2) + ',' + (tickContainer.node.getBBox().height + axisLabel.getBBox().height)
                        });
                    }

                    if(options.axisLine) {
                        axisLine.attr('path', 'm0,0l' + w + ',0');
                    }
            }
            }
            if(tilt && options.type === 'bottom') {
                if(!tooltip) {
                    var tooltipConfig = {};
                    if(options.tooltip) {
                        tooltipConfig = {
                            type: 'item',
                            display: 'custom',
                            onShow: options.tooltip.onShow,
                            onHide: options.tooltip.onHide,    
                            data: function(seriesIndex, num) {
                                return {
                                    seriesLabels: [tickValues[num]],
                                    data: []
                                };
                            }
                        };
                    } else {
                        tooltipConfig = {
                            type: 'area',
                            surfaceType: 'column',
                            numLabels: 0,
                            numParts: tickValues.length,
                            data: function(part) {
                                return {
                                    label: tickValues[part]
                                    // data: [options.series[seriesIndex].data[num]],
                                    // seriesIndex: [_.pluck(options.series, 'seriesIndex')[seriesIndex]],
                                    // seriesLabels: [_.pluck(options.series, 'caption')[seriesIndex]]
                                };
                            }
                        };
                    }
                    tooltip = new Tooltip();
                    tooltip.config(tooltipConfig);

                    tooltip.addSeriesItems(1, _.compact(ticks));
                    tooltip.renderTo(paper, core, width, core.node.getBBox().height, xOffset, yOffset - core.node.getBBox().height);
                } else {
                    tooltip.addSeriesItems(1, _.compact(ticks));
                    tooltip._init();
                    tooltip.resizeTo(width, core.node.getBBox().height, xOffset, yOffset - core.node.getBBox().height);
                }
                    
            }
        };

        self.update = function() {
            var scale = options.scale,
                h = height,
                w = width,
                oldScale = null,
                oldTicks = null, i, g;

            if(scale.type !== 'linear') {
                return;
            }

            oldScale = new Scale.linear();
            oldScale.domain(cachedScaleDomain);
            oldScale.range(cachedScaleRange);
            oldTickValues = tickValues;
            tickValues = [];
            cachedScaleRange = scale.range();
            cachedScaleDomain = scale.domain();

            createTickValues();
            
            oldTicks = ticks;
            ticks = [];
            ticks = createTicks(tickValues, options.type);
            if(options.type === 'left') {
                for(i=-1; ++i<ticks.length;) {
                    g = ticks[i];
                    g.transform('t0,' + (h - oldScale.calc(tickValues[i])));
                    g.attr('opacity', 0);
                    g.animate({
                        'transform': 't0,' + (h - scale.calc(tickValues[i])),
                        'opacity': 1
                    }, 500);
                }
                for(i=-1; ++i<oldTicks.length;) {
                    g = oldTicks[i];
                    g.animate({
                        'transform': 't0,' + (h - scale.calc(oldTickValues[i])),
                        'opacity': 0
                    }, 500);
                }
                // core.transform('t' + (core.node.getBBox().width - 30) + ',0');
            } else if(options.type === 'bottom') {
                for(i=-1; ++i<ticks.length;) {
                    g = ticks[i];
                    g.transform('t'+ oldScale.calc(tickValues[i]) +',0');
                    g.attr('opacity', 0);
                    g.animate({
                        'transform': 't'+ scale.calc(tickValues[i]) +',0',
                        'opacity': 1
                    }, 500);
                }
                for(i=-1; ++i<oldTicks.length;) {
                    g = oldTicks[i];
                    g.animate({
                        'transform': 't' + scale.calc(oldTickValues[i]) + ',0' ,
                        'opacity': 0
                    }, 500);
                }
            } else if(options.type === 'right') {
                for(i=-1; ++i<ticks.length;) {
                    g = ticks[i];
                    g.transform('t0,' + (h - oldScale.calc(tickValues[i])));
                    g.attr('opacity', 0);
                    g.animate({
                        'transform': 't0,' + (h - scale.calc(tickValues[i])),
                        'opacity': 1
                    }, 500);
                }
                for(i=-1; ++i<oldTicks.length;) {
                    g = oldTicks[i];
                    g.animate({
                        'transform': 't0,' + (h - scale.calc(oldTickValues[i])),
                        'opacity': 0
                    }, 500);
                }
            }
            setTimeout(function() {
                for(i=-1; ++i<oldTicks.length;) {
                    oldTicks[i].remove();
                    oldTicks[i] = null;
                }
            }, 500);
            cachedScaleDomain = scale.domain();
            cachedScaleRange = scale.range();
        };

        self.ticks = function() {
            return tickValues;
        };

        self.setOffsets = function(xoff, yoff) {
            xOffset = xoff;
            yOffset = yoff;
        };

        var nullFormat = function(tick) {
            return tick;
        };

        var createLabelActivateCallback = function (params) {
          return function () {
            eventManager.trigger('labelActivate', params);
          };
        };

        var createTrendLine = function () {
            if(options.trendline && options.trendline.enabled) {
                var g = paper.group('trendline', tickContainer);
                trendLabel = paper.text(0, 0, options.trendline.label, g);
                trendLabel.attr({
                    x: -14,
                    'text-anchor': 'end',
                    'fill': options.trendline.color
                });
                trendLabel.node.setAttribute('class', 'rc-trendlabel');

            }
        };

        var createTicks = function(_tickValues, orientation) {

            var tempHolder = [];
            var showLabelFlag = shouldLabelBeShown();
            if(showLabelFlag) {
            for(var i=-1; ++i<_tickValues.length;) {
                if(options.labelStep && options.labelStep.interval) {
                    var interval = options.labelStep.interval + 1,
                        startIndex = options.labelStep.startIndex;
                    if(i >= startIndex && ((i - startIndex) % interval !== 0)) {
                        continue;
                    }
                }
                var tickLabel = showLabelFlag ? tickLabels[i] : '';
                var g = paper.group('tick-' + (i+1), tickContainer),
                    _ticks = paper.text(0 , 0, '' + tickLabel, g),
                    line = null;

                if(orientation === 'left') {
                    _ticks.attr({
                        x: -14,
                        'text-anchor': 'end'
                    });
                    
                    line = paper.path('m0,0 l-10,0', g);
                    line.node.setAttribute('class', 'rc-grid-line');

                    if(!options.tickLine) {
                        line.attr('opacity', 0);
                    }
                    
                } else if(orientation === 'bottom') {
                    _ticks.attr({
                        'text-anchor': 'middle',
                        'y': 14
                    });
                    
                    line = paper.path('m0,0 l0,10', g);
                    line.node.setAttribute('class', 'rc-grid-line');    

                    if(!options.tickLine) {
                        line.attr('opacity', 0);
                    }
                } else if(orientation === 'right') {
                    _ticks.attr({
                        x: 14,
                        'text-anchor': 'start'
                    });
                    
                    line = paper.path('m0,0 l10,0', g);
                    line.node.setAttribute('class', 'rc-grid-line');
                    if(!options.tickLine) {
                        line.attr('opacity', 0);
                    }
                } else if(orientation === 'top') {
                    _ticks.attr({
                        'text-anchor': 'middle',
                        'y': -14
                    });
                }
                tempHolder[i] = g;
                if(eventManager) {
                  _ticks.click(createLabelActivateCallback({
                    label: tickLabels[i]
                  }));
                }
            }
        }

            return tempHolder;
        };

        var createMultilineTick = function(words, idx, orientation) {
            var g = paper.group('tick-' + (idx + 1), tickContainer),
                // _ticks = [],
                line = null;
            for(var i=-1; ++i<words.length;) {

                var _ticks = paper.text(0, 0, '' + words[i], g);

                if(orientation === 'left') {
                    _ticks.attr({
                        'text-anchor': 'end',
                        'y': i * 14
                    });
                    if(options.tickLine) {
                        line = paper.path('m5,0 l10,0', g);
                        line.node.setAttribute('class', 'rc-grid-line');    
                    }
                } else if(orientation === 'bottom') {
                    _ticks.attr({
                        'text-anchor': 'middle',
                        'y': 14 + i * 14
                    });
                    if(options.tickLine) {
                        line = paper.path('m5,0 l0,10', g);
                        line.node.setAttribute('class', 'rc-grid-line');    
                    }
                } else if(orientation === 'right') {
                    _ticks.attr({
                        'text-anchor': 'start',
                        'y': i * 14
                    });
                } else if(orientation === 'top') {
                    _ticks.attr({
                        'text-anchor': 'middle',
                        'y': -14 + i * 14
                    });
                }
            }
            return g;
        };

        var createTiltedTick = function(label, idx, width, orientation) {
            var labelWidth = labelWidths[label];
            var maxWidth = height * MAX_AXIS_PERCENT * 2;
            // var correctLength = labelWidth < width ? labelWidth : label.length * (width / labelWidth),
            //     correctWidth = labelWidth < width ? labelWidth  : labelWidth * (width / labelWidth);
            var correctLength = label.length + 1;
            var correctWidth = labelWidth;
            var topPadding = TILTED_TICK_TOP_PADDING;
            if(labelWidth > maxWidth) {
                correctLength = Math.floor(label.length * (maxWidth / labelWidth));
                correctWidth = maxWidth;
                topPadding -= 5;
                label = label.slice(0, correctLength - 3) + (correctLength - 3 < label.length ? '...' : '');
            }
            
             var g = paper.group('tick-' + (idx + 1), tickContainer),
                _ticks = paper.text(0, 0, '' + label, g),
                line = null;

            if(orientation === 'left') {
                _ticks.attr({
                    'text-anchor': 'end'
                });
                if(options.tickLine) {
                    paper.path('m5,0 l10,0', g);
                }
            } else if(orientation === 'bottom') {
                _ticks.attr({
                    'text-anchor': 'middle',
                    y: topPadding
                });
                if(options.tickLine) {
                    line = paper.path('m0,0 l0,8', g);    
                }
            } else if(orientation === 'right') {
                _ticks.attr({
                    'text-anchor': 'start'
                });
            } else if(orientation === 'top') {
                _ticks.attr({
                    'text-anchor': 'middle',
                    'y': -14
                });
            }
            // No matter the size of the label the parent g element stays in place, to counter this we need to change the x from the width after it is tilted
            // The 6 in the end is half height of the text
            _ticks.transform('r-45t-' + (correctWidth / 2) + ',0');

            return g;
        };

        var precise = function(num, precision) {
            var n = num.toString().split('.');
            if(n[1] && n[1].length > precision) {
                n[1] = n[1].slice(0, precision);
            }

            return parseFloat(n[0] + '.' + n[1]);
        };

        var sanitizePrecision = function(obj) {
            if(_.isNumber(obj)) {
                return precise(obj, 1);
            } else if(_.isArray(obj)) {
                for(var i=-1; ++i<obj.length;) {
                    obj[i] = precise(obj[i], 2);
                }
            }
            return obj;
        };

        var createTickValues = function() {
            var scale = options.scale,
                unit = Math.floor(options.dataMax / numTicks);
            if(scale.type === 'linear') {
                var domain = graphUtils.prettyDomain(options.dataMin < 0 ? options.dataMin : 0, options.dataMax),
                    newMin = domain.min,
                    newMax = domain.max;
                if(options.forceNumTicks) {
                    unit = graphUtils.prettyDomain(0, (domain.max - domain.min) / options.forceNumTicks).max;
                    if(domain.min < 0 && domain.max > 0) {
                        var minPercent = Math.abs(domain.min) / (domain.max - domain.min),
                            numTicksForMin = Math.floor(options.forceNumTicks * minPercent),
                            numTicksForMax = Math.floor(options.forceNumTicks * (1 - minPercent));

                        newMin = domain.min;
                        newMax = domain.max;
                        
                        if(numTicksForMin <= 0) {
                            numTicksForMin ++;
                            numTicksForMax --;
                        }
                        if(numTicksForMax <= 0) {
                            numTicksForMin --;
                            numTicksForMax ++;
                        }
                        if((numTicksForMin + numTicksForMax) === options.forceNumTicks) {
                            if(numTicksForMin > numTicksForMax) {
                                numTicksForMin--;
                            } else {
                                numTicksForMax--;
                            }
                        }
                        unit = Math.round(Math.abs(newMin / numTicksForMin) - 1);
                        unit = graphUtils.prettyDomain(0, unit).max;
                        newMin = -Math.round(unit * numTicksForMin);    
                        newMax = Math.round(unit * numTicksForMax);
                        if(Math.abs(domain.min) > Math.abs(domain.max)) {
                            unit = Math.abs(domain.min / numTicksForMin);
                            newMax = unit * numTicksForMax;
                            newMin = -(unit * numTicksForMin);
                        } else {
                            unit = domain.max / numTicksForMax;
                            newMin = -(unit * numTicksForMin);
                        }
                    }
                    for(var i=-1; ++i<options.forceNumTicks;) {
                        tickValues.push(sanitizePrecision(newMin + unit * i));
                    }
                        
                } else if(options.forceDomain) {
                    domain = options.domain;
                    tickValues = sanitizePrecision(domain.ticks);
                } else if (options.minValue !== null || options.maxValue !== null) {
                    var min = options.minValue === null ?  scale.min() : options.minValue;
                    var max = options.maxValue === null ? scale.max() : options.maxValue;
                    var numTicks = options.numTicks - 1 || 5;
                    var unit = (max - min) / numTicks;
                    for(var i=-1; ++i<numTicks + 1;) {
                        tickValues[i] = sanitizePrecision(min + unit * i);
                    }
                } else {
                    tickValues = sanitizePrecision(domain.ticks);
                }
                scale.domain([_.min(tickValues), _.max(tickValues)]);
                // for(var i=-1; ++i<numTicks+1;) {
                //     tickValues.push(unit * i);
                // }
            } else if(scale.type === 'ordinal') {
                tickValues = scale.domain();
            }

            tickLabels = _.map(tickValues, format);
        };

        var findLabelWidths = function(labels) {
            for(var i=-1;++i<labels.length;) {
                var temp = paper.text(0,0, labels[i], core);
                labelWidths[labels[i]] = temp.getBBox().width;
                temp.remove();
            }
        };

        var findWordWidths = function(labels) {
            var words = extractWords(labels);
            for(var i=-1; ++i<words.length;) {
                var temp = paper.text(0,0, words[i], core);
                wordWidths[words[i]] = temp.getBBox().width;
                temp.remove();
            }
        };

        var extractWords = function(labels) {
            var list = [];
            for(var i=-1; ++i<labels.length;) {
                var label = labels[i];
                list = list.concat(label.split(' '));
            }

            return list;
        };

        var getLines = function(label, width) {
            // TODO: Fix a bug with the line becoming one worded later
            var words = label.split(' ');

            var lengths = _.values(_.pick(wordWidths, words));
            var lines = 1;
            var wordsLine = [''];
            var sum = 0;
            for (var i = 0; i < words.length; i++) {
                if (sum + lengths[i] < width) {
                  sum += lengths[i];
                  wordsLine[lines - 1] += (' ' + words[i]);
                } else {
                  lines++;
                  wordsLine[lines - 1] = ' ' + words[i];
                  sum = lengths[i];
                }
            }

            return {
                numLines: lines,
                words: wordsLine
            };
        };

        var shouldWeTilt = function(labels, width) {
            var tilt = false;
            for(var i=-1;++i<labels.length;) {
                var words = labels[i].split(' '),
                    lengths = _.values(_.pick(wordWidths, words)),
                    maxLength = _.max(lengths);
                if(maxLength > width) {
                    tilt = true;
                    break;
                }
            }
            
            return tilt;
        };

        var shouldLabelBeShown = function() {

            if(typeof options.showLabelFlag === 'undefined'){
                return true;
            }
            else {
                return options.showLabelFlag;
            }
        }

        var readjustNumTicks = function () {
            var unit = (options.type === 'left' || options.type === 'right') ? height : width;

            if(options.scale.type === 'linear' && unit) {
                var threshold = unit / (tickValues.length - 1);
                if(threshold < MIN_TICK_THRESHOLD) {
                    var hasNegative = _.min(tickValues) < 0;
                    tickValues = [];
                    options.forceNumTicks = Math.floor(height / MIN_TICK_THRESHOLD) + 1;
                    options.forceNumTicks = hasNegative ? options.forceNumTicks < 3 ? 3 : options.forceNumTicks : options.forceNumTicks < 2 ? 2 : options.forceNumTicks;
                    createTickValues ();
                    for(i=-1; ++i<ticks.length;) {
                        ticks[i].remove();
                        ticks[i] = null;
                    }
                    ticks = createTicks(tickValues, options.type);
                }
            }
        }
    };

    return Axis;
});
define('razorcharts/axes/grid',['razorcharts/utils/graphutils', 'razorcharts/utils/pathgen', 'razorcharts/scales/scale', 'vendor/lodash'], function(graphUtils, PathGen, Scale, _) {
    var Grid = function() {
        var self = this,    
            options = null,
            paper = null,
            core = null,
            width = null,
            height = null,
            yGridLines = [],
            xGridLines = [],
            oldYScale = null,
            oldXScale = null,
            gridContainer = null,
            oldYTicks = null,
            oldXTicks = null,
            trendLineElement;

        self.config = function(_options) {
            options = _options;
        };

        self.updateConfig = function(_options) {
            options = _.extend(options, _options);
        };

        self.renderTo = function(_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            cacheScales();
            draw(true, false);
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            cacheScales();
            draw(false, false);
        };
        
        self.update = function(w, h) {
            width = w;
            height = h;
            draw(true, true, true);
        };

        var draw = function(create, animate, update) {
            var yScale = null,
                yTicks = null,
                yAxis = null,
                xScale = null,
                xTics = null,
                xAxis = null,
                i, pathGen, newpath, tick, gridLine, scale,
                path = '';

            if(options.type.indexOf('y') !== -1) {
                yScale = options.yScale,
                yTicks = options.yAxis.ticks(),
                yAxis = options.yAxis;
            }
            if(options.type.indexOf('x') !== -1) {
                xScale = options.xScale,
                xTicks = options.xAxis.ticks(),
                xAxis = options.xAxis;
            }

            var oldYLines = null;
            if(create) {
                gridContainer = paper.group('rc-grid', core);
                gridContainer.node.setAttribute('class', 'rc-grid');
            }
            if(update) {
                if(options.type.indexOf('y') !== -1) {

                    oldYLines = _.clone(yGridLines);
                    for(i=-1; ++i<oldYLines.length;) {
                        pathGen = new PathGen();
                        newpath = pathGen.moveTo(0, height - yScale.calc(oldYTicks[i])).lineTo(width, height - yScale.calc(oldYTicks[i])).path();
                        oldYLines[i].animate({
                            path: newpath,
                            opacity: 0
                        }, 500);
                    }

                    setTimeout(function() {
                        for(i=-1; ++i<oldYLines.length;) {
                            oldYLines[i].remove();
                            oldYLines[i] = null;
                        }
                        oldYLines = [];
                    }, 500);
                }
                
                if(options.type.indexOf('x') !== -1) {
                    oldXLines = _.clone(xGridLines);
                    for(i=-1; ++i<oldXLines.length;) {
                        pathGen = new PathGen();
                        newpath = pathGen.moveTo(xScale.calc(oldXTicks[i]), 0).lineTo(xScale.calc(oldXTicks[i]), height).path();
                        oldXLines[i].animate({
                            path: newpath,
                            opacity: 0
                        }, 500);
                    }

                    setTimeout(function() {
                        for(i=-1; ++i<oldXLines.length;) {
                            oldXLines[i].remove();
                            oldXLines[i] = null;
                        }
                        oldXLines = [];
                    }, 500);
                }
            }
            if(options.type.indexOf('y') !== -1) {
                for(i=-1; ++i<yTicks.length;) {
                    tick = yTicks[i];
                    gridLine = null;
                    pathGen = new PathGen();
                    scale = null;
                    
                    scale = update ? oldYScale : yScale;
                    path = pathGen.moveTo(0, height - scale.calc(tick)).lineTo(width, height - scale.calc(tick)).path();
                    if(create) {
                        gridLine = yGridLines[i] = paper.path(path, gridContainer);
                        gridLine.node.setAttribute('class', 'rc-grid-line ' + (tick === 0 ? 'rc-grid-line-base' : ''));
                        gridLine.attr({
                            opacity: 0
                        });
                    } else {
                        gridLine = yGridLines[i];
                    }
                    if(update) {
                        pathGen.clear();
                        path =  pathGen.moveTo(0, height - yScale.calc(tick)).lineTo(width, height - yScale.calc(tick)).path();
                    }
                    
                    gridLine.animate({
                        path: path,
                        opacity: 1
                    }, animate ? 500: 0);
                }

                if(options.trendline && options.trendline.enabled) {
                    // Handle trendLinePath
                    var val = options.trendline.value;
                    var trendLinePath = new PathGen().moveTo(0, height - scale.calc(val)).lineTo(width, height - scale.calc(val)).path();

                    if(create) {
                        trendLineElement = paper.path(trendLinePath, gridContainer);
                        trendLineElement.attr({
                            opacity: 1,
                        });
                        trendLineElement.node.setAttribute("class", "rc-trendlabel");
                    }
                    else {
                        trendLineElement.attr({
                            path: trendLinePath
                        })
                    }
                }


            }
            if(options.type.indexOf('x') !== -1) {
                for(i=-1; ++i<xTicks.length;) {
                    tick = xTicks[i];
                    gridLine = null;
                    pathGen = new PathGen();
                    scale = null;
                    scale = update ? oldXScale : xScale;
                    path = pathGen.moveTo(scale.calc(tick), 0).lineTo(scale.calc(tick), height).path();
                    if(create) {
                        gridLine = xGridLines[i] = paper.path(path, gridContainer);
                        gridLine.node.setAttribute('class', 'rc-grid-line ' + (tick === 0 ? 'rc-grid-line-base' : ''));
                        gridLine.attr({
                            opacity: 0
                        });
                    } else {
                        gridLine = xGridLines[i];
                    }
                    if(update) {
                        pathGen.clear();
                        path =  pathGen.moveTo(xScale.calc(tick), 0).lineTo(xScale.calc(tick), height).path();
                    }
                    
                    gridLine.animate({
                        path: path,
                        opacity: 1
                    }, animate ? 500: 0);
                }
            }

            gridContainer.toBack();
            cacheScales();
        };

        var cacheScales = function() {
             var yScale = options.yScale,
                xScale = options.xScale,
                xAxis = options.xAxis,
                yAxis = options.yAxis;
            if(options.type.indexOf('y') !== -1) {
                oldYScale = new Scale.linear();
                oldYScale.domain(yScale.domain());
                oldYScale.range(yScale.range());
                oldYTicks = yAxis.ticks();
            }
            if(options.type.indexOf('x') !== -1) {
                oldXScale = new Scale.linear();
                oldXScale.domain(xScale.domain());
                oldXScale.range(xScale.range());
                oldXTicks = xAxis.ticks();
            }
        };
    };

    return Grid;
});
define('razorcharts/charts/linearchart',['razorcharts/renderers/column', 
        'razorcharts/renderers/line', 
        'razorcharts/renderers/area', 
        'razorcharts/scales/scale', 
        'razorcharts/axes/axis', 
        'razorcharts/axes/grid', 
        'razorcharts/utils/graphutils', 
        'razorcharts/utils/tooltip',
        'vendor/lodash'], function (Column, Line, Area, Scale, Axis, Grid, graphUtils, Tooltip, _) {
    var LinearChart = function () {
        var self = this,
            options = {},
            stacked = false,
            xAxisGroup = null,
            yAxisGroup = null,
            xAxis = null,
            yAxis = {},
            container = null,
            core = null,
            series = null,
            charts = {},
            xScale = null,
            yScale = {},
            rightYScale = null,
            allData = [],
            dataByAxisType = {
                'left': [],
                'right': []
            },
            dataByChartType = {

            },
            stackedByChartType = {},
            paper = null,
            yAxisWidth = null,
            xAxisHeight = null,
            width = null,
            height = null,
            grid = null,
            dualAxis = false,
            eventManager = null,
            tooltip = new Tooltip();

        self.config = function (_options) {
            var chartSeriesByType = {},
                chartTypeKeys = [],
                i;
            options = _options;
            series = options.series,
            labels = options.labels;
            // stacked = _.reduce(series, function(item, mem) {
            //     return mem.stacked || item.stacked;
            // });
            var dataList = _.flatten(_.pluck(series, 'data'));
            chartTypeKeys = _.uniq(_.pluck(series, 'displayType'));
            var seriesIndex = 1;
            for(var c=-1; ++c<chartTypeKeys.length;) {
                var chartType = chartTypeKeys[c];
                var _series = _.where(series, {displayType: chartType});
                // debugger
                if(_series.length > 1) {
                    stackedByChartType[chartType] = _.reduce(_series, function(item, mem) {
                        return mem.stacked || (item && item.stacked);
                    });
                } else {
                    stackedByChartType[chartType] = series[0].stacked;
                }
                    

                chartSeriesByType[chartType] = _series;
                var _data = [];
                if(stackedByChartType[chartType]) {
                    for(i=-1; ++i<_series.length;) {
                        for(var j=-1; ++j<_series[i].data.length;) {
                            if(typeof _data[j] === 'undefined') {
                                 _data[j] = 0;
                             }
                            if(_data[j] < 0 && _series[i].data[j] > 0 || _data[j] > 0 && _series[i].data[j] < 0) {
                                _data.push(_series[i].data[j]);
                            }
                            _data[j] += _series[i].data[j];
                        }
                    }
                } else {
                    for(i=-1; ++i<_series.length;) {
                        _data = _data.concat(_series[i].data);
                    }
                }
                allData = allData.concat(_data);
                dataByChartType[chartType] = _data;
                for(var l=-1; ++l<_series.length;) {
                    var item = _series[l];
                    item.seriesIndex = (item.seriesIndex + 1) || seriesIndex++;
                    dataByAxisType[item.yAxis || 'left'] = dataByAxisType[item.yAxis || 'left'].concat(item.data);    
                }
                
            }

            dualAxis = options.dualAxis;
            eventManager = options.eventManager;
            
            var max = _.max(allData),
                min = _.min(dataList);
            
            xScale = new Scale.ordinal();
            xScale.domain(options.labels);
            if(options.dualAxis) {
                max = _.max(dataByAxisType['left']),
                min = _.min(dataByAxisType['left']);

                yScale['left'] = new Scale.linear();
                if(options.yAxis[0].minValue) {
                    var min = options.yAxis[0].minValue;
                    yScale['left'].domain([min, max]);
                } else {
                    yScale['left'].domain([min < 0 ? min : 0, max]);    
                }
                

                max = _.max(dataByAxisType['right']);
                min = _.min(dataByAxisType['right']);

                yScale['right'] = new Scale.linear();
                 if(options.yAxis[1].minValue) {
                    var min = options.yAxis[1].minValue;
                    yScale['right'].domain([min, max]);
                } else {
                    yScale['right'].domain([min < 0 ? min : 0, max]);    
                }
            } else {
                yScale = new Scale.linear();
                if(options.yAxis.minValue) {
                    var min = options.yAxis.minValue;
                    yScale.domain([min, max]);
                } else {
                    yScale.domain([min < 0 ? min : 0, max]);
                }
            }
                

            for(var key in chartSeriesByType) {
                if(chartSeriesByType.hasOwnProperty(key)) {
                    charts[key] = createChartByType(key);
                    charts[key].config({
                        yScale: yScale,
                        stacked: stackedByChartType[key],
                        stackedTotalDisplay: options.stackedTotalDisplay,
                        series: chartSeriesByType[key],
                        dualAxis: !!options.dualAxis,
                        animateOnRender: !!options.animateOnRender,
                        eventManager: eventManager,
                        labels: labels,
                        tooltip: tooltip,
                        plotItemClasses: options.plotItemClasses
                    });
                }
            }

            if(options.dualAxis) {
                var lMin = _.min(dataByAxisType['left']) < 0 ? _.min(dataByAxisType['left']) : 0;
                var rMin = _.min(dataByAxisType['right']) < 0 ? _.min(dataByAxisType['right']) : 0;
                var domains = graphUtils.dualAxisDomain([lMin, _.max(dataByAxisType['left'])], [rMin, _.max(dataByAxisType['right'])]);
                if(options.yAxis[0].minValue || options.yAxis[0].maxValue || options.yAxis[1].minValue || options.yAxis[1].maxValue) {
                    if(options.yAxis[0].numTicks !== options.yAxis[1].numTicks) {
                        throw "numTicks for both axes should be same";
                    }                    

                    var min = options.yAxis[0].minValue || 0;
                    var max = options.yAxis[0].maxValue || _.max(dataByAxisType['left']);
                    var numTicks = options.yAxis[0].numTicks - 1 || 5;
                    var unit = (max - min) / numTicks;
                    for(var i=-1; ++i<numTicks + 1;) {
                        domains['lDomain'].ticks[i] = (min + unit * i);
                    }

                    min = options.yAxis[1].minValue || 0;
                    max = options.yAxis[1].maxValue || _.max(dataByAxisType['left']);
                    numTicks = options.yAxis[1].numTicks - 1 || 5;
                    unit = (max - min) / numTicks;
                    for(var i=-1; ++i<numTicks + 1;) {
                        domains['rDomain'].ticks[i] = (min + unit * i);
                    }
                }
                yAxis['left'] = new Axis();
                if(dataByAxisType.left.length) {
                    yAxis['left'].config(_.extend(_.where(options.yAxis, {type: 'left'})[0] || {}, {
                        scale: yScale['left'],
                        type: 'left',
                        forceDomain: true,
                        domain: domains.lDomain,
                        dataMin: min,
                        dataMax: max
                    }));
                }
                yAxis['right'] = new Axis();
                if(dataByAxisType.right.length) {
                    yAxis['right'].config(_.extend(_.where(options.yAxis, {type: 'right'})[0] || {}, {
                        scale: yScale['right'],
                        type: 'right',
                        forceDomain: true,
                        domain: domains.rDomain,
                        dataMin: min,
                        dataMax: max
                    }));
                }
            } else {
                yAxis = new Axis();
                yAxis.config(_.extend(options.yAxis || {}, {
                    scale: yScale,
                    type: 'left',
                    dataMin: min,
                    dataMax: max,
                    trendline: options.trendline
                }));
            }

            xAxis = new Axis();
            xAxis.config(_.extend(options.xAxis || {}, {
                scale: xScale,
                type: 'bottom',
                eventManager: eventManager,
                tooltip: options.axesTooltip,
                showLabelFlag: options.showLabelFlag,
                labelStep: options.labelStep
            }));

            grid = new Grid();
            grid.config({
                yScale: options.dualAxis ? yScale['left'] : yScale,
                yAxis: options.dualAxis ? yAxis['left'] : yAxis,
                type: 'y',
                trendline: options.trendline
            });
            if(options.tooltip) {
                tooltip.config({
                    type: 'item',
                    display: 'custom',
                    popup: true,
                    onShow: options.tooltip.onShow,
                    onHide: options.tooltip.onHide,
                    data: function(seriesIndex, num) {
                        return {
                            label: options.labels[num],
                            data: [_.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].data[num]],
                            seriesIndex: [_.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].seriesIndex],
                            seriesLabels: [_.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].caption],
                            color: _.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].color
                        };
                    }
                });
            } else {
                tooltip.config({
                    type: 'item',
                    numLabels: 1,
                    popup: true,
                    popupType: 'top',
                    data: function(seriesIndex, num) {
                        return {
                            label: options.labels[num],
                            data: [options.series[seriesIndex].data[num]],
                            seriesIndex: [_.pluck(options.series, 'seriesIndex')[seriesIndex]],
                            seriesLabels: [_.pluck(options.series, 'caption')[seriesIndex]]
                        };
                    }
                });
            }
                
        };

        self.renderTo = function (_paper, w, h) {
            paper = _paper;
            container = paper.group('container');
            xAxisGroup = paper.group('xAxis', container);
            if(dualAxis) {
                yAxisGroup = {};
                yAxisGroup['left'] = paper.group('yAxis-left', container);
                yAxisGroup['right'] = paper.group('yAxis-right', container);
            } else {
                yAxisGroup = paper.group('yAxis', container);    
            }
            
            core = paper.group('core', container);
            width = w;
            height = h - 20;
            container.transform('t0, 10');
            if(dualAxis) {
                yScale['left'].range([0, height]);
                yScale['right'].range([0, height]);
                if(dataByAxisType.left.length) {
                    yAxis['left'].renderTo(paper, yAxisGroup['left'], null, height);
                }
                if(dataByAxisType.right.length) {
                    yAxis['right'].renderTo(paper, yAxisGroup['right'], null, height);
                }
                yAxisWidth = yAxisGroup['left'].node.getBBox().width + yAxisGroup['right'].node.getBBox().width;
            } else {
                yScale.range([0, height]);    
                yAxis.renderTo(paper, yAxisGroup, null, height);
                yAxisWidth = yAxisGroup.node.getBBox().width;
            }
            
            xScale.range([0, width]);
            
            xScale.range([0, width - yAxisWidth]);
            xAxis.setOffsets(yAxisWidth, height);
            xAxis.renderTo(paper, xAxisGroup, width - yAxisWidth, height);
            xAxisHeight = xAxisGroup.node.getBBox().height;

            if(dualAxis) {
                yScale['left'].range([0, height - xAxisHeight]);
                yScale['right'].range([0, height - xAxisHeight]);
                if(dataByAxisType.left.length) {
                    yAxis['left'].resizeTo(width, height - xAxisHeight);
                }
                if(dataByAxisType.right.length) {
                    yAxis['right'].resizeTo(width, height - xAxisHeight);
                }
                yAxisGroup['right'].transform('t' + (width - yAxisGroup['right'].node.getBBox().width) + ' ,0');
                // yAxisWidth = yAxisGroup['left'].node.getBBox().width + yAxisGroup['right'].node.getBBox().width;
            } else {
                yScale.range([0, height - xAxisHeight]);
                yAxis.resizeTo(w, height - xAxisGroup.node.getBBox().height);
                // yAxisWidth = yAxisGroup.node.getBBox().width;
            }
            
            // debugger
            var t = dualAxis ? yAxisGroup['left'].node.getBBox().width : yAxisGroup.node.getBBox().width;
            xAxisGroup.transform('t' + t +',' + (height - xAxisHeight));
            grid.renderTo(paper, core, width - yAxisWidth, height - xAxisHeight);

            if(charts['column']) {
                charts['column'].renderTo(paper, core, width - yAxisWidth, height - xAxisGroup.node.getBBox().height);
            }

            if(charts['area']) {
                charts['area'].renderTo(paper, core, width - yAxisWidth, height - xAxisGroup.node.getBBox().height);
            }

            if(charts['line']) {
                charts['line'].renderTo(paper, core, width - yAxisWidth, height - xAxisGroup.node.getBBox().height);
            }
            core.transform('t' + t + ',0');

            // for(var key in charts) {
            //     charts[key].renderTo(paper, core, width - yAxisWidth, height - xAxisGroup.node.getBBox().height);
                
            // }
            tooltip.renderTo(paper, core, width - yAxisWidth, height - xAxisHeight, yAxisWidth, 0);
        };

        self.resizeTo = function (w, h) {
            width = w;
            height = h - 20;
            updateAxesSizes();
            if(dualAxis) {
                yAxisWidth = yAxisGroup['left'].node.getBBox().width + yAxisGroup['right'].node.getBBox().width;
            }
            xScale.range([0, width - yAxisWidth]);
            xAxis.setOffsets(yAxisWidth, height);
            xAxis.resizeTo(width - yAxisWidth, height);
            if(dualAxis) {
                xAxisGroup.transform('t' +  yAxisGroup['left'].node.getBBox().width +',' + (height - xAxisHeight));    
            } else {
                xAxisGroup.transform('t' +  yAxisGroup.node.getBBox().width +',' + (height - xAxisHeight));    
            }
            
            updateAxesSizes();
            if(dualAxis) {
                yScale['left'].range([0, height - xAxisHeight]);
                yScale['right'].range([0, height - xAxisHeight]);
                if(dataByAxisType.left.length) {
                    yAxis['left'].resizeTo(width, height - xAxisHeight);
                }
                if(dataByAxisType.right.length) {
                    yAxis['right'].resizeTo(width, height - xAxisHeight);
                }
                yAxisGroup['right'].transform('t' + (width - yAxisGroup['right'].node.getBBox().width) + ' ,0');

            } else {
                yScale.range([0, height - xAxisHeight]);
                yAxis.resizeTo(width, height - xAxisHeight);
            }

            var diff = 0;
            if(dualAxis && diff > 0) {
                diff = xAxisGroup._getBBox().width + yAxisGroup['right']._getBBox().width - width;
                xScale.range([0, width - yAxisWidth - diff]);
                xAxis.resizeTo(width - yAxisWidth - diff, height);
                xAxisGroup.transform('t' + diff +',' + (height - xAxisHeight));
            }
            
            if(dualAxis && !dataByAxisType.left.length) {
                grid.updateConfig({
                    yScale: yScale['right'],
                    yAxis: yAxis['right'],
                    type: 'y'
                });
                grid.renderTo(paper, core, width - yAxisWidth - diff, height - xAxisHeight);
            }

            grid.resizeTo(width - yAxisWidth - diff, height - xAxisHeight);

            if(dualAxis) {
                yAxisWidth = yAxisGroup['left'].node.getBBox().width + yAxisGroup['right'].node.getBBox().width;
            }
            for(var key in charts) {
                if(charts.hasOwnProperty(key)) {
                    charts[key].resizeTo(width - yAxisWidth - diff, height - xAxisHeight);
                }
            }
            if(dualAxis) {
                yAxisWidth = yAxisGroup['left'].node.getBBox().width;
            }
            core.transform('t' + (yAxisWidth + diff) + ',0');
            
            tooltip.resizeTo(width, height, yAxisWidth, 0);
        };

        var updateAxesSizes = function() {
            var oldyAxisWidth = yAxisWidth,
                oldxAxisHeight = xAxisHeight;
            if(!dualAxis) {
                yAxisWidth = yAxisGroup.node.getBBox().width;
            }
            xAxisHeight = xAxisGroup.node.getBBox().height;
            return oldxAxisHeight !== xAxisHeight || oldyAxisWidth !== yAxisWidth;
        };

        self.updateSeries = function (_series) {
            var chartSeriesByType = {},
                chartTypeKeys = [],
                i;
            // for(var key in charts) {
            //     charts[key].resizeTo(width - yAxisWidth, height - xAxisHeight);
            //     core.transform('t' + yAxisWidth + ',0');
            // }
            for(i=-1; ++i<_series.length;) {
                var id = _series[i].id;
                if(id) {
                    var obj = _.each(_.where(series, {id: id}), function(item) {
                        item.data = _series[i].data;
                    });
                } else if(_.isArray(_series[i])) {
                    series[i].data = _series[i];
                }
            }

            allData = [];
            dataByAxisType = {
                'left': [],
                'right': []
            };
            // for(var i = -1; ++i<series.length;) {
            //     var item = series[i];
            //     if(stacked) {
            //         for(var j=-1;++j<item.data.length;) {
            //             allData[j] = allData[j] 
            //                     ? ((allData[j] < 0 && item.data[j] > 0 ) || (allData[j] > 0 && item.data[j] < 0)) ? allData[j] : allData[j] + item.data[j]
            //                     : item.data[j];
            //         }
            //     } else {
            //         allData = allData.concat(item.data);    
            //     }
            // }
            for(i = -1; ++i<series.length;) {
                var item = series[i];
                if(!chartSeriesByType[item.displayType]) {
                    chartSeriesByType[item.displayType] = [];
                }
                item.seriesIndex = i + 1;
                chartSeriesByType[item.displayType].push(item);
                if(options.stacked) {
                    for(var j=-1;++j<item.data.length;) {
                        allData[j] = allData[j] ?
                                ((allData[j] < 0 && item.data[j] > 0 ) || (allData[j] > 0 && item.data[j] < 0)) ? allData[j] : allData[j] + item.data[j] :
                                item.data[j];
                        dataByAxisType[item.yAxis][j] = dataByAxisType[item.yAxis][j] ?
                                                    ((dataByAxisType[item.yAxis][j] < 0 && item.data[j] > 0 ) || (dataByAxisType[item.yAxis][j] > 0 && item.data[j] < 0)) ? dataByAxisType[item.yAxis][j] : dataByAxisType[item.yAxis][j]+ item.data[j] :
                                                    item.data[j];
                    }

                } else {
                    dataByAxisType[item.yAxis || 'left'] = dataByAxisType[item.yAxis || 'left'].concat(item.data);
                    allData = allData.concat(item.data);    
                }
            }

            var max = _.max(allData),
                min = _.min(allData);
            if(dualAxis) {
                max = _.max(dataByAxisType['left']),
                min = _.min(dataByAxisType['left']);

                yScale['left'].domain([min < 0 ? min : 0, max]);
                yAxis['left'].update();
                var domain = graphUtils.prettyDomain(min < 0 ? min : 0, max);
                max = _.max(dataByAxisType['right']);
                min = _.max(dataByAxisType['right']);

                yScale['right'].domain([min < 0 ? min : 0, max]);
                yAxis['right'].setConfigValue('forceNumTicks',domain.numTicks);
                yAxis['right'].update();
            } else {
                yScale.domain([min < 0 ? min : 0, max]);
                yAxis.update();
            }

            // if(dualAxis) {
            //     yScale['left'].domain([min < 0 ? min : 0, max]);
            //     yAxis.update();
            // } else {
            //     yScale.domain([min < 0 ? min : 0, max]);
            //     yAxis.update();    
            // }
            if(dualAxis) {
                yAxisWidth = yAxisGroup['left'].node.getBBox().width + yAxisGroup['right'].node.getBBox().width;
            }
            grid.update(width - yAxisWidth, height - xAxisHeight);
            updateAxesSizes();
            xScale.range([0, width - yAxisWidth]);
            xAxis.resizeTo(width - yAxisWidth, height);
            for(var key in charts) {
                if(charts.hasOwnProperty(key)) {
                    charts[key].updateSeries(width - yAxisWidth, height - xAxisHeight);
                }
            }
            if(dualAxis) {
                yAxisWidth = yAxisGroup['left'].node.getBBox().width;
            }

            core.animate({'transform': 't' + yAxisWidth + ',0'}, 500);

            xAxisGroup.transform('t' + yAxisWidth +',' + (height - xAxisHeight));
        };


        var createChartByType = function (type) {
            if(type === 'column') {
                return new Column();
            } else if(type === 'line') {
                return new Line();
            } else if(type === 'area') {
                return new Area();
            }

            throw new Error("Chart type `" + type + "` is not found!");
        };
    };

    return LinearChart;
    });
define('razorcharts/renderers/bar',['vendor/lodash'], function(_) {
    var BarChart = function() {
        var  SERIES_PADDING = 0.2;
        var self = this,
            options = null,
            paper = null,
            core = null,
            barCore = null,
            width = null,
            height = null,
            seriesGroups = [],
            seriesPlotItems = [];

        self.config = function(_options) {
            options = _options;
            eventManager = options.eventManager;

            eventManager.register('plotItemClick');
            eventManager.register('plotItemMouseOver');
            eventManager.register('plotItemMouseOut');
            eventManager.register('plotItemActivate');
        };

        self.renderTo = function(_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            draw(true, true && options.animateOnRender);
            for(var i=-1; ++i<seriesPlotItems.length;) {
                options.tooltip.addSeriesItems(options.series[i].seriesIndex, seriesPlotItems[i]);
            }
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            draw(false, false);
        };

        self.updateSeries = function(w, h) {
            width = w;
            height = h;
            draw(false, true);
        };

        var draw = function(create, animate) {
             var xScale = options.xScale,
                series = options.series,
                dataLength = _.max(_.pluck(_.pluck(series, 'data'), 'length')),
                seriesFullHeight =  (height / dataLength),
                seriesHeight = seriesFullHeight * (1 - SERIES_PADDING),
                columnHeight = options.stacked ? seriesHeight : (seriesHeight / series.length),
                padding = seriesFullHeight * SERIES_PADDING;
            if(create) {
                barCore = paper.group('rc-bar-chart', core);
                barCore.node.setAttribute('class', 'rc-bar-chart');
            }
            for(var i=-1; ++i<series.length;) {
                var data = series[i].data,
                    classes = ' rc-series-' + series[i].seriesIndex + ' rc-plot-item' + ' ' + (options.plotItemClasses || '');
                if(create) {
                    seriesGroups[i] = paper.group('column-series' + (i+1), barCore);
                    seriesGroups[i].node.setAttribute('class', 'rc-series-' + series[i].seriesIndex);
                    if(!seriesPlotItems[i]) {
                        seriesPlotItems[i] = [];
                    }
                }
                
                for(var j=-1; ++j<data.length;) {
                    var rect;
                    var _x, _y, _w, _h;
                    var minTick = xScale.min () > 0 ? xScale.calc(xScale.min()) : xScale.calc(0);
                    if(options.stacked) {
                        if(xScale.min() < 0) {
                            if(data[j] < 0) {
                                _x = i > 0 ? xScale.calc(prevIndexTotal(i, j) + data[j]) : xScale.calc(data[j]);
                            } else {
                                _x = i > 0 ? xScale.calc(prevIndexTotal(i, j)) : xScale.calc(prevIndexTotal(i, j));
                            }
                        } else {
                            if(data[j] < 0) {
                                _x = i > 0 ? xScale.calc(prevIndexTotal(i, j) + data[j]) : xScale.calc(data[j]);
                            } else {
                                _x = i > 0 ? xScale.calc(prevIndexTotal(i, j)) : xScale.calc(prevIndexTotal(i, j) + xScale.min());
                            }
                        }
                            
                    } else {
                        _x = data[j] < 0 ? xScale.calc(data[j]) : minTick;    
                    }
                    _y = seriesFullHeight * j + padding / 2;
                    
                    
                    _w = xScale.calc(Math.abs(data[j])) - minTick;
                    if(xScale.min () > 0 && options.stacked && i > 0 && prevIndexTotal(i, j) !== xScale.min()) {
                        _w = xScale.calc(Math.abs(data[j] + xScale.min())) - minTick;
                    }
                    _h = columnHeight;
                    // _h = seriesHeight;
                    

                    if(create) {
                        rect = seriesPlotItems[i][j] = paper.rect(xScale.calc(0), _y, 0, _h, seriesGroups[i]);
                        rect.node.setAttribute('class', series[i].color !== 'auto' ? '' : (series[i].classed || '') + classes);
                        var params = {
                            seriesIndex: series[i].seriesIndex,
                            labelIndex: j,
                            value: data[j],
                            label: options.labels[j]
                        };
                        rect.click(createClickCallback(params));
                        rect.mouseover(createOverCallback(params));
                        rect.mouseout(createOutCallback(params));
                        if(series[i].color !== 'auto') {
                            rect.attr({
                                fill: series[i].color,
                                stroke: 'none'
                            });
                        }
                    } else{
                        rect = seriesPlotItems[i][j];
                    }
                    rect.animate({
                        x: _x,
                        y: _y,
                        width: _w,
                        height: _h
                    }, animate ? 500 : 0);
                }
                if(!options.stacked) {
                    seriesGroups[i].transform("t0," + (columnHeight * i));    
                }
            }
        };
        var createClickCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemClick', params);
                eventManager.trigger('plotItemActivate', params);
            };
        };
        var createOverCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemMouseOver', params);
            };
        };
        var createOutCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemMouseOut', params);
            };
        };

         var prevIndexTotal = function(currentSeriesIndex, dataIndex) {
            var series = options.series;
            var num = 0, negative = series[currentSeriesIndex].data[dataIndex] < 0;
            for(var i=currentSeriesIndex - 1; i >= 0; --i) {
                var val = series[i].data[dataIndex];
                num += negative ? (val < 0) ? val : 0 : (val > 0) ? val : 0;
            }
            return num;
        };
    };

    return BarChart;
});
define('razorcharts/charts/barchart',['razorcharts/renderers/bar',
        'razorcharts/scales/scale', 
        'razorcharts/axes/axis', 
        'razorcharts/axes/grid',
        'razorcharts/utils/tooltip',
        'vendor/lodash'], function (Bar, Scale, Axis, Grid, Tooltip, _) {
    var xPadding = 30,
        yPadding = 20;
    var BarChart = function () {
        var self = this,
            options = {},
            xAxisGroup = null,
            yAxisGroup = null,
            xAxis = null,
            yAxis = null,
            core = null,
            series = null,
            charts = {},
            xScale = null,
            yScale = null,
            allData = [],
            paper = null,
            yAxisWidth = null,
            xAxisHeight = null,
            seriesGroups = [],
            seriesPlotItems = [],
            barChart = null,
            width = null,
            height = null,
            grid = null,
            tooltip = new Tooltip(),
            eventManager = null;

        self.config = function (_options) {
            options = _options;
            series = options.series;
            eventManager = options.eventManager;
            options.stacked = !!_.compact(_.pluck(series, 'stacked')).length;

            for(var i = -1; ++i<series.length;) {
                series[i].seriesIndex = series[i].seriesIndex !== undefined ? series[i].seriesIndex + 1 : (i + 1);
                var item = series[i];
                if(options.stacked) {
                    for(var j=-1;++j<item.data.length;) {
                        if(typeof allData[j] === 'undefined') {
                            allData[j] = {positive: 0, negative: 0};
                        }
                        
                        allData[j][item.data[j] < 0 ? 'negative': 'positive'] += item.data[j];
                        
                        // if(allData[j] > 0 && item.data[j] < 0 || allData[j] < 0 && item.data[j] > 0) {
                        //     allData.push(item.data[j]);
                        // } else {
                        //     allData[j] += item.data[j];
                        // }
                    }
                } else {
                    allData = allData.concat(item.data);    
                }
            }
        
            var max = options.stacked ? _.max(_.pluck(allData, 'positive')) : _.max(allData),
                min = options.stacked ? _.min(_.pluck(allData, 'negative')) : _.min(allData);
            
            yScale = new Scale.ordinal();
            yScale.domain(options.labels);

            xScale = new Scale.linear();
            xScale.domain([min < 0 ? min : 0 , max]);

            barChart = new Bar();
            barChart.config({
                xScale: xScale,
                stacked: !!options.stacked,
                series: options.series,
                animateOnRender: !!options.animateOnRender,
                eventManager: eventManager,
                labels: options.labels,
                tooltip: tooltip
            });

            yAxis = new Axis();
            yAxis.config(_.extend(options.yAxis || {}, {
                scale: yScale,
                type: 'left',
                showLabelFlag: options.showLabelFlag
            }));

            xAxis = new Axis();
            xAxis.config(_.extend(options.xAxis || {}, {
                scale: xScale,
                type: 'bottom',
                dataMin: min,
                dataMax: max
            }));

            grid = new Grid();
            grid.config({
                xScale: xScale,
                xAxis: xAxis,
                type: 'x'
            });
            if(options.tooltip) {
                tooltip.config({
                    type: 'item',
                    display: 'custom',
                    popup: true,
                    popupType: 'left',
                    onShow: options.tooltip.onShow,
                    onHide: options.tooltip.onHide,
                    data: function(seriesIndex, num) {
                        return {
                            label: options.labels[num],
                            data: [_.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].data[num]],
                            seriesIndex: [_.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].seriesIndex],
                            seriesLabels: [_.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].caption],
                            color: _.where(options.series, {'seriesIndex' : seriesIndex + 1})[0].color
                        };
                    }
                });
            } else {
                tooltip.config({
                    type: 'item',
                    numLabels: 1,
                    popup: true,
                    popupType: 'left',
                    data: function(seriesIndex, num) {
                        return {
                            label: options.labels[num],
                            data: [options.series[seriesIndex].data[num]],
                            seriesIndex: [_.pluck(options.series, 'seriesIndex')[seriesIndex]],
                            seriesLabels: [_.pluck(options.series, 'caption')[seriesIndex]]
                        };
                    }
                });
            }
                
        };

        self.renderTo = function (_paper, w, h) {
            width = w - xPadding;
            height = h - yPadding;
            var series = options.series;
            paper = _paper;
            xAxisGroup = paper.group('xAxis');
            yAxisGroup = paper.group('yAxis');
            core = paper.group('core');
            yScale.range([0, height]);
            xScale.range([0, width]);

            yAxis.renderTo(paper, yAxisGroup, null, height);
            yAxisGroup.transform('t0,10');
            yAxisWidth = yAxisGroup.node.getBBox().width;
            xScale.range([0, width - yAxisWidth]);

            
            xAxis.renderTo(paper, xAxisGroup, width - yAxisGroup.node.getBBox().width, null);
            xAxisHeight = xAxisGroup.node.getBBox().height;
            yScale.range([0, height - xAxisHeight]);
            
            yAxis.resizeTo(w, height - xAxisGroup.node.getBBox().height);
            yAxisWidth = yAxisGroup.node.getBBox().width;
            xAxisGroup.transform('t' + (yAxisGroup.node.getBBox().width + 10) +',' + (height - xAxisHeight + 10));

            grid.renderTo(paper, core, width - yAxisWidth, height - xAxisHeight);

            width = width - yAxisWidth;
            height = height - xAxisHeight;
            h = height - xAxisHeight;
            barChart.renderTo(paper, core, width, height);
            core.transform("t" + (yAxisWidth + 10) + ",10");
            tooltip.renderTo(paper, core, width, height, yAxisWidth, 0);
        };

        self.resizeTo = function (w, h) {
            width = w - xPadding;
            height = h - yPadding;
            yScale.range([0, height - xAxisHeight]);
            xScale.range([0, width - yAxisWidth]);
            xAxis.resizeTo(width - yAxisWidth, height);
            yAxis.resizeTo(width, height - xAxisHeight);
            xAxisGroup.transform('t' + (yAxisWidth + 10) +',' + (height - xAxisHeight + 10));
            grid.resizeTo(width - yAxisWidth, height - xAxisHeight);
            h = height - xAxisHeight;
            barChart.resizeTo(width - yAxisWidth, h);
            core.transform("t" + (yAxisWidth + 10) + ",10");
            tooltip.resizeTo(width, height, yAxisWidth, 0);
        };

        self.updateSeries = function (_series) {
            var series = options.series, i;
            for(i=-1; ++i<_series.length;) {
                var id = _series[i].id;
                var obj = _.each(_.where(series, {id: id}), function(item) {
                    item.data = _series[i].data;
                });
            }
            allData = [];
            for(i = -1; ++i<series.length;) {
                var item = series[i];
                if(options.stacked) {
                    for(var j=-1;++j<item.data.length;) {
                        allData[j] = allData[j] ?
                                ((allData[j] < 0 && item.data[j] > 0 ) || (allData[j] > 0 && item.data[j] < 0)) ? allData[j] : allData[j] + item.data[j] :
                                item.data[j];
                    }
                } else {
                    allData = allData.concat(item.data);    
                }
            }

            var max = _.max(allData),
                min = _.min(allData);
                
            xScale.domain([min < 0 ? min : 0 , max]);
            xAxis.update();
            grid.update(width, height);
            barChart.updateSeries(width, height);
            core.transform("t" + yAxisWidth + ",0");
        };


        var createChartByType = function (type) {
            if(type === 'column') {
                return new ColumnChart();
            }

            throw new Error("Chart type `" + type + "` is not found!");
        };
    };

    return BarChart;
});
define('razorcharts/utils/timer',[], function() {
    var FPS = 1000 / 30;
    var tick = window.requestAnimationFrame || setTimeout;
    // TODO: Support timing functions like, ease-in, ease-out etc
    var Timer = function(cb, time, fcb) {
      var startTime = Date.now(),
          endTime = startTime + time,
          d = 0;
      
      var animationFunc = function() {
        cb(d);
        d = Date.now() - startTime;
        if(d > time) { cb(time); if(fcb) { fcb(); } return; }
        tick(animationFunc, FPS);
      };

      animationFunc();
    };

    return Timer;
});
define('razorcharts/renderers/pie',['razorcharts/utils/timer', 'razorcharts/utils/pathgen', 'razorcharts/utils/tooltip', 'vendor/lodash'], function(Timer, PathGen, Tooltip, _) {
    var Pie = function() {
        var PADDING = 0.2;
        var ARROW_RADIUS_PADDING = 90;
        var MIN_CHART_WIDTH = 30;
        var TOP_PADDING = 20;
        var self = this,
            options = null,
            paper = null,
            core = null,
            pieCore = null,
            width = null,
            height = null,
            pieGroup = null,
            pieSlices = [],
            labelSizes = [], pieRadius = null,
            registeredLabelPos = [],
            labelObjects = [],
            tooltip = new Tooltip(),
            sliceBBoxes = [],
            noLabels = false;

        var extraFuncs = {
            hasLabels: function() {
                findPieRadius(width / 2 - TOP_PADDING - ARROW_RADIUS_PADDING, labelSizes, options.series.data);
                return !noLabels;
            }
        };

        self.config = function(_options) {
            options = _options;
            options.series.format = options.series.format || function(item) {return item;};
            eventManager = options.eventManager;

            eventManager.register('plotItemClick');
            eventManager.register('plotItemMouseOver');
            eventManager.register('plotItemMouseOut');
            eventManager.register('plotItemActivate');
            if(options.tooltip) {
                tooltip.config({
                    type: 'item',
                    display: 'custom',
                    onShow: options.tooltip.onShow,
                    onHide: options.tooltip.onHide,
                    data: function(seriesIndex, num) {
                        return {
                            label: '',
                            seriesLabels: [options.labels[num]],
                            data: [options.series.data[num]],
                            seriesIndex: num + 1
                        };
                    }
                });
            } else {
                tooltip.config({
                    type: 'item',
                    numLabels: 1,
                    data: function(seriesIndex, num) {
                        return {
                            label: '',
                            seriesLabels: [options.labels[num]],
                            data: [options.series.data[num]],
                            seriesIndex: num + 1
                        };
                    }
                });
            }
        };

        self.renderTo = function(_paper, _core, w, h) {
            noLabels = false;
            paper = _paper;
            core = _core;
            width = w;
            height = h;
            findWidths(options.labels,options.series.data);
            pieRadius = findPieRadius((_.min([width, height]) / 2), labelSizes, options.series.data);
            draw(true, true && options.animateOnRender);
            tooltip.addItems(pieSlices);
            tooltip.renderTo(paper, core, width, height, 0, 0);
        };

        self.callFunction = function(func) {
            if(extraFuncs[func]) {
                return extraFuncs[func]();
            }
        };

        self.resizeTo = function(w, h) {
            noLabels = false;
            width = w;
            height = h;
            findWidths(options.labels,options.series.data);
            var r = width / 2 - TOP_PADDING - ARROW_RADIUS_PADDING;
            pieRadius = findPieRadius(r, labelSizes, options.series.data);
            if(pieRadius * 2 > height) pieRadius = findPieRadius(r - (pieRadius * 2 - height) / 2, labelSizes, options.series.data);
            if(noLabels || !options.showPieLabels) {
                hideAllLabels();
            } else {
                showAllLabels();
            }
            draw(false, false);
            tooltip.resizeTo(width, height, 0, 0);
        };

        self.updateSeries = function() {
            draw(false, true);
        };

        var hideAllLabels = function() {
            for(var i=-1; ++i<labelObjects.length;) {
                labelObjects[i].line.node.style.display = 'none';
                labelObjects[i].label.node.style.display = 'none';
                labelObjects[i].text.node.style.display = 'none';
            }
        };

        var showAllLabels = function(){
            for(var i=-1; ++i<labelObjects.length;) {
                labelObjects[i].line.node.style.display = 'block';
                labelObjects[i].label.node.style.display = 'block';
                labelObjects[i].text.node.style.display = 'block';
            }
        };

        var draw = function(create, animate) {
            var series = options.series,
                data = series.data,
                total = _.reduce(data, function(mem, item) {return mem + item;}),
                cx = width / 2,
                cy = height / 2, 
                r = pieRadius,
                ir = r;

            r = r - r * PADDING;

            // Temp fix
            if(noLabels || !options.showPieLabels) {
                r = _.min([width, height]) / 2;
                r *= 0.8;    
            }
            

            ir = options.donut ? r * 0.7 : 0;
            if(create) {
                pieCore = paper.group('pie-chart', core);
                pieCore.node.setAttribute('class', 'rc-pie-chart');
                pieGroup = paper.group('pie-series', pieCore);
                pieGroup.node.setAttribute('class', 'rc-pie-series');
            }
            registeredLabelPos = [];
            var startAngle = 0,
                endAngle = 0;

                for(var i=-1; ++i<data.length;) {
                    var datum = data[i],
                        slice = null,
                        path = '';
                    endAngle = startAngle + (datum / total) * 360;
                    if(!noLabels || options.showPieLabels) {
                        drawLabel(create, animate, cx, cy, (startAngle + endAngle) / 2, r, r + ARROW_RADIUS_PADDING, options.labels[i], i);    
                    }
                    if(create) {
                        var customColor = options.series.colors ? options.series.colors[i] === 'auto' ? '' : options.series.colors[i] : '';
                        slice = pieSlices[i] = paper.path(path, pieGroup);
                        slice.node.setAttribute('class', (series.classed || '') + customColor ? '' : (' rc-plot-item-' + (i+1)));
                        var params = {
                            seriesIndex: i,
                            dataIndex: i,
                            value: datum,
                            label: options.labels[i]
                        };
                        if(customColor) {
                            slice.attr({'fill': customColor, "stroke": 'none'});
                        }
                        slice.click(createClickCallback(params));
                        slice.mouseover(createOverCallback(params));
                        slice.mouseout(createOutCallback(params));
                    } else {
                        slice = pieSlices[i];
                    }
                    if(animate) {
                        !function(slice, startAngle, endAngle) {
                            Timer(function(d) {
                                d /= 500;
                                slice.attr({
                                    path: slicePath(cx, cy, startAngle * d, endAngle * d, ir, r)
                                });
                            }, 500);    
                        }(slice, startAngle, endAngle);
                    } else {
                        slice.attr({
                            path: slicePath(cx, cy, startAngle, endAngle, ir, r)
                        });
                    }
                    
                    sliceBBoxes[i] = slicePath(cx, cy, startAngle, endAngle, ir, r);
                    startAngle = endAngle;                        
                }
        };

        var drawLabel = function(create, animate, cx, cy, angle, sr, er, label, idx) {
            var path = new PathGen();
            var spoint = angleToPoint(cx, cy, sr, angle);
            var epoint = angleToPoint(cx, cy, er, angle);
            
            var x = epoint.x + (epoint.x < cx ? -labelSizes[idx].width : 0),
                y = epoint.y - labelSizes[idx].height / 2,
                w = labelSizes[idx].width,
                h = labelSizes[idx].height;
            


            var newBox = getCorrectedBoundingBox({
                x: x,
                y: y,
                width: w,
                height: h,
                cx: cx,
                cy: cy,
                angle: angle,
                r: er
            });
            var pathString = path.moveTo(spoint.x, spoint.y).lineTo(newBox.x + (newBox.x < cx ? w : 0), newBox.y + h / 2).lineTo(newBox.x + (newBox.x < cx ? -10 + w : 10), newBox.y + h/2).path();
            var line, text, circle;
            if(create) {
                line = paper.path(Raphael.path2curve(pathString), pieCore);
                line.node.setAttribute('class', 'pie-label-line');
                text = paper.text(newBox.x + (newBox.x < cx ? -20 + w : 20) , newBox.y + h/2 , options.series.format(options.series.data[idx]), pieCore);
                text.node.setAttribute('class', 'pie-label-text');
                label = paper.text(newBox.x + (newBox.x < cx ? -28 - text.getBBox().width + w : 28 + text.getBBox().width) , newBox.y + h/2 , label, pieCore);
                label.node.setAttribute('class', 'pie-label-label');
                text.attr({
                    'text-anchor':newBox.x < cx ? 'end' : 'start'
                });
                label.attr({
                    'text-anchor':newBox.x < cx ? 'end' : 'start'
                });
                labelObjects[idx] = {
                    line: line,
                    text: text,
                    label: label
                };
            } else {
                line = labelObjects[idx].line;
                text = labelObjects[idx].text;
                label = labelObjects[idx].label;

                line.animate({
                    path: pathString
                }, animate ? 500 : 0);
                text.attr({
                    'text-anchor':newBox.x < cx ? 'end' : 'start',
                    text: options.series.format(options.series.data[idx])
                });

                label.attr({
                    'text-anchor':newBox.x < cx ? 'end' : 'start'
                });
                text.animate({
                    x: newBox.x + (newBox.x < cx ? -20 + w : 20),
                    y: newBox.y + h/2
                }, animate ? 500 : 0);

                label.animate({
                    x: newBox.x + (newBox.x < cx ? -28 - text.getBBox().width + w : 28 + text.getBBox().width),
                    y: newBox.y + h/2
                }, animate ? 500 : 0);
            }
        };

        var getLabelCoords = function(cx, cy, ex, ey, w, h) {
            return {
                x: ex + (ex < cx ? -w : 0),
                y: ey - h / 2,
                w: w,
                h: h
            };
        };

        function correctPlacement(box) {
            if (box.x < width / 2) {
              box.x -= box.width;
            }
            return box;
        }

        var detectCollision = function(box1, box2) {
            var temp1 = correctPlacement(_.clone(box1)),
                temp2 = correctPlacement(_.clone(box2));

            if (temp1.x < temp2.x + temp2.width && temp1.x + temp1.width > temp2.x &&
                temp1.y < temp2.y + temp2.height && temp1.y + temp1.height > temp2.y) {
              return true;
            }

            return false;
        };

        var getCorrectedBoundingBox = function(bbox) {
            var tBox = _.cloneDeep(bbox);

            for(var i=-1; ++i<registeredLabelPos.length;) {
                var bbox2 = registeredLabelPos[i];
                var angle = bbox.angle;
                var startAngle = angle;
                // debugger
                while(detectCollision(tBox, bbox2) && angle - startAngle < 22.5) {
                    var tr = paper.rect(tBox.x, tBox.y, bbox.width, bbox.height, core);
                    // console.log(angle);
                    // debugger
                    tr.remove();
                    
                    var newEpoint = angleToPoint(bbox.cx, bbox.cy, bbox.r, ++angle);
                    newEpoint.x = newEpoint.x + (newEpoint.x < bbox.cx ? -bbox.width : 0);
                    newEpoint.y = newEpoint.y - bbox.height / 2;
                    _.extend(tBox, newEpoint);
                }
            }
            registeredLabelPos.push(tBox);
            return tBox;
        };

        var angleToPoint = function(cx, cy, r, angle) {
            var point = {};

            point.x = cx + r * Math.cos(Math.PI * angle / 180);
            point.y = cy + r * Math.sin(Math.PI * angle / 180);

            return point;
        };

        var findWidths = function (labels, values) {
            for(var i=-1; ++i<labels.length;) {
                var text = paper.text(0, 0, labels[i] + '##' + options.series.format(values[i]), core);
                text.node.style.fontSize = 12;
                labelSizes[i] = {
                    width: text.node.getBBox().width,
                    height: text.node.getBBox().height
                };
                text.remove();
            }
        };

        var findPieRadius = function(maxRadius, sizes, data) {
            findArrowRadius(maxRadius);
            var startAngle = 0,
                endAngle = 0,
                total = _.reduce(data, function(mem, item) {return mem + item; });

            var placements = [];
            for(var i=-1; ++i<sizes.length;) {
                var datum = data[i];
                endAngle = startAngle + (datum / total) * 360;
                var pt = angleToPoint(maxRadius, maxRadius, maxRadius, (startAngle + endAngle) / 2);
                var placement = {};
                placement.width = sizes[i].width;
                placement.height = sizes[i].height;
                if(pt.x < maxRadius) {
                    placement.x = pt.x - sizes[i].width;
                    placement.y = pt.y - sizes[i].height / 2;
                    placement.xtra = placement.x < 0 ? -placement.x : 0;
                } else {
                    placement.x = pt.x;
                    placement.y = pt.y;
                    placement.xtra = (placement.x + placement.width - maxRadius * 2) > 0 ? (placement.x + placement.width - maxRadius * 2) : 0;
                }
                
                placements[i] = placement;
                startAngle = endAngle;
                // The below comment is to visualize the label positions don't delete
                // paper.rect(placement.x, placement.y, placement.width, placement.height, core);
            }
            var maxWidth = _.max(_.pluck(placements, 'xtra'));
            return adjustEverything(maxRadius, maxWidth);
        };

        var findArrowRadius = function(maxRadius) {
            ARROW_RADIUS_PADDING = maxRadius * 0.1;
        };

        var adjustEverything = function(maxRadius, maxLabelWidth) {
            var actualRadius = maxRadius - maxLabelWidth - ARROW_RADIUS_PADDING;
            if(actualRadius < MIN_CHART_WIDTH) {
                noLabels = true;
                return;
            } else {
                return actualRadius;
            }
        };

        var slicePath = function(cx, cy, startAngle, endAngle, innerRadius, outerRadius){
            // full circle angle is impossible in SVG
            if (endAngle % 360 == 0)
                endAngle -= 0.01;
            var cut = Math.abs(startAngle - endAngle) > 180 ? 1 : 0;
            var startX  = cx + innerRadius * Math.cos(Math.PI * startAngle / 180),
                startY = cy + innerRadius * Math.sin(Math.PI * startAngle / 180),
                endX  = cx + innerRadius * Math.cos(Math.PI * endAngle / 180),
                endY = cy + innerRadius * Math.sin(Math.PI * endAngle / 180);

            var x1 = cx + outerRadius * Math.cos(Math.PI * startAngle/180),
                y1 = cy + outerRadius * Math.sin(Math.PI * startAngle/180),
                x2 = cx + outerRadius * Math.cos(Math.PI * endAngle/180),
                y2 = cy + outerRadius * Math.sin(Math.PI * endAngle/180);

            var pathString = "M"+ startX + " " + startY + " L" + x1 + " " + y1 + " A" + outerRadius + " " + outerRadius + " 0 " + cut + " 1 " + x2 + " " + y2 + 
                                " L"+ endX + " " + endY +" A" + innerRadius + " " + innerRadius + " 0 " + cut + " 0 " + startX + " " + startY + " z";

            return pathString;
        };
        var createClickCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemClick', params);
                eventManager.trigger('plotItemActivate', params);
            };
        };
        var createOverCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemMouseOver', params);
            };
        };
        var createOutCallback = function (params) {
            return function() {
                eventManager.trigger('plotItemMouseOut', params);
            };
        };
    };

    return Pie;
});
define('razorcharts/charts/piechart',['razorcharts/renderers/pie', 'vendor/lodash'], function(Pie, _) {
    var PieChart = function() {
        var self = this,    
            options = null,
            paper = null,
            core = null,
            width = null,
            height = null,
            chart = null,
            series = null;

        self.config = function(_options) {
            options = _options;

            chart = new Pie();
            chart.config(options);
        };

        self.renderTo = function(_paper, w, h) {
            paper = _paper;
            width = w;
            height = h;
            series = options.series;

            core = paper.group('core');
            chart.renderTo(paper, core, w, h);
        };

        self.resizeTo = function(w, h) {
            chart.resizeTo(w, h);
        };

        self.updateSeries = function(_series) {
            options.series = _series;
            chart.updateSeries();
        };

        self.callFunction = function(func) {
            return chart.callFunction(func);
        };
    };

    return PieChart;
});
define('razorcharts/renderers/gauge',['razorcharts/utils/timer', 'vendor/lodash'], function(Timer, _) {
    var Gauge = function() {
        var PADDING = 0.7,
            VALUE_LABEL_FONT_SIZE = 24,
            INNERCIRCLE_USABLE_SPACE = 0.5;
        var self = this,
            options = null,
            paper = null,
            core = null,
            width = null,
            height = null,
            background = null,
            main = null,
            innerCircle = null,
            valueLabel = null,
            valueText = null,
            value = null,
            labels = {
            };

        self.config = function(_options) {
            options = _options;
        };

        self.renderTo = function(_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;

            draw(true, false);
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            draw(false, false);
        };

        self.updateSeries = function(_series) {
            options.value = _series.value;
            draw(false, true);
        };

        var draw = function(create, animate) {
            var cx = width / 2,
                cy = height / 2,
                t,
                r = (_.min([width, height]) / 2),
                oldValue = value || null,
                formatFunc = options.format || function(item) {return item;};
            r *= PADDING;
            value = options.value;
            valueText = formatFunc(value);
            if(value < options.min) {
                console.error('Value below minimum');
            } else if(value > options.max) {
                console.error('Value above maximum');
            }
            var oldValuePercent = oldValue ? Math.abs(oldValue / (options.max - options.min)) : 0,
                valPercent = value > options.min ? value < options.max ? Math.abs((value - options.min) / (options.max - options.min)) : 1 : 0,
                innerRadius = r - r*0.05,
                innerCircleRadius = r - r*0.5,
                arrowPointRadius = r - r*0.4;
            
            backgroundPath = slicePath(cx, cy, -240, 60, innerRadius, r);
            valuePath = slicePath(cx, cy, -240, -240 + (oldValuePercent * 300), innerRadius, r);
            innerCirclePath = slicePath(cx, cy, -230, 110, innerCircleRadius, 0, true, arrowPointRadius, 10);
            if(create) {
                background = paper.path(backgroundPath, core);
                background.node.setAttribute('class', 'background');
                main = paper.path(valuePath, core);
                main.node.setAttribute('class', 'main');
                innerCircle = paper.path(innerCirclePath, core);
                innerCircle.node.setAttribute('class', 'inner-circle');
                valueLabel = paper.text(cx, cy, valueText, core);
                valueLabel.node.setAttribute('class', 'value-label');
                background.attr({
                    fill: '#888'
                });

                main.attr({
                    fill: '#080'
                });

                t = angleToPoint(cx, cy, r, -240);
                labels['min'] = paper.text(t.x, t.y, "" + formatFunc(options.min), core);
                labels['min'].attr({x: t.x, y: t.y + labels['min'].getBBox().height});
                t = angleToPoint(cx, cy, r, 60);
                labels['max'] = paper.text(t.x, t.y, "" + formatFunc(options.max), core);
                labels['max'].attr({x: t.x, y: t.y + labels['max'].getBBox().height});
                labels['min'].node.setAttribute('class', 'label');
                labels['max'].node.setAttribute('class', 'label');

            } else {
                background.attr({
                    path: backgroundPath
                });
                main.attr({
                    path: valuePath
                });
                innerCircle.attr({
                    path: innerCirclePath
                });
                valueLabel.attr({
                    text: valueText,
                    x: cx,
                    y: cy
                });
                t = angleToPoint(cx, cy, r, -240);
                labels['min'].attr({x: t.x, y: t.y + labels['min'].getBBox().height});
                t = angleToPoint(cx, cy, r, 60);
                labels['max'].attr({x: t.x, y: t.y + labels['min'].getBBox().height});
            }
            valueLabel.attr({
                'font-size': VALUE_LABEL_FONT_SIZE
            });
            var valueLabelWidth = valueLabel.getBBox().width,
                innerCircleDiameter = (innerCircleRadius * 2) * INNERCIRCLE_USABLE_SPACE;
            
            if(innerCircleDiameter < valueLabelWidth) {
                var newFontSize = (innerCircleDiameter / valueLabelWidth) * VALUE_LABEL_FONT_SIZE;
                valueLabel.attr({
                    'font-size': newFontSize
                });
                labels['min'].attr({'font-size': newFontSize * 0.8});
                labels['max'].attr({'font-size': newFontSize * 0.8});
                t = angleToPoint(cx, cy, r, -240);
                labels['min'].attr({x: t.x, y: t.y + labels['min'].getBBox().height});
                t = angleToPoint(cx, cy, r, 60);
                labels['max'].attr({x: t.x, y: t.y + labels['max'].getBBox().height});
            }
            if(animate) {
                innerCircle.animate({
                    transform: 'r' + (valPercent * 300)
                }, 500);
            } else {
                innerCircle.transform('r' + (valPercent * 300));
            }
                

            if(animate) {
                !function(main) {
                    Timer(function(d) {
                        d /= 500;
                        main.attr({
                            path: slicePath(cx, cy, -240, -240 + (oldValuePercent * 300) + ((valPercent - oldValuePercent) * 300) * d, innerRadius, r)
                        });
                    }, 500);    
                }(main);
            } else {
                main.attr({
                    path: slicePath(cx, cy, -240, -240 + (valPercent * 300), innerRadius, r)
                });
            }
        };

         var angleToPoint = function(cx, cy, r, angle) {
            var point = {};

            point.x = cx + r * Math.cos(Math.PI * angle / 180);
            point.y = cy + r * Math.sin(Math.PI * angle / 180);

            return point;
        };

        var slicePath = function(cx, cy, startAngle, endAngle, innerRadius, outerRadius, arrow, arrowRadius, distance){
            var cut = Math.abs(startAngle - endAngle) > 180 ? 1 : 0;

            var startX  = cx + innerRadius * Math.cos(Math.PI * startAngle / 180),
                startY = cy + innerRadius * Math.sin(Math.PI * startAngle / 180),
                endX  = cx + innerRadius * Math.cos(Math.PI * endAngle / 180),
                endY = cy + innerRadius * Math.sin(Math.PI * endAngle / 180);

            var x1 = cx + outerRadius * Math.cos(Math.PI * startAngle/180),
                y1 = cy + outerRadius * Math.sin(Math.PI * startAngle/180),
                x2 = cx + outerRadius * Math.cos(Math.PI * endAngle/180),
                y2 = cy + outerRadius * Math.sin(Math.PI * endAngle/180);

            var lastPath = "";

            if(arrow) {
                var arrowX = cx + arrowRadius * Math.cos(Math.PI * (endAngle + distance) / 180);
                var arrowY = cy + arrowRadius * Math.sin(Math.PI * (endAngle + distance) / 180);

                lastPath = arrow ? " L" + arrowX + "," + arrowY + " L" + endX + "," + endY : "";
            }
            
            var pathString = "M"+ startX + " " + startY + " L" + x1 + " " + y1 + " A" + outerRadius + " " + outerRadius + " 0 " + cut + " 1 " + x2 + " " + y2 + 
                                " L"+ endX + " " + endY +" A" + innerRadius + " " + innerRadius + " 0 " + cut + " 0 " + startX + " " + startY + lastPath + " z";
            if(arrow) {
                pathString = " M"+ endX + " " + endY +" A" + innerRadius + " " + innerRadius + " 0 " + cut + " 0 " + startX + " " + startY + lastPath + " z";
            }

            return pathString;
        };
    };

    return Gauge;
});
define('razorcharts/charts/gaugechart',['razorcharts/renderers/gauge', 'vendor/lodash'], function(Gauge, _) {
    var GaugeChart = function() {
        var self = this,
            options = null,
            paper = null,
            core = null,
            width = null,
            height = null,
            gauge = null;

        self.config = function(_options) {
            options = _options;
            gauge = new Gauge();
            gauge.config(options);
        };

        self.renderTo = function(_paper, w, h) {
            paper = _paper;
            width = w;
            height = h;
            core = paper.group('rc-gauge');
            core.node.setAttribute('class', 'rc-gauge');
            gauge.renderTo(paper, core, width, height);
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
            gauge.resizeTo(w, h);
        };

        self.updateSeries = function(_series) {
            gauge.updateSeries(_series);
        };
    };

    return GaugeChart;
});
define('razorcharts/renderers/tracker',['razorcharts/renderers/area', 'razorcharts/renderers/column', 'razorcharts/scales/scale', 'vendor/lodash'], function(Area, Column, Scale, _) {
    var Tracker = function() {
        var self = this,
            paper = null,
            core = null,
            width = null,
            height = null,
            xScale = null,
            yScale = null,
            thumbGroup = null,
            thumb = null,
            thumbW, thumbH, thumbX, thumbY;

        self.config = function(_options) {
            options = _options;

            xScale = new Scale.ordinal();
            xScale.domain(options.labels);

            yScale = new Scale.linear();
            yScale.domain([_.min(options.series.data), _.max(options.series.data)]);

            chart = new Area();
            chart.config({
                yScale: yScale,
                stacked: false,
                series: [options.series],
                dualAxis: false,
                animateOnRender: !!options.animateOnRender,
                eventManager: options.eventManager
            });

        };

        self.renderTo = function(_paper, _core, w, h) {
            paper = _paper;
            core = _core;
            width = w;
            height = h;

            xScale.range([0, w]);
            yScale.range([0, h]);

            chart.renderTo(paper, core, w, h);

            thumbGroup = paper.group('thumbGroup', core);

            thumbX = 0;
            thumbY = 0;
            thumbW = w;
            thumbH = h;

            thumb = paper.rect(0, 0, w, h, thumbGroup);
            var leftHandle = paper.rect(0, 0, 20, h, thumbGroup);
            var rightHandle = paper.rect(w-20, 0, 20, h, thumbGroup);
            thumb.attr({
                fill: '#46f',
                opacity: 0.5
            });

            rightHandle.attr({
                fill: '#aaa'
            });
            rightHandle.node.style.pointerEvents = 'none';
            leftHandle.attr({
                fill: '#aaa'
            });
            leftHandle.node.style.pointerEvents = 'none';

            var which = 'left',
                nw = thumbW,
                nx = thumbX;
            thumb.mousedown(function(ev, x, y) {
                if(x > (thumbX + thumbW - 20)) {
                    // console.log(x, thumbW - 20);
                    which = 'right';
                    console.log('right selected');
                } else if(x < thumbX + 20) {
                    which = 'left';
                    // console.log('left selected');
                } else {
                    which = 'middle';
                    // console.log('middle selected');
                }
                nw = thumbW;
                nx = thumbX;
            });
            
            thumb.drag(function(dx, dy) {
                // console.log(dx);
                if(which === 'left') {
                    thumbW = nw - dx;
                    thumbX = nx + dx;
                } else if(which === 'right') {
                    thumbW = nw + dx;
                } else if(which === 'middle') {
                    thumbX = nx + dx;
                }
                if(thumbW > w) {
                    thumbW = w;
                }
                if(thumbX < 0) {
                    thumbX = 0;
                }
                if(thumbX > w - thumbW) {
                    thumbX = w - thumbW;
                }
                repositionThumb();
                options.eventManager.trigger('thumbDrag', {
                    x: thumbX,
                    y: thumbY,
                    width: thumbW,
                    height: thumbH
                });
            });

            thumb.mouseup(function() {
                which = 'none';
            });

            function repositionThumb() {
                thumb.attr({
                    x: thumbX,
                    y: thumbY,
                    width: thumbW,
                    height: thumbH
                });
                leftHandle.attr({
                    x: thumbX
                });
                rightHandle.attr({
                    x: thumbX + thumbW - 20
                });
            }
        };

        self.resizeTo = function(w, h) {
            width = w;
            height = h;
        };

        var draw = function() {

        };
    };

    return Tracker;
});
define('razorcharts/charts/timeseries',['razorcharts/scales/scale', 'razorcharts/axes/axis', 'razorcharts/renderers/area', 'razorcharts/renderers/column', 'razorcharts/renderers/tracker', 'vendor/lodash'], function(Scale, Axis, Area, Column, Tracker, _) {
    var Timeseries = function() {
        var self = this,
            options = null,
            paper = null,
            core = null,
            width = null,
            height = null,
            xScale = null,
            yScale = null,
            xAxis = null,
            yAxis = null,
            xAxisGroup = null,
            yAxisGroup = null,
            xAxisHeight, yAxisWidth,
            chart = null,
            tracker = null,
            chartCore = null,
            trackerCore = null,
            currentZoom = 1;

        self.config = function(_options) {
            options = _options;
            options.eventManager.register('thumbDrag');
            var startDate = options.startDate || new Date('1 Jan 1970'),
                series = options.series,
                labels = [],
                data = series.data,
                min = _.min(data),
                max = _.max(data),
                totalLength = data.length,
                labelsLength = 10;

            for(var j=-1; ++j<labelsLength;) {
                var d = getDateFromUnit(options.startDate, options.unit, j / labelsLength * totalLength);
                labels.push(d.getDate() + '/' + (d.getMonth() + 1) + '/' + d.getFullYear());
            }

            xScale = new Scale.ordinal();
            xScale.domain(labels);

            yScale = new Scale.linear();
            yScale.domain([min < 0 ? min : 0, max]);

            xAxis = new Axis();
            xAxis.config({
                scale: xScale,
                type: 'bottom',
                axisLine: true
            });

            yAxis = new Axis();
            yAxis.config({
                scale: yScale,
                type: 'left'
            });
            series.seriesIndex = 1;
            if(series.displayType === 'area') {
                chart = new Area();
                chart.config({
                    yScale: yScale,
                    stacked: false,
                    series: [series],
                    dualAxis: false,
                    animateOnRender: !!options.animateOnRender,
                    eventManager: options.eventManager
                });
            }

            tracker = new Tracker();
            tracker.config({
                labels: labels,
                series: series,
                eventManager: options.eventManager
            });

            options.eventManager.bind('thumbDrag', onThumbDrag);
        };

        self.renderTo = function(_paper, w, h) {
            paper = _paper;
            width = w;
            height = h - 20 - (h * 0.2);

            xScale.range([0, width]);
            yScale.range([0, height]);

            core = paper.group('timeseries');

            

            xAxisGroup = paper.group('xAxisContainer', core);
            yAxisGroup = paper.group('yAxisContainer', core);

            yAxis.renderTo(paper, yAxisGroup, width, height);
            yAxisWidth = yAxisGroup.node.getBBox().width;

            xScale.range([0, width - yAxisWidth]);
            xAxis.renderTo(paper, xAxisGroup, width - yAxisWidth, height);
            xAxisHeight = xAxisGroup.node.getBBox().height;

            yScale.range([0, height - xAxisHeight]);
            yAxis.resizeTo(width, height - xAxisHeight);

            xAxisGroup.transform('t' + yAxisGroup.node.getBBox().width +',' + (height - xAxisHeight));

            chartCore = paper.group('chartCore', core);
            chartCore.attr({
                'clip-rect': yAxisWidth + ',0,' + (width - yAxisWidth) + ',' + height
            });

            chart.renderTo(paper, chartCore, (width * currentZoom) - yAxisWidth, height - xAxisHeight);

            trackerCore = paper.group('trackerCore', trackerCore);

            tracker.renderTo(paper, trackerCore, width, h * 0.2);
            
            chartCore.transform('t' + yAxisWidth + ',0');
            core.transform('t0,20');
            trackerCore.transform('t0,' + (height + xAxisHeight));
        };

        self.zoom = function(zoomFactor) {
            var zoomWidth = (width - yAxisWidth) * zoomFactor;

            xScale.range([0, zoomWidth]);
            // xAxis.resizeTo(zoomWidth - yAxisWidth, height);
            chart.resizeTo(zoomWidth, height - xAxisHeight);
        };

        self.resizeTo = function() {

        };

        var getDateFromUnit = function(date, unit, index) {
            var match = unit.match(/([0-9]+)\s([a-z]+)/),
                num = +match[1],
                type = match[2],
                numUnits = getItemInMillisecs(type) * num * index;
            
            return new Date(date.getTime() + numUnits);
        };

        var getItemInMillisecs = function(item) {
            if(item === 'day') {
                return 1000 * 60 * 60 * 24;
            }
        };

        var onThumbDrag = function(obj) {
            var zoomFactor = width / obj.width;
            var zoomWidth = (width - yAxisWidth) * zoomFactor;
            self.zoom(zoomFactor);
            chartCore.transform('t' + (-((obj.x / width) * zoomWidth) + yAxisWidth) + ',0');
        };
    };

    return Timeseries;
});
define('razorcharts/utils/eventmanager',['vendor/lodash'], function(_) {
    var EventManager = function() {
        var self = this,
            events = {};

        self.register = function (eventName) {
            events[eventName] = [];
        };

        self.bind = function(eventName, cb) {
            if(events[eventName]) {
                events[eventName].push(cb);
            } else {
                console.error('Event `' + eventName + '` does not exist');
            }
        };

        self.trigger = function(eventName, params) {
            if(events[eventName]) {
                for(var i=-1; ++i<events[eventName].length;) {
                    events[eventName][i](params);
                }
            } else {
                console.error('Event `' + eventName + '` does not exist');   
            }
        };

        self.isSubscribed = function(eventName) {
            // console.log(events[eventName]);
            return !!(events[eventName] && events[eventName].length);
        };
    };

    return EventManager;
});
define('razorcharts/core/chart',['razorcharts/charts/linearchart', 
        'razorcharts/charts/barchart', 
        'razorcharts/charts/piechart', 
        'razorcharts/charts/gaugechart',
        'razorcharts/charts/timeseries',
        'razorcharts/utils/eventmanager',
        'vendor/lodash'], function(LinearChart, BarChart, PieChart, GaugeChart, Timeseries, EventManager, _) {
    var Chart = function() {
        // Private variables
        var self = this,
            options = {},
            core = null,
            chart = null,
            eventManager = new EventManager(),
            chart_defaults = {
                animateOnRender: true,
                eventManager: eventManager
            };

        self.config = function (_options) {
            options = _options;

            if(options.type === 'linear') {
                chart = new LinearChart();
            } else if(options.type === 'bar') {
                chart = new BarChart();
            } else if(options.type === 'pie') {
                chart = new PieChart();
            } else if(options.type === 'gauge') {
                chart = new GaugeChart();
            } else if(options.type === 'timeseries') {
                chart = new Timeseries();
            }
            options = _.extend(chart_defaults, options);
            chart.config(options);
        };

        self.zoom = function(zoomFactor) {
            chart.zoom(zoomFactor);
        };

        self.renderTo = function (id, w, h) {
            core = Raphael(id, w, h);
            core.canvas.setAttribute('class', 'rc-chart');
            chart.renderTo(core, w, h);
        };

        self.resizeTo = function (w, h) {
            core.setSize(w, h);
            chart.resizeTo(w, h);
        };

        self.updateSeries = function(_series) {
            chart.updateSeries(_series);
        };

        self.on = function(eventName, cb) {
            eventManager.bind(eventName, cb);
        };

        self.callFunction = function(func) {
            return chart.callFunction(func);
        };
    };

    return Chart;
});
define('graphics/rfsparkline',[
  'vendor/lodash'
], function (_) {
  var RFSparkline = function () {
    var self = this,
        config = {},
        $sparkContainer,
        $canvas,
        width = 0,
        height = 0,
        valueNode = {},
        ctx,
        showPoints,
        max,
        min,
        strokeColor = "#2C82C9",
        lineWidth = 0;

    self.width = function(_width) {
      if(_width) {
        width = _width;
        return;
      }

      return width;
    };

    self.height = function(_height) {
      if(_height) {
        height = _height;
        return;
      }

      return height;
    };

    self.configure = function (cfg) {
      config = cfg;
      showPoints = config.points ? true : false;
      lineWidth = config.lineWidth ? config.lineWidth : 0;
      strokeColor = config.strokeColor ? config.strokeColor : strokeColor;
      width = config.width ? config.width : width;
      height = config.height ? config.height : height;
      max = _.max(config.sparkValues);
      min = _.min(config.sparkValues);
      strokeColor = config.strokeColor;
    };

    self.renderTo = function (sparkContainer) {
      $sparkContainer = sparkContainer;
      startRender();
      $sparkContainer.html($canvas);
    };

    self.render = function() {
      $canvas = config.canvas[0];
      ctx = $canvas.getContext('2d');
      startRender();
    };

    var createCanvas = function() {
      $canvas = $("<canvas/>", {widtH: width, heighT: height, id: config.id});
      ctx = $canvas[0].getContext('2d');
    };

    var startRender = function() {
      createCanvas();
      var data = config.sparkValues,
          xWidth = width / data.length,
          x = xWidth / 2,
          y;


      ctx.beginPath();
      ctx.strokeStyle = strokeColor;
      ctx.fillStyle = strokeColor;
      ctx.lineWidth = lineWidth;

      for(var i=0; i<data.length; i++) {
        y = calculateY(data, i);
        ctx.lineTo(x, y);
        
        if(showPoints) {
          ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
        }

        ctx.moveTo(x, y);

        x = x + xWidth;
      }

      ctx.stroke();

      if(showPoints) {
        ctx.fill();
      }
    };

    var calculateY = function(data, index) {
      var ratio = ( max - data[index] ) / ( max - min );

      // TODO: Hack implemented to fit the canvas points widthoout touching the container edges.
      if(ratio < 0.5) {
        return ratio * height + 5;
      }

      return ratio * height - 5;
    };
  };

  return RFSparkline;
});

define('graphics/rfkpi',[
  "utils/internallayoutmanager",
  "constants/kpilayoutconstants",
  "utils/numberformatter",
  "razorcharts/core/chart",
  "utils/iconutils",
  "graphics/rfsparkline",
  'vendor/lodash'
], function (InternalLayoutManager, KPILayouts, NumberFormatter, RazorChart, iconUtils, RFSparkline, _) {
  var RFKPI = function () {
    var self = this,
        config = {},
        layoutManager = null,
        profiles = KPILayouts,
        $core,
        $sparkContainer,
        $gaugeContainer,
        spark,
        gauge,
        gaugeRendered = false;

    self.configure = function (cfg) {
      config = cfg;
    };

    self.renderTo = function (jqDiv) {
      var layoutObject = getLayoutObject(),
          layoutValues = {
            'rfKPIValue': config.valueString,
            'rfKPICaption': config.captionString
          }, sparkContainer,
          icon = config.icon,
          iconProps = config.iconProps;
      layoutManager = new InternalLayoutManager(layoutObject, layoutValues);
      layoutManager.manageElement(jqDiv);
      layoutManager.setValues();
      $core = jqDiv;
      if(icon) {
        $core.find('.rfKPIValue').prepend(iconUtils.getHTMLForIcon(icon, iconProps));  
      }
      $sparkContainer = jqDiv.find('.rfKPISpark');
      if (config.sparkFlag) {
        spark = new RFSparkline();
        spark.configure({
          sparkValues: config.sparkValues,
          width: $sparkContainer.outerWidth(),
          height: $sparkContainer.outerHeight(),
          strokeColor: '#2C82C9',
          points: true,
          lineWidth: 3
        });
        // spark.renderTo($sparkContainer);
      }
      if (config.gaugeFlag) {
        $gaugeContainer = jqDiv.find('.rfKPIGauge');
      }
      if (config.valueTextColor !== "auto") {
        $core.find('.rfKPIValue').css({
          "color" : config.valueTextColor
        });
      }
    };

    self.resizeTo = function(width, height){
      layoutManager.handleResize(width, height);
        if(spark){
          spark.width($sparkContainer.outerWidth());
          spark.height($sparkContainer.outerHeight());
          spark.renderTo($sparkContainer);
        }
        if(config.gaugeFlag){
          if(!gaugeRendered) {
            gauge = new RazorChart();
            gauge.config({
              type: 'gauge',
              min: config.limits.min,
              max: config.limits.max,
              value: config.value,
              format: function(item) {
                return applyNumberFormatting(config.numberFormatProps, item);
              }
            });
            gauge.renderTo($gaugeContainer[0], $gaugeContainer.width(), $gaugeContainer.height());
            gaugeRendered = true;
          } else {
            gauge.resizeTo($gaugeContainer.width(), $gaugeContainer.height());
          }
        }
    };

    self.updateValue = function(newValue, oldValue) {
      if(config.gaugeFlag) {
        // gauge.config({
        //   type: 'gauge',
        //   min: config.limits.min,
        //   max: config.limits.max,
        //   value: newValue.value,
        //   format: function(item) {
        //     return applyNumberFormatting(newValue, item);
        //   }
        // });
        gauge.updateSeries({value: newValue.value});
      } else {
        var $value = $core.find('.rfKPIValue');
        timer(function(d) {
          $value.css('opacity', 1 - (d / 250));
        }, function() {
          $value.text(applyNumberFormatting(newValue, newValue.value));
          timer(function(d) {
            $value.css('opacity', (d / 250));
          }, 250);
        }, 250);
      }
        
    };

    var timer = function(cb, fcb, time) {
      var startTime = Date.now(),
          endTime = startTime + time,
          d = 0;
      
      var animationFunc = function() {
        cb(d);
        d = Date.now() - startTime;
        if(d > time) { cb(time); fcb(); return; }
        requestAnimationFrame(animationFunc);
      };

      animationFunc();
    };

    var lerp = function(s, e, t) {
      return s+(e-s)*t;
    };

    var applyNumberFormatting  = function(obj, val) {
      var numberFormatter = new NumberFormatter();
      numberFormatter.setConfig(obj);
      return numberFormatter.formatValue(val);
    };

    var checkRequirements = function (items) {
      var checkFlag = true, i;
      if (items.has) {
        _.each(items.has, function (key) {
          if (!config.hasOwnProperty(key)) {
            checkFlag = false;
          }
        });
      }
      if (items.not) {
        _.each(items.not, function (key) {
          if (config.hasOwnProperty(key)) {
            checkFlag = false;
          }
        });
      }

      return checkFlag;
    };

    var getLayoutObject = function () {
      var profileName = '';
      if (checkRequirements({has: ['captionString', 'valueString'], not: ['gaugeFlag', 'sparkFlag']})) {
        profileName = 'basicKPI';
      }
      if (checkRequirements({has: ['captionString', 'valueString', 'gaugeFlag']})) {
        profileName = 'basicGauge';
      }
      if (checkRequirements({has: ['captionString', 'valueString', 'sparkFlag']})) {
        profileName = 'kpiWithSpark';
      }
      if (checkRequirements({has: ['captionString', 'valueString', 'c1', 'c2']})) {
        profileName = 'kpiWithChanges';
      }
      return profiles[profileName][config.mode];
    };
  };

  return RFKPI;
});

define('graphics/minikpi',['utils/iconutils', 'generated/templates'], function(iconUtils, JST) {
    var MiniKPI = function() {
        var self = this,
            options = null,
            $core = null,
            $container = null,
            $caption = null,
            $value = null,
            $borderContainer;


        self.config = function(_options) {
            options = _options;
        };

        self.updateValue = function(value) {
            $value.text(value);
            if(options.icon) {
                $value.prepend(iconUtils.getHTMLForIcon(options.icon, options.iconProps));  
            }
        };

        self.render = function(_core) {
            $core = _core;
            $core.append(JST.minikpi({
                caption: options.caption,
                value: options.value
            }));
            $container = $core.find('.rfMiniKPICore');
            $caption = $core.find('.rfMiniKPICaption');
            $value = $core.find('.rfMiniKPIValue');
            $borderContainer = $core.find('.rfMiniKPIBorderContainer');

            if(options.icon) {
                $value.prepend(iconUtils.getHTMLForIcon(options.icon, options.iconProps));  
            }
        };

        self.resize = function(w, h) {
            var xPadding = w * 0.1,
                yPadding = h * 0.1,
                unitWidth = (w + h) / 2,
                fontSize = ((unitWidth/2 - xPadding) / 1.5);

            $borderContainer.css({
                top: yPadding,
                height: h - yPadding * 2
            });

            $container.css({
                width: w,
                height: h
            });
            $caption.css({
                fontSize: fontSize * (options.captionFontScale || 0.7)
            });
            $caption.css({
                width: w * 0.8,
                maxHeight: (h - yPadding * 2) / 2,
                left: w * 0.1,
                top: h/2 - $caption.height() - yPadding/2,
                position: 'absolute',
                color: options.captionColor
            });
            $value.css({
                fontSize: fontSize * (options.valueFontScale || 1)
            });
            $value.css({
                width: w * 0.8,
                maxHeight: (h - yPadding * 2) / 2,
                left: w * 0.1,
                top: (h/2) + yPadding/2,
                position: 'absolute',
                color: options.valueColor
            });
        };
    };

    return MiniKPI;
});
/**
 * Copyright (c) 2011-2013 Felix Gnass
 * Licensed under the MIT license
 */
(function(root, factory) {

  /* CommonJS */
  if (typeof exports == 'object')  module.exports = factory()

  /* AMD module */
  else if (typeof define == 'function' && define.amd) define('vendor/spin',factory)

  /* Browser global */
  else root.Spinner = factory()
}
(this, function() {
  "use strict";

  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
    , animations = {} /* Animation rules keyed by their name */
    , useCssAnimations /* Whether to use CSS animations or setTimeout */

  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div')
      , n

    for(n in prop) el[n] = prop[n]
    return el
  }

  /**
   * Appends children and returns the parent.
   */
  function ins(parent /* child1, child2, ...*/) {
    for (var i=1, n=arguments.length; i<n; i++)
      parent.appendChild(arguments[i])

    return parent
  }

  /**
   * Insert a new stylesheet to hold the @keyframe or VML rules.
   */
  var sheet = (function() {
    var el = createEl('style', {type : 'text/css'})
    ins(document.getElementsByTagName('head')[0], el)
    return el.sheet || el.styleSheet
  }())

  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation(alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')
      , start = 0.01 + i/lines * 100
      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
      , pre = prefix && '-' + prefix + '-' || ''

    if (!animations[name]) {
      sheet.insertRule(
        '@' + pre + 'keyframes ' + name + '{' +
        '0%{opacity:' + z + '}' +
        start + '%{opacity:' + alpha + '}' +
        (start+0.01) + '%{opacity:1}' +
        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
        '100%{opacity:' + z + '}' +
        '}', sheet.cssRules.length)

      animations[name] = 1
    }

    return name
  }

  /**
   * Tries various vendor prefixes and returns the first supported property.
   */
  function vendor(el, prop) {
    var s = el.style
      , pp
      , i

    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
    for(i=0; i<prefixes.length; i++) {
      pp = prefixes[i]+prop
      if(s[pp] !== undefined) return pp
    }
    if(s[prop] !== undefined) return prop
  }

  /**
   * Sets multiple style properties at once.
   */
  function css(el, prop) {
    for (var n in prop)
      el.style[vendor(el, n)||n] = prop[n]

    return el
  }

  /**
   * Fills in default values.
   */
  function merge(obj) {
    for (var i=1; i < arguments.length; i++) {
      var def = arguments[i]
      for (var n in def)
        if (obj[n] === undefined) obj[n] = def[n]
    }
    return obj
  }

  /**
   * Returns the absolute page-offset of the given element.
   */
  function pos(el) {
    var o = { x:el.offsetLeft, y:el.offsetTop }
    while((el = el.offsetParent))
      o.x+=el.offsetLeft, o.y+=el.offsetTop

    return o
  }

  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
    return typeof color == 'string' ? color : color[idx % color.length]
  }

  // Built-in defaults

  var defaults = {
    lines: 12,            // The number of lines to draw
    length: 7,            // The length of each line
    width: 5,             // The line thickness
    radius: 10,           // The radius of the inner circle
    rotate: 0,            // Rotation offset
    corners: 1,           // Roundness (0..1)
    color: '#000',        // #rgb or #rrggbb
    direction: 1,         // 1: clockwise, -1: counterclockwise
    speed: 1,             // Rounds per second
    trail: 100,           // Afterglow percentage
    opacity: 1/4,         // Opacity of the lines
    fps: 20,              // Frames per second when using setTimeout()
    zIndex: 2e9,          // Use a high z-index by default
    className: 'spinner', // CSS class to assign to the element
    top: 'auto',          // center vertically
    left: 'auto',         // center horizontally
    position: 'relative'  // element position
  }

  /** The constructor */
  function Spinner(o) {
    if (typeof this == 'undefined') return new Spinner(o)
    this.opts = merge(o || {}, Spinner.defaults, defaults)
  }

  // Global defaults that override the built-ins:
  Spinner.defaults = {}

  merge(Spinner.prototype, {

    /**
     * Adds the spinner to the given target element. If this instance is already
     * spinning, it is automatically removed from its previous target b calling
     * stop() internally.
     */
    spin: function(target) {
      this.stop()

      var self = this
        , o = self.opts
        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})
        , mid = o.radius+o.length+o.width
        , ep // element position
        , tp // target position

      if (target) {
        target.insertBefore(el, target.firstChild||null)
        tp = pos(target)
        ep = pos(el)
        css(el, {
          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',
          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'
        })
      }

      el.setAttribute('role', 'progressbar')
      self.lines(el, self.opts)

      if (!useCssAnimations) {
        // No CSS animation support, use setTimeout() instead
        var i = 0
          , start = (o.lines - 1) * (1 - o.direction) / 2
          , alpha
          , fps = o.fps
          , f = fps/o.speed
          , ostep = (1-o.opacity) / (f*o.trail / 100)
          , astep = f/o.lines

        ;(function anim() {
          i++;
          for (var j = 0; j < o.lines; j++) {
            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)

            self.opacity(el, j * o.direction + start, alpha, o)
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))
        })()
      }
      return self
    },

    /**
     * Stops and removes the Spinner.
     */
    stop: function() {
      var el = this.el
      if (el) {
        clearTimeout(this.timeout)
        if (el.parentNode) el.parentNode.removeChild(el)
        this.el = undefined
      }
      return this
    },

    /**
     * Internal method that draws the individual lines. Will be overwritten
     * in VML fallback mode below.
     */
    lines: function(el, o) {
      var i = 0
        , start = (o.lines - 1) * (1 - o.direction) / 2
        , seg

      function fill(color, shadow) {
        return css(createEl(), {
          position: 'absolute',
          width: (o.length+o.width) + 'px',
          height: o.width + 'px',
          background: color,
          boxShadow: shadow,
          transformOrigin: 'left',
          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',
          borderRadius: (o.corners * o.width>>1) + 'px'
        })
      }

      for (; i < o.lines; i++) {
        seg = css(createEl(), {
          position: 'absolute',
          top: 1+~(o.width/2) + 'px',
          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
          opacity: o.opacity,
          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'
        })

        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))
        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))
      }
      return el
    },

    /**
     * Internal method that adjusts the opacity of a single line.
     * Will be overwritten in VML fallback mode below.
     */
    opacity: function(el, i, val) {
      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
    }

  })


  function initVML() {

    /* Utility function to create a VML tag */
    function vml(tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
    }

    // No CSS transforms but VML support, add a CSS rule for VML elements:
    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')

    Spinner.prototype.lines = function(el, o) {
      var r = o.length+o.width
        , s = 2*r

      function grp() {
        return css(
          vml('group', {
            coordsize: s + ' ' + s,
            coordorigin: -r + ' ' + -r
          }),
          { width: s, height: s }
        )
      }

      var margin = -(o.width+o.length)*2 + 'px'
        , g = css(grp(), {position: 'absolute', top: margin, left: margin})
        , i

      function seg(i, dx, filter) {
        ins(g,
          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),
            ins(css(vml('roundrect', {arcsize: o.corners}), {
                width: r,
                height: o.width,
                left: o.radius,
                top: -o.width>>1,
                filter: filter
              }),
              vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),
              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
            )
          )
        )
      }

      if (o.shadow)
        for (i = 1; i <= o.lines; i++)
          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')

      for (i = 1; i <= o.lines; i++) seg(i)
      return ins(el, g)
    }

    Spinner.prototype.opacity = function(el, i, val, o) {
      var c = el.firstChild
      o = o.shadow && o.lines || 0
      if (c && i+o < c.childNodes.length) {
        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild
        if (c) c.opacity = val
      }
    }
  }

  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})

  if (!vendor(probe, 'transform') && probe.adj) initVML()
  else useCssAnimations = vendor(probe, 'animation')

  return Spinner

}));

define('renderers/componentrenderer',[
  "core/rfclass",
  "generated/templates",
  "constants/componentconstants",
  "utils/media",
  "utils/iconutils",
  "graphics/rfkpi",
  "utils/positionutils",
  "graphics/minikpi",
  "kendo/kendo.notification",
  "utils/numberformatter",
  'vendor/lodash',
  'vendor/Modernizr',
  'vendor/spin'
], function (RFClass, JST, ComponentConstants, MediaUtils, iconUtils, RFKPI, positionUtils, MiniKPI, kNotification, NumberFormatter, _, Modernizr, Spinner) {
  var xPadding = ComponentConstants.component.xPadding;
  var yPadding = ComponentConstants.component.yPadding;
  function ComponentRenderer() {
    RFClass.call(this);

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {},
        profiles = ComponentConstants;

    var props = {}, boundItems = [], createdItems = [];
    
    Public = {
      /**
       * This is a SNAPSHOT of the propertybase that is being rendered.
       */
      props: null,
      $container: null,
      $core: null,
      $caption: null,
      $wrapper: null,
      $lockDisplay: null,
      $footer: null,
      $header: null,
      $errorMessage: null,
      $errorMessageText: null,
      $loadingTextDiv: null,
      $spinnerDiv: null,
      locked: false,
      error: false,
      db: null,
      handleMaximize: false,
      maximizeFlag: false,
      showCaption: true,
      integratedFlag: false,
      kpiContainers: [],
      kpiobjs: [],
      overriddenDimensions: null,
      numKPIs: null,
      init: function (config) {
        overriddenDimensions = config.overriddenDimensions;
        self.props = config.props;
        self.$container = config.container;
        self.locked = config.locked;
        self.error = config.error;
        self.handleMaximize = config.handleMaximize;
        self.maximizeFlag = config.maximizeFlag;
        self.showCaption = config.showCaption;
        self.integratedFlag = config.integratedFlag;
      },
      renderContainer: function () {
        var formComponent = raw.className === 'FormRenderer' ? true : false,
            mobile = false;
        if(raw.className === 'KPIRenderer') {
          self.$container.html(JST.component_chromeless({
            captionText: self.props.core.caption
          }));  
          self.$caption = self.$container.find(".rfChromelessTop");
        } else {
          if (rf.globals.media === "xs" && Modernizr.touch) {
            mobile = true;
          } 
          self.$container.html(JST.component_wrapper({
            captionText: self.props.core.caption,
            showCaption: self.showCaption,
            error: self.error,
            lock: self.locked,
            formComponent: formComponent,
            mobile: mobile
          }));
          self.$caption = self.$container.find(".rfCaption");
          var icon = self.props.core.icon,
              iconProps = JSON.parse(self.props.core.iconprops);
          if(icon) {
            self.$caption.find('.rfCaptionIconContainer').append(iconUtils.getHTMLForIcon(icon, iconProps));
          }
          if (self.showCaption) {
            // iconUtils.draw(self.$container, 12, 12);
          }
        }

        self.$wrapper = self.$container.find(".rfWrapper");
        self.$footer = self.$container.find(".rfFooter");
        self.$header = self.$container.find(".rfHeader");
        if (self.maximizeFlag) {
          self.$core = self.$container;
        } else {
          self.$core = self.$container.find(".rfCore");
        }
        self.$lockDisplay = self.$container.find(".rfLock");
        self.$caption.find ('.rfMaximizeIcon').click (self.handleMaximize);

        // Find the error display
        self.$errorMessage = self.$container.find(".rfError");

        if (self.locked) {
          self.showLoadingScreen();
        }
        else {
          self.hideLoadingScreen();
        }

        if (self.props.kpis && (self.props.kpis).length !== 0) {
          self.showComponentKPI();
        }

        if(self.props.core.isHidden) {
          // self.$container.hide();
        }
        if(self.integratedFlag) {
          self.$container.find(".rfWrapper").addClass("rfIntegrated");
        }

        return self.$core;
      },
      resizeContainer: function () {
        if(_.keys(self.props.kpis).length && raw.className !== 'KPIRenderer' && raw.className !== 'KPIGroupRenderer' && raw.className !== 'KPITableRenderer') {
          var media = rf.globals.dbRegistry.getCurrentDashboard().pro.media.getCurrentMedia();
          var componentWidth = (media !== 'xs' ? self.props.core.location.w : overriddenDimensions['xs'].w),
              componentHeight = (media !== 'xs' ? self.props.core.location.h : overriddenDimensions['xs'].h),
              numPossibleKPIs = componentWidth / 2;
          var kpiContainers = self.kpiContainers,
              kpiobjs = self.kpiobjs,
              kpis = self.props.kpis,
              w = self.$container.width(),
              h = positionUtils.unitsToPixels(media === 'xs' ? 2 : 1, (self.$container.height() / componentHeight) * 12),
              numKPIs = self.numKPIs;

          var kpiW = Math.floor(w / (media === 'xs' ? 2 : numPossibleKPIs)) - 8,
              kpiH = h;
          for(var key in kpis) {
            if(kpis.hasOwnProperty(key)) {
              kpiobjs[key].resize(kpiW, kpiH);
              kpiContainers[key].css({
                  width: kpiW,
                  height: kpiH
              });
            }
          }
        }
        self.adjustHeights();
      },

      showComponentKPI: function () {
        if(raw.className === 'KPIRenderer' || raw.className === 'KPIGroupRenderer' || raw.className === 'KPITableRenderer') {
          return;
        }
        var componentWidth = self.props.core.location.w,
            numPossibleKPIs = componentWidth / 2,
            kpis = self.props.kpis,
            numKPIsNeeded = _.keys(kpis).length,
            numKPIs = numPossibleKPIs > numKPIsNeeded ? numKPIsNeeded : numPossibleKPIs,
            kpiContainers = self.kpiContainers,
            kpiobjs = self.kpiobjs;
          self.numKPIs = numKPIs;
          self.$footer.append(JST.kpigroup({
              numKPIs: numKPIs,
              keys: _.keys(kpis)
          }));

          for(var key in kpis) {
            if(kpis.hasOwnProperty(key)) {
              var kpi = kpis[key],
                  numberFormatter = new NumberFormatter();
              kpi.dataType = 'number';
              numberFormatter.setConfig(kpi);
              kpiContainers[key] = self.$footer.find('.rfMiniKPIContainer#' + key);
              kpiobjs[key] = new MiniKPI();
              kpiobjs[key].config({
                  caption: kpi.caption,
                  value: numberFormatter.formatValue(kpi.value),
                  captionColor: kpi.captioncolor,
                  valueColor: kpi.valuecolor,
                  icon: kpi.icon,
                  iconProps: JSON.parse(kpi.iconprops),
                  captionFontScale: 0.4,
                  valueFontScale: 0.72
              });
              kpiobjs[key].render(kpiContainers[key]);
            }
          }
      },

      adjustHeights: function () {
        var visibleDiv = self.$core,  
            wrapperHeight = self.$container.height() - yPadding,
            wrapperWidth = self.$container.width() - xPadding;

        if (self.locked) {
          visibleDiv = self.$lockDisplay;
        }
        else if (self.error) {
          visibleDiv = self.$errorMessage;
        }
        self.$wrapper.width(self.$container.width() - xPadding);
        self.$wrapper.height(wrapperHeight);
        self.$wrapper.css({
          'margin-left': xPadding / 2,
          'margin-top': yPadding / 2
        });
        if (Modernizr.touch) {
          self.$wrapper.css({
            'margin-left': "9px"
          });
        }
        if(!visibleDiv.parent().hasClass('rfWrapper')) {
          wrapperHeight += yPadding;
        }
        if (self.error && !self.locked) {
          wrapperHeight -= yPadding;
          visibleDiv.width(wrapperWidth - xPadding);
        }
        visibleDiv.height(wrapperHeight - self.$caption.height() -self.$footer.height() - self.$header.height());
      },
      dispose: function () {
        var i;
        self.pro.unbindAll();
        for (i = 0; i < boundItems.length; i++) {
          boundItems[i].unbind();
        }
        boundItems = [];

        for (i = 0; i < createdItems.length; i++) {
          createdItems[i].remove();
        }
        createdItems = [];
        self.$container = null;
        self.$core = null;
        self.$caption = null;
        self.$wrapper = null;
        self.$lockDisplay = null;
        self.$footer = null;
        self.$header = null;
        self.$errorMessageText = null;
        self.$errorMessage = null;
        self.$loadingTextDiv = null;
        self.$spinnerDiv = null;
      },
      managedBind: function (jqDiv, eventName, callback) {
        jqDiv.bind(eventName, callback);
        boundItems.push(jqDiv);
      },
      /**
       * Instead of:
       * $("<div/>", {id: 'foo'});
       * use self.managedCreate("<div/>", {id: 'foo'})
       *
       * @param baseHTML
       * @param params
       */
      managedCreate: function (baseHTML, params) {
        var item = $(baseHTML, params);
        createdItems.push(item);
        return item;
      },
      showLoadingScreen: function () {
        self.locked = true;
        self.$core.hide();
        self.$footer.hide();
        self.$lockDisplay.show();
        if(self.$caption) {
          self.$caption.hide();
        }
        self.adjustSpinnerWidth();
        self.adjustHeights();
      },

      adjustSpinnerWidth: function () {
        var opts = profiles.spinner.options,
            loadingText = "Loading",
            spinner = new Spinner(opts).spin(),
            media = self.db.pro.media.getCurrentMedia();

        self.$loadingTextDiv = self.$lockDisplay.find('.rfLoadingText');
        self.$spinnerDiv = self.$lockDisplay.find('.rfSpinner');
        self.$loadingTextDiv.text(loadingText);
        self.$spinnerDiv.append(spinner.el);
        self.$lockDisplay.addClass('loading');
      },

      hideLoadingScreen: function () {
        self.locked = false;
        self.$lockDisplay.hide();
        self.$lockDisplay.removeClass('loading');
        if(self.$caption) {
          self.$caption.show();
        }
        self.$core.show();
        self.$footer.show();
      },

      showErrorMessage: function (message) {
        self.$core.hide();
        self.$errorMessage.show();
        self.$errorMessageText = self.$errorMessage.find('.rfErrorMessageText');
        self.$errorMessageText.html(JST.error_list({
          "message" : message,
          media: self.db.pro.media.getCurrentMedia()
        }));
      },

      hideErrorMessage: function () {
        self.$errorMessage.hide();
        self.$core.show();
      },

      getDimensionProperties: function () {
        var location = self.props.core.location;

        var potraitMode = (location.w > location.h) ? false : true;
        return {
          w: location.w,
          h: location.h,
          portrait: potraitMode
        };
      },
      linkToDashboard: function(db) {
        self.db = db;
      },
      showErrorNotification: function(errors) {
        var $notification = $("body").find(".rfNotification");
        var errorTemplate = JST.notification_errors({
          errors: errors
        });

        $notification.append(errorTemplate);
        $notification.kendoNotification({
          allowHideAfter: 2000,
           position: {
            stacking: 'down',
            top: 30,
            right: 30
           },
          handleClick: function() {
            self.db.pro.logger.show();
          }
        }).data('kendoNotification');

        $notification.data('kendoNotification').show(errorTemplate, "error");
      }
    };

    Protected = {

    };

    raw._registerClassName("ComponentRenderer");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);
  }

  return ComponentRenderer;
});

/* jsep v0.2.9 (http://jsep.from.so/) */
!function(a){"use strict";var b="Compound",c="Identifier",d="MemberExpression",e="Literal",f="ThisExpression",g="CallExpression",h="UnaryExpression",i="BinaryExpression",j="LogicalExpression",k="ConditionalExpression",l="Array",m=46,n=44,o=39,p=34,q=40,r=41,s=91,t=93,u=63,v=59,w=58,x=function(a,b){var c=new Error(a+" at character "+b);throw c.index=b,c.dedscription=a,c},y=!0,z={"-":y,"!":y,"~":y,"+":y},A={"||":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":10,"/":10,"%":10},B=function(a){var b,c=0;for(var d in a)(b=d.length)>c&&a.hasOwnProperty(d)&&(c=b);return c},C=B(z),D=B(A),E={"true":!0,"false":!1,"null":null},F="this",G=function(a){return A[a]||0},H=function(a,b,c){var d="||"===a||"&&"===a?j:i;return{type:d,operator:a,left:b,right:c}},I=function(a){return a>=48&&57>=a},J=function(a){return 36===a||95===a||a>=65&&90>=a||a>=97&&122>=a},K=function(a){return 36===a||95===a||a>=65&&90>=a||a>=97&&122>=a||a>=48&&57>=a},L=function(a){for(var i,j,y=0,B=a.charAt,L=a.charCodeAt,M=function(b){return B.call(a,b)},N=function(b){return L.call(a,b)},O=a.length,P=function(){for(var a=N(y);32===a||9===a;)a=N(++y)},Q=function(){var a,b,c=S();return P(),N(y)!==u?c:(y++,a=Q(),a||x("Expected expression",y),P(),N(y)===w?(y++,b=Q(),b||x("Expected expression",y),{type:k,test:c,consequent:a,alternate:b}):(x("Expected :",y),void 0))},R=function(){P();for(var b=a.substr(y,D),c=b.length;c>0;){if(A.hasOwnProperty(b))return y+=c,b;b=b.substr(0,--c)}return!1},S=function(){var a,b,c,d,e,f,g,h;if(f=T(),b=R(),!b)return f;for(e={value:b,prec:G(b)},g=T(),g||x("Expected expression after "+b,y),d=[f,e,g];(b=R())&&(c=G(b),0!==c);){for(e={value:b,prec:c};d.length>2&&c<=d[d.length-2].prec;)g=d.pop(),b=d.pop().value,f=d.pop(),a=H(b,f,g),d.push(a);a=T(),a||x("Expected expression after "+b,y),d.push(e,a)}for(h=d.length-1,a=d[h];h>1;)a=H(d[h-1].value,d[h-2],a),h-=2;return a},T=function(){var b,c,d;if(P(),b=N(y),I(b)||b===m)return U();if(b===o||b===p)return V();if(J(b)||b===q)return Y();for(c=a.substr(y,C),d=c.length;d>0;){if(z.hasOwnProperty(c))return y+=d,{type:h,operator:c,argument:T(),prefix:!0};c=c.substr(0,--d)}return!1},U=function(){for(var a,b="";I(N(y));)b+=M(y++);if(N(y)===m)for(b+=M(y++);I(N(y));)b+=M(y++);if(a=M(y),"e"===a||"E"===a){for(b+=M(y++),a=M(y),("+"===a||"-"===a)&&(b+=M(y++));I(N(y));)b+=M(y++);I(N(y-1))||x("Expected exponent ("+b+M(y)+")",y)}return J(N(y))&&x("Variable names cannot start with a number ("+b+M(y)+")",y),{type:e,value:parseFloat(b),raw:b}},V=function(){for(var a,b="",c=M(y++),d=!1;O>y;){if(a=M(y++),a===c){d=!0;break}if("\\"===a)switch(a=M(y++)){case"n":b+="\n";break;case"r":b+="\r";break;case"t":b+="	";break;case"b":b+="\b";break;case"f":b+="\f";break;case"v":b+=""}else b+=a}return d||x('Unclosed quote after "'+b+'"',y),{type:e,value:b,raw:c+b+c}},W=function(){var b,d=N(y),g=y;for(J(d)?y++:x("Unexpected "+M(y),y);O>y&&(d=N(y),K(d));)y++;return b=a.slice(g,y),E.hasOwnProperty(b)?{type:e,value:E[b],raw:b}:b===F?{type:f}:{type:c,name:b}},X=function(a){for(var c,d,e=[];O>y;){if(P(),c=N(y),c===a){y++;break}c===n?y++:(d=Q(),d&&d.type!==b||x("Expected comma",y),e.push(d))}return e},Y=function(){var a,b;for(a=N(y),b=a===q?Z():W(),P(),a=N(y);a===m||a===s||a===q;)y++,a===m?(P(),b={type:d,computed:!1,object:b,property:W()}):a===s?(b={type:d,computed:!0,object:b,property:Q()},P(),a=N(y),a!==t&&x("Unclosed [",y),y++):a===q&&(b={type:g,arguments:X(r),callee:b}),P(),a=N(y);return b},Z=function(){y++;var a=Q();return P(),N(y)===r?(y++,a):(x("Unclosed (",y),void 0)},$=function(){return y++,{type:l,body:X(t)}},_=[];O>y;)i=N(y),i===v||i===n?y++:i===s&&(j=$())?_.push(j):(j=Q())?_.push(j):O>y&&x('Unexpected "'+M(y)+'"',y);return 1===_.length?_[0]:{type:b,body:_}};if(L.version="0.2.9",L.toString=function(){return"JavaScript Expression Parser (JSEP) v"+L.version},L.addUnaryOp=function(a){return z[a]=y,this},L.addBinaryOp=function(a,b){return D=Math.max(a.length,D),A[a]=b,this},L.removeUnaryOp=function(a){return delete z[a],a.length===C&&(C=B(z)),this},L.removeBinaryOp=function(a){return delete A[a],a.length===D&&(D=B(A)),this},"undefined"==typeof exports){var M=a.jsep;a.jsep=L,L.noConflict=function(){return a.jsep===L&&(a.jsep=M),L}}else"undefined"!=typeof module&&module.exports?exports=module.exports=L:exports.parse=L}(this);
define("jsep", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.jsep;
    };
}(this)));

define('utils/evalexpression',[
	"jsep",
	"vendor/lodash"
], function (jsep, _) {
	var cellValue = null,
			evalExpression = function (expression, value) {
				cellValue = value;
				return getResult(jsep(expression));
			},

			getResult = function(tree) {
				switch (tree.type) {
					case "LogicalExpression" : 
										switch(tree.operator) {
											case "&&" : return getResult(tree.left) && getResult(tree.right);
											case "||" : return getResult(tree.left) || getResult(tree.right);
										}
					case "BinaryExpression" :
										var left = getResult(tree.left),
											right = getResult(tree.right);
										if(_.isBoolean(left)) {
											if(!left) {
												return false;
											} else {
												left = cellValue;
											}
										}
										switch(tree.operator) {
											case "<" : return left < right;
											case ">" : return left > right;
											case "<=" : return left <= right;
											case ">=" : return left >= right;
											case "==" : return left == right;
											case "===" : return left === right;
											case "+" : return left + right;
											case "-" : return left - right;
											case "*" : return left * right;
											case "/" : return left / right;
											case "%" : return left % right;
										}
					case "Literal" :
										return tree.value;
					case "Identifier" :
										return cellValue;
				}
				return false;
			};

	return evalExpression;
});
define('renderers/kpirenderer',[
  "renderers/componentrenderer",
  "graphics/rfkpi",
  "utils/numberformatter",
  "utils/evalexpression"
], function (ComponentRenderer, RFKPI, NumberFormatter, evalExpression) {
  function KPIRenderer() {
    ComponentRenderer.call(this);

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    var kpi,
        mode,
        spark,
        sparkContainer,
        sparkLabels,
        sparkValues,
        limits,
        gaugeFlag,
        valueTextColor,
        conditionalParam = [];

    Public = {
      dispose: function () {
        base.dispose();
      },
      setConfig: function (cfg) {
        sparkLabels = cfg.labels;
        sparkValues = cfg.values;
        limits = cfg.limits;
        gaugeFlag = !!cfg.gaugeFlag;
      },
      renderCore: function () {
        var dimension = self.getDimensionProperties(),
            config;
        if (dimension.portrait) {
          mode = 'portrait';
        } else {
          mode = 'landscape';
        }
        if (self.db === null) {
          mode = 'landscape';
        } else {
          if(self.db.pro.media.mediaSelect({"sm+xs":true}, false)) {
            mode = 'mobile';
          }
        }

        valueTextColor = self.props.kpi.display.valueTextColor;

        conditionalParam = self.props.kpi.valueConditionalFormatters;
        
        for(var i=0; i < conditionalParam.length; i++) {
          if(evalExpression(conditionalParam[i].expression, self.props.kpi.display.value)) {
            valueTextColor = conditionalParam[i].valueColor;
          }
        }
        
        kpi = new RFKPI();
        config = {
          valueString: applyNumberFormatting(self.props.kpi.display.value),
          value: self.props.kpi.display.value,
          numberFormatProps: self.props.kpi.display,
          captionString: self.props.core.caption,
          dimensions: self.props.core.dimensions,
          mode: mode,
          sparkValues: sparkValues,
          sparkLabels: sparkLabels,
          limits: limits,
          icon: self.props.kpi.display.icon,
          iconProps: JSON.parse(self.props.kpi.display.iconprops),
          valueTextColor: valueTextColor
        };
        if (self.props.kpi.display.sparkFlag) {
          config.sparkFlag = true;
        } else if (self.props.kpi.display.gaugeFlag) {
          config.gaugeFlag = true;
        }
        kpi.configure(config);
        kpi.renderTo(self.$core);
        self.$core.click(function () {
          self.pro.trigger("click", {
            a:"hello",
            b:"world"
          });
        });
      },
      resizeCore: function (width, height) {
        if(kpi) {
          kpi.resizeTo(width, height);
        }
      },
      updateValue: function(newValue, oldValue) {
        kpi.updateValue(newValue, oldValue);
      }
    };

    Protected = {

    };

    var applyNumberFormatting  = function(val) {
      var numberFormatter = new NumberFormatter();
      numberFormatter.setConfig(self.props.kpi.display);
      return numberFormatter.formatValue(val);
    };

    raw._registerClassName("KPIRenderer");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);
  }

  return KPIRenderer;
});

define('prop/proputils',["utils/media",
  "vendor/lodash"],
    function (mediaUtils, _) {
      return {
        error: function (message, object) {
          console.error(message, object);
        },

        isProp: function (item) {
          if (item !== null && typeof(item) !== 'undefined') {
            if (item.isPropList || item.isPropBase) {
              return true;
            }

            var selected = mediaUtils.fastMediaSelect(mediaUtils.getCurrentMedia(), item);
            if (selected === null) {
              return false;
            }
            if (selected.isPropList || selected.isPropBase) {
              return true;
            }

            return false;
          }
          return false;
        },

        isPropList: function (item) {
          if (item !== null && typeof(item) !== 'undefined') {
            if (item.isPropList) {
              return true;
            }
            var selected = mediaUtils.fastMediaSelect(mediaUtils.getCurrentMedia(), item);
            if (selected === null) {
              return false;
            }

            if (selected.isPropList) {
              return true;
            }

            return false;
          }
          return false;
        },

        isPropBase: function (item) {
          if (item !== null && typeof(item) !== 'undefined') {
            if (item.isPropBase) {
              return true;
            }

            var selected = mediaUtils.fastMediaSelect(mediaUtils.getCurrentMedia(), item);
            if (selected === null) {
              return false;
            }
            if (selected.isPropBase) {
              return true;
            }
            return false;
          }
          return false;
        },
        sanitizeHTML: function (str) {
          if (_.isString(str)) {
            return str.replace(/(<([^>]+)>)/ig,"");
          }
          return str;
        }
      };
    });
define('prop/propertybase',[
    "utils/media",
    "prop/proputils",
    "vendor/lodash"
], function (mediaUtils, propUtils, _) {


    function PropertyBase() {
        var self = this,
            cobj = null,
            data = {},
            defaults = {},
            subscribers = {},
            parentList = null, listIndex = null,
            basePath = '',
            parentProp = null,
            modifiedStatus = {},
            types = {};

        self.isPropBase = true;

        /**
         * Setters
         */
        self.setValue = function (path, value, rootPath) {
            var parts = getParts(path);
            rootPath = rootPath ? rootPath : path;

            // the final setting logic only works on terminal leaves which
            // have a regular value.

            if (parts.terminal && !propUtils.isPropBase(parts.root)) {
                var oldValue = data[parts.key];
                value = propUtils.sanitizeHTML(value);
                data[parts.key] = value;
                modifiedStatus[parts.key] = true;

                self.trigger('setValue', rootPath, value, oldValue, parts);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                modifiedStatus[parts.key] = true;
                parts.root.setValue(parts.rest, value, rootPath);
            }
            else {
                propUtils.error("Cannot set a value to this pb", parts);
            }
        };
        /**
         * Set the root object
         *
         * @param object
         */
        self.setRootObject = function (object) {
            var key;
            data = _.clone(defaults);
            object = self.flipMedia(object);

            for (key in object) {
                if (data.hasOwnProperty(key)) {
                    if (propUtils.isProp(data[key])) {
                        data[key].setRootObject(object[key], true);
                        modifiedStatus[key] = true;
                    }
                    else {
                        data[key] = object[key];
                        modifiedStatus[key] = true;
                    }
                }
                else {
                    propUtils.error("Unknown key in object", key);
                }
            }
        };


        self.setObjectAtPath = function (path, object, rootPath) {
            var parts = getParts(path);
            rootPath = rootPath ? rootPath : path;
            // the final setting logic only works on terminal leaves which
            // have a regular value.
            if (parts.terminal && propUtils.isProp(parts.root)) {
                var oldValue = parts.root.getRootObject();
                for (var key in object) {
                    object[key] = propUtils.sanitizeHTML(object[key]);
                }
                parts.root.setRootObject(object, true);

                self.trigger('setObjectAtPath', rootPath, object, oldValue, parts);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.setObjectAtPath(parts.rest, object, rootPath);
            }
            else {
                propUtils.error("Cannot set an object to this pb", parts);
            }
        };

        self.addItemToList = function (path, id, item, rootPath) {
            var parts = getParts(path);
            rootPath = rootPath ? rootPath : path;
            // the final setting logic only works on terminal leaves which
            // have a regular value.
            if (parts.terminal && propUtils.isPropList(parts.root)) {
                for (var key in item) {
                    item[key] = propUtils.sanitizeHTML(item[key]);
                }
                var itemObj = parts.root.addItem(id, item, true);
                self.trigger('addItemToList', rootPath, itemObj, null, parts);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.addItemToList(parts.rest, id, item, rootPath);
            }
            else {
                propUtils.error("Cannot add an item to this pb", parts);
            }
        };

        self.pushItemToList = function (path, item, rootPath) {
            var parts = getParts(path);

            rootPath = rootPath ? rootPath : path;

            // the final setting logic only works on terminal leaves which
            // have a regular value.
            if (parts.terminal && propUtils.isPropList(parts.root)) {
                var itemObj = parts.root.pushItem(item, true);
                for (var key in item) {
                    item[key] = propUtils.sanitizeHTML(item[key]);
                }
                self.trigger('pushItemToList', rootPath, itemObj, null, parts);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.pushItemToList(parts.rest, item, rootPath);
            }
            else {
                propUtils.error("Cannot push an item to this pb", parts);
            }
        };

        self.resetValue = function (path, rootPath) {
            var parts = getParts(path);
            rootPath = rootPath ? rootPath : path;

            // the final setting logic only works on terminal leaves which
            // have a regular value.
            if (parts.terminal && !propUtils.isPropBase(parts.root)) {
                var oldValue = data[parts.key];
                var value = defaults[parts.key];
                data[parts.key] = value;

                self.trigger('resetValue', rootPath, value, oldValue, parts);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.resetValue(parts.rest, rootPath);
            }
            else {
                propUtils.error("Cannot set a value to this pb", parts);
            }
        };

        self.resetKeyInAll = function (path, key) {
            var parts = getParts(path);


            // the final setting logic only works on terminal leaves which
            // have a regular value.
            if (parts.terminal && propUtils.isPropList(parts.root)) {
                parts.root.resetKeyInAll(key);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.resetKeyInAll(parts.rest, key);
            }
            else {
                propUtils.error("Cannot push an item to this pb", parts);
            }
        };

        /**
         * Getters
         */
        self.getValue = function (path) {
            var parts = getParts(path);

            if (parts.terminal && !propUtils.isProp(parts.root)) {
                return self.responsiveFilter(data[parts.key]);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                return parts.root.getValue(parts.rest);
            }

            propUtils.error("Cannot get value for ", parts);
        };

        self.getRootObject = function () {
            var key, res = {};

            for (key in data) {
                if (propUtils.isProp(data[key])) {
                    res[key] = data[key].getRootObject();
                }
                else {
                    res[key] = rawGetData(key);
                }
            }

            return self.responsiveFilter(res);
        };

        self.getObjectAtPath = function (path) {
            var parts = getParts(path);

            if (parts.terminal && propUtils.isProp(parts.root)) {
                return parts.root.getRootObject();
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                return parts.root.getObjectAtPath(parts.rest);
            }

            propUtils.error("Cannot get object for ", parts);
        };

        self.isSet = function (path) {
            var parts = getParts(path);

            if (parts.terminal && !propUtils.isProp(parts.root)) {
                return data[parts.key] !== null;
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                return parts.root.isSet(parts.rest);
            }

            propUtils.error("Cannot get value for ", parts);
        };

        self.getListItem = function (path, index) {
            var parts = getParts(path);

            if (parts.terminal && propUtils.isPropList(parts.root)) {
                return parts.root.getListItem(index);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                return parts.root.getListItem(parts.rest, index);
            }
            else {
                propUtils.error("Cannot set a value to this pb", parts);
            }
        };

        self.checkHasKey = function (path, key) {
            var parts = getParts(path);

            if (parts.terminal && propUtils.isPropList(parts.root)) {
                return parts.root.checkHasKey(key);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                return parts.root.checkHasKey(parts.rest, key);
            }
            else {
                propUtils.error("check if this key exists", parts);
            }
        };

        self.validate = function () {
            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    console.log("Validating key", key);

                    if (propUtils.isPropBase(data[key])) {
                        console.log("going into ", key);
                        data[key].validate();
                        console.log("Came out of ", key);
                    }
                    else if (propUtils.isPropList(data[key])) {
                        var listAsOb = data[key].getRootObject();
                        console.warn("Validating as a list", key);
                        console.warn(listAsOb);
                        data[key].validate();
                    }
                    else {
                        console.warn("Actually validating", key);
                    }
                }
            }

            return [];
        };


        /**
         * Utilities
         */
        self.register = function (properties) {

            _.each(properties, function (property) {
                var key = property.key;
                    data[key] = property.value;
                    defaults[key] = property.value;
                    subscribers [key] = [];
                    modifiedStatus[key] = false;
                    types[key] = property.type;
            })
            // for (key in items) {
            //     if (items.hasOwnProperty(key)) {
            //         item = items[key];
            //         if (propUtils.isProp(item)) {
            //             item.setParentProp(self);
            //         }
            //         data[key] = item;
            //         defaults[key] = item;
            //         subscribers [key] = [];
            //         modifiedStatus[key] = false;
            //     }

            // }
        };

        self.registerTypes = function (items) {

        }
        self.responsiveFilter = function (obj) {
            var media = mediaUtils.getCurrentMedia(),
                result = null;

            if (obj === null) {
                return null;
            }
            else if (_.isArray(obj)) {
                result = obj;
                // for (var i = 0; i < obj.length; i++) {
                //     var selectedObj = rf.utils.fastMediaSelect(media, obj[key]);
                //     result.push(self.responsiveFilter(selectedObj));
                // }

                return result;
            }
            else if (_.isObject(obj)) {
                // If it's an object, it can be one of 2 things:
                //
                // 1. a final value which is an object like {xs: 42, sm: 43}
                // 2. A complex object

                var realObject = mediaUtils.fastMediaSelect(media, obj);

                if (realObject === Object(obj)) {
                    result = {};
                    for (var key in realObject) {
                        if (realObject.hasOwnProperty(key)) {
                            var selectedObj = mediaUtils.fastMediaSelect(media, realObject[key]);
                            result[key] = self.responsiveFilter(selectedObj);
                        }
                    }

                    return result;
                }
                else {
                    return realObject;
                }


            }
            else {
                return obj;
            }
        };

        self.flipMedia = function (object) {
            if (!mediaUtils.isMediaObject(object)) {
                return object;
            }

            var result = {};

            for (var mediaType in object) {
                if (object.hasOwnProperty(mediaType)) {
                    for (var key in object[mediaType]) {
                        if (object[mediaType].hasOwnProperty(key)) {
                            if (!result[key]) {
                                result[key] = {};
                            }
                            result[key][mediaType] = object[mediaType][key];
                        }
                    }
                }
            }

            return result;
        };

        self.linkToComponent = function (component) {
            var key;

            cobj = component;

            for (key in data) {
                if (propUtils.isProp(data[key])) {
                    data[key].linkToComponent(component);
                }
            }
        };

        self.setBasePath = function (bp) {
            basePath = bp;

            for (var key in data) {
                if (propUtils.isProp(data[key])) {
                    data[key].setBasePath(basePath + '.' + key);
                }
            }
        };

        self.setParentProp = function (pp) {
            parentProp = pp;
        };

        self.trigger = function (type, path, newValue, oldValue, parts) {
            var listChanged = false;
            if (parentList !== null) {
                listChanged = parentList.onItemUpdated(listIndex, self);
            }
            if (cobj !== null) {
                if (!listChanged) {
                    cobj.pro.applyChange(type, path, newValue, oldValue, parts);
                }
            }
            if (subscribers.hasOwnProperty(parts.key)) {
                if (subscribers[parts.key].length > 0) {
                    for (var i = 0; i < subscribers[parts.key].length; i++) {
                        subscribers[parts.key][i](newValue, oldValue);
                    }
                }
            }
        };

        self.applyPatch = function (patchObj) {
            var action = patchObj.action,
                path = patchObj.path,
                params = patchObj.params;

            switch (action) {
                case 'setValue':
                    self.setValue(path, params);
                    break;
                case 'setObjectAtPath':
                    self.setObjectAtPath(path, params);
                    break;
                case 'addItemToList':
                    self.addItemToList(path, params.id, params.item);
                    break;
                case 'pushItemToList':
                    self.addItemToList(path, params.item);
                    break;
                case 'emptyList':
                    self.emptyList(path);
                    break;
            }
        };

        self.subscribe = function (path, callback) {
            var parts = getParts(path);

            if (parts.terminal && !propUtils.isPropBase(parts.root)) {
                subscribers[parts.key].push(callback);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.subscribe(parts.rest, callback);
            }
            else {
                propUtils.error("Cannot set a value to this pb", parts);
            }
        };

        self.listSubscribe = function (path, callback) {
            var parts = getParts(path);

            if (parts.terminal && propUtils.isPropList(parts.root)) {
                parts.root.listSubscribe(callback);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.listSubscribe(parts.rest, callback);
            }
            else {
                propUtils.error("Cannot set a value to this pb", parts);
            }
        };

        self.resetListSubscribers = function (path) {
            var parts = getParts(path);

            if (parts.terminal && propUtils.isPropList(parts.root)) {
                parts.root.resetListSubscribers(callback);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.resetListSubscribers(parts.rest, callback);
            }
            else {
                propUtils.error("Cannot set a value to this pb", parts);
            }
        };


        self.emptyList = function (path, rootPath) {
            var parts = getParts(path);

            rootPath = rootPath ? rootPath : path;

            // the final setting logic only works on terminal leaves which
            // have a regular value.
            if (parts.terminal && propUtils.isPropList(parts.root)) {
                parts.root.emptyList();

                self.trigger('emptyList', rootPath, null, null, parts);
            }
            else if (!parts.terminal && propUtils.isPropBase(parts.root)) {
                parts.root.emptyList(parts.rest, rootPath);
            }
            else {
                error("Cannot empty this pb", parts);
            }
        };

        self.sag = function (path, callback) {
            self.subscribe(path, callback);

            callback(self.getValue(path), null);

        };

        self.setModifiedStatus = function (key) {

        };

        var getParts = function (path) {
            var parts = path.split('.'),
                currentPart = parts[0],
                indexMatches = currentPart.match(/\[.+\]/),
                indexValue = null,
                rootItem = null,
                rootList = null,
                terminal = parts.length === 1;

            // index matches in case the path is structured like this:
            // foo[3].bar.test
            if (indexMatches !== null) {
                // Let's say Path is "foo[3].bar.test"
                // indexvalue is "[3]"
                indexValue = indexMatches[0];

                // Current part is "foo"
                currentPart = currentPart.substr(0, currentPart.length - indexValue.length);

                // Indexvalue is now "3"
                indexValue = indexValue.substr(1, indexValue.length - 2);

                // Root list is now data["foo"] which gives us the propertylist object
                rootList = data[currentPart];

                // Now we have to extract the rootItem. This will be equivalent to get("foo[3]")
                // because the logic to handle the remaining is common whether it's get("foo[3]") or get("foo");
                if (!isNaN(parseInt(indexValue, 10))) {
                    // This means that indexValue is a number
                    rootItem = rootList.getAtIndex(parseInt(indexValue, 10));
                }
                else {
                    rootItem = rootList.getAtId(indexValue);
                }
            }
            else {
                rootItem = data[parts[0]];
            }

            parts.shift();

            var obj = {
                root: rootItem,
                key: currentPart,
                rest: parts.join('.'),
                terminal: terminal
            };
            return obj;
        };

        var rawGetData = function (key) {
            if(data.hasOwnProperty(key)) {
                if (types[key] === "color") {
                    if(data[key] !== 'auto') {
                        return (data[key].match(/^#/) ? data[key] : '#' + data[key]);
                    }
                    return data[key];
                }
                return data[key];
            }
            else {
                throw "Unknown key to get data:" + key;
            }
            return null;
        }

        self.setParentList = function (proplist, index) {
            parentList = proplist;
            listIndex = index;
        };
    }


    return PropertyBase;
});

define('prop/propertylist',[
  "prop/propertybase",
  "utils/media",
  "prop/proputils"
],
    function (PropertyBase, mediaUtils, propUtils) {
      function PropertyList(ObjType) {
        var self = this,
            cobj = null,
            dataArr = [],
            dataObj = {},
            objMode = false,
            parentProp = null,
            listSubscribers = [],
            basePath;

        self.isPropList = true;

        /**
         * Setters
         */
        self.setRootObject = function (object) {
          var key,
              i;
          dataArr = [];
          dataObj = [];
          if (typeof(object[0]) === "undefined") {
            objMode = true;
          }

          if (objMode) {
            for (key in object) {
              if (object.hasOwnProperty(key)) {
                self.addItem(key, object[key]);
              }
            }
          }
          else {
            for (i = 0; i < object.length; i++) {
              self.pushItem(object[i]);
            }
          }
        };

        self.resetKeyInAll = function (keyName) {
          iterateOverItems(function (key, obj) {
            obj.resetValue(keyName);
          });
        };

        var makeObj = function (item, index) {
          var itemObj;
          if (propUtils.isPropBase(item)) {
            itemObj = item;
          }
          else {
            var newObject = new ObjType();
            newObject.setRootObject(item);
            itemObj = newObject;
          }

          if (cobj !== null) {
            itemObj.linkToComponent(cobj);
          }

          itemObj.setParentList(self, index);
          itemObj.setBasePath(basePath);

          for (var i = 0; i < listSubscribers.length; i++) {
            listSubscribers[i].init(index, itemObj.getRootObject());
          }

          return itemObj;
        };

        self.addItem = function (key, item) {
          objMode = true;

          var obj = makeObj(item, key);
          dataObj[key] = obj;
          return obj;
        };

        self.pushItem = function (item) {
          objMode = false;
          var obj = makeObj(item, dataArr.length);
          dataArr.push(obj);
          return obj;
        };

        /**
         * Getters
         */
        self.getRootObject = function () {
          var key, i, res;

          if (objMode) {
            res = {};
            for (key in dataObj) {
              if (dataObj.hasOwnProperty(key)) {
                res[key] = dataObj[key].getRootObject();
              }
            }
          }
          else {
            res = [];
            for (i = 0; i < dataArr.length; i++) {
              res.push(dataArr[i].getRootObject());
            }
          }

          return res;
        };

        self.getAtIndex = function (index) {
          return dataArr [index];
        };

        self.getAtId = function (id) {
          return dataObj [id];
        };

        self.getListItem = function (index) {
          if (dataObj) {
            return dataObj[index];
          }
          else {
            return dataArr[index];
          }
        };

        self.checkHasKey = function (key) {
          if (dataObj) {
            return dataObj.hasOwnProperty(key);
          }
          else {
            return dataArr.length < parseInt(key, 10);
          }
        };

        /**
         * Utilities
         */
        self.linkToComponent = function (component) {
          cobj = component;

          // link existing items to component
          iterateOverItems(function (key, obj) {
            obj.linkToComponent(component);
          });
        };

        self.listSubscribe = function (object) {
          listSubscribers.push(object);

          iterateOverItems(function (key, obj) {
            object.init(key, obj.getRootObject());
          });
        };

        self.resetListSubscribers = function () {
          listSubscribers = [];
        };

        self.onItemUpdated = function (key, value) {
          var i;

          if (listSubscribers.length === 0) {
            return false;
          }

          for (i = 0; i < listSubscribers.length; i++) {
            listSubscribers[i].update(key, value.getRootObject());
          }

          return true;
        };

        self.validate = function () {
          iterateOverItems(function (index, item) {
            console.log("PROPLIST!!! Validating", index);
            item.validate();
          });

          return items;
        };

        self.emptyList = function () {
            if (dataObj) {
              dataObj = {};
              return dataObj;
            }
            else {
              dataArr = [];
              return dataArr;
            }
        };

        var iterateOverItems = function (cb) {
          var key, i;
          if (objMode) {
            for (key in dataObj) {
              if (dataObj.hasOwnProperty(key)) {
                cb(key, dataObj[key]);
              }
            }
          }
          else {
            for (i = 0; i < dataArr.length; i++) {
              cb(i, dataArr[i]);
            }
          }
        };

        self.setParentProp = function (prop) {
          parentProp = prop;
        };

        self.setBasePath = function (bp) {
          basePath = bp;
        };

        self.getBasePath = function () {
          return basePath;
        };
      }

      return PropertyList;
    });
define('prop/properties',[
    'prop/propertybase',
    'prop/propertylist'
], function (PropertyBase, PropertyList) {
  var exports = {};

function NullProperties() {
  PropertyBase.call(this);

  this.register([
    
  ]);
}
exports.NullProperties = NullProperties;




function DataColumnProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'dataType',
    value:"auto",
    type: 'string'},
{
key: 'numberFormatFlag',
    value:true,
    type: 'boolean'},
{
key: 'numberHumanize',
    value:false,
    type: 'boolean'},
{
key: 'numberPrefix',
    value:null,
    type: 'string'},
{
key: 'numberSuffix',
    value:null,
    type: 'string'},
{
key: 'numberThousandsSeparator',
    value:".",
    type: 'string'},
{
key: 'numberDecimalsSeparator',
    value:",",
    type: 'string'},
{
key: 'numberForceDecimals',
    value:false,
    type: 'boolean'},
{
key: 'numberDecimalPoints',
    value:2,
    type: 'number'}
  ]);
}
exports.DataColumnProperties = DataColumnProperties;




function ComponentProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'core',
    value:new ComponentCoreProperties(),
    type: 'PropertyBase'},
{
key: 'events',
    value:new PropertyList(ComponentEventProperties),
    type: 'PropertyList'},
{
key: 'children',
    value:new PropertyList(NullProperties),
    type: 'PropertyList'},
{
key: 'data',
    value:new ComponentDataProperties(),
    type: 'PropertyBase'},
{
key: 'kpis',
    value:new PropertyList(ComponentKPIProperties),
    type: 'PropertyList'}
  ]);
}
exports.ComponentProperties = ComponentProperties;




function ComponentKPIProperties() {
  DataColumnProperties.call(this);

  this.register([
    {
key: 'caption',
    value:"",
    type: 'string'},
{
key: 'value',
    value:0,
    type: 'number'},
{
key: 'captioncolor',
    value:null,
    type: 'string'},
{
key: 'valuecolor',
    value:null,
    type: 'string'},
{
key: 'Width',
    value:2,
    type: 'number'},
{
key: 'activeFlag',
    value:true,
    type: 'boolean'},
{
key: 'icon',
    value:null,
    type: 'string'},
{
key: 'iconprops',
    value:"{}",
    type: 'string'},
{
key: 'valueConditionalFormatters',
    value:new PropertyList(ValueConditionalFormat),
    type: 'PropertyList'}
  ]);
}
exports.ComponentKPIProperties = ComponentKPIProperties;




function ComponentDataProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'sources',
    value:new PropertyList(RemoteDataSourceProperties),
    type: 'PropertyList'}
  ]);
}
exports.ComponentDataProperties = ComponentDataProperties;




function RemoteDataSourceProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'url',
    value:null,
    type: 'string'}
  ]);
}
exports.RemoteDataSourceProperties = RemoteDataSourceProperties;




function ComponentEventProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'type',
    value:"",
    type: 'string'},
{
key: 'affectedComponents',
    value:new PropertyList(AffectedComponentProperties),
    type: 'PropertyList'},
{
key: 'url',
    value:"",
    type: 'string'},
{
key: 'context',
    value:"",
    type: 'url'}
  ]);
}
exports.ComponentEventProperties = ComponentEventProperties;




function AffectedComponentProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'id',
    value:null,
    type: 'string'}
  ]);
}
exports.AffectedComponentProperties = AffectedComponentProperties;




function ComponentCoreProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'caption',
    value:"",
    type: 'string'},
{
key: 'icon',
    value:null,
    type: 'string'},
{
key: 'iconprops',
    value:"{}",
    type: 'string'},
{
key: 'absolutePosition',
    value:false,
    type: 'boolean'},
{
key: 'dimensions',
    value:new ComponentDimensionProperties(),
    type: 'PropertyBase'},
{
key: 'isChild',
    value:false,
    type: 'boolean'},
{
key: 'location',
    value:new ComponentLocationProperties(),
    type: 'PropertyBase'},
{
key: 'zoomable',
    value:true,
    type: 'string'},
{
key: 'breadCrumbs',
    value:new PropertyList(BreadCrumbProperties),
    type: 'PropertyList'},
{
key: 'isHidden',
    value:false,
    type: 'boolean'},
{
key: 'showModal',
    value:false,
    type: 'boolean'},
{
key: 'breadcrumbStartString',
    value:"Start",
    type: 'string'},
{
key: 'index',
    value:99999,
    type: 'Number'}
  ]);
}
exports.ComponentCoreProperties = ComponentCoreProperties;




function BreadCrumbProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'url',
    value:null,
    type: 'string'}
  ]);
}
exports.BreadCrumbProperties = BreadCrumbProperties;




function ComponentDimensionProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'w',
    value:null,
    type: 'number'},
{
key: 'h',
    value:null,
    type: 'number'}
  ]);
}
exports.ComponentDimensionProperties = ComponentDimensionProperties;




function ComponentLocationProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'x',
    value:null,
    type: 'number'},
{
key: 'y',
    value:null,
    type: 'number'},
{
key: 'w',
    value:null,
    type: 'number'},
{
key: 'h',
    value:null,
    type: 'number'}
  ]);
}
exports.ComponentLocationProperties = ComponentLocationProperties;




function KPIComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'kpi',
    value:new KPIProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.KPIComponentProperties = KPIComponentProperties;




function KPIProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'display',
    value:new KPIDisplayProperties(),
    type: 'PropertyBase'},
{
key: 'valueConditionalFormatters',
    value:new PropertyList(ValueConditionalFormat),
    type: 'PropertyList'}
  ]);
}
exports.KPIProperties = KPIProperties;




function ValueConditionalFormat() {
  PropertyBase.call(this);

  this.register([
    {
key: 'expression',
    value:"",
    type: 'string'},
{
key: 'valueColor',
    value:"auto",
    type: 'string'}
  ]);
}
exports.ValueConditionalFormat = ValueConditionalFormat;




function KPIDisplayProperties() {
  DataColumnProperties.call(this);

  this.register([
    {
key: 'dataType',
    value:"number",
    type: 'string'},
{
key: 'value',
    value:0,
    type: 'number'},
{
key: 'indicator',
    value:null,
    type: 'string'},
{
key: 'indicatorColor',
    value:"green",
    type: 'string'},
{
key: 'caption',
    value:"",
    type: 'string'},
{
key: 'subcaption',
    value:"",
    type: 'string'},
{
key: 'target',
    value:null,
    type: 'number'},
{
key: 'gaugeType',
    value:"circular",
    type: 'string'},
{
key: 'gaugeFlag',
    value:false,
    type: 'boolean'},
{
key: 'sparkFlag',
    value:false,
    type: 'boolean'},
{
key: 'ranges',
    value:new PropertyList(RFRangeProperties),
    type: 'PropertyList'},
{
key: 'maximum',
    value:null,
    type: 'number'},
{
key: 'minimum',
    value:null,
    type: 'number'},
{
key: 'type',
    value:null,
    type: 'string'},
{
key: 'icon',
    value:null,
    type: 'string'},
{
key: 'iconprops',
    value:"{}",
    type: 'string'},
{
key: 'valueTextColor',
    value:"auto",
    type: 'string'}
  ]);
}
exports.KPIDisplayProperties = KPIDisplayProperties;




function RFRangeProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'start',
    value:null,
    type: 'number'},
{
key: 'end',
    value:null,
    type: 'number'},
{
key: 'color',
    value:null,
    type: 'string'}
  ]);
}
exports.RFRangeProperties = RFRangeProperties;




function ChartComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'chart',
    value:new ChartProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.ChartComponentProperties = ChartComponentProperties;




function ChartProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'series',
    value:new PropertyList(ChartSeriesProperties),
    type: 'PropertyList'},
{
key: 'yaxis',
    value:new ChartAxisProperties(),
    type: 'PropertyBase'},
{
key: 'xaxis',
    value:new ChartAxisProperties(),
    type: 'PropertyBase'},
{
key: 'secondaryYAxis',
    value:new ChartAxisProperties(),
    type: 'PropertyBase'},
{
key: 'dualY',
    value:false,
    type: 'boolean'},
{
key: 'showLegendFlag',
    value:true,
    type: 'boolean'},
{
key: 'showPieValues',
    value:true,
    type: 'boolean'},
{
key: 'showLabelFlag',
    value:true,
    type: 'boolean'},
{
key: 'labelStep',
    value:new LabelStepProperties(),
    type: 'PropertyBase'},
{
key: 'trendline',
    value:new TrendLineProperties(),
    type: 'PropertyBase'},
{
key: 'stackedTotalDisplay',
    value:false,
    type: 'boolean'}
  ]);
}
exports.ChartProperties = ChartProperties;




function TrendLineProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'value',
    value:null,
    type: 'number'},
{
key: 'label',
    value:"",
    type: 'string'},
{
key: 'color',
    value:"#000000",
    type: 'string'},
{
key: 'enabled',
    value:false,
    type: 'boolean'}
  ]);
}
exports.TrendLineProperties = TrendLineProperties;




function LabelStepProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'interval',
    value:null,
    type: 'number'},
{
key: 'startIndex',
    value:0,
    type: 'number'}
  ]);
}
exports.LabelStepProperties = LabelStepProperties;




function ChartAxisProperties() {
  DataColumnProperties.call(this);

  this.register([
    {
key: 'id',
    value:"primary",
    type: 'string'},
{
key: 'dataType',
    value:"number",
    type: 'string'},
{
key: 'axisName',
    value:"",
    type: 'string'},
{
key: 'minValue',
    value:null,
    type: 'number'},
{
key: 'maxValue',
    value:null,
    type: 'number'},
{
key: 'numTicks',
    value:null,
    type: 'number'}
  ]);
}
exports.ChartAxisProperties = ChartAxisProperties;




function ChartSeriesProperties() {
  DataColumnProperties.call(this);

  this.register([
    {
key: 'dataType',
    value:"number",
    type: 'string'},
{
key: 'seriesName',
    value:"",
    type: 'string'},
{
key: 'seriesDisplayType',
    value:"column",
    type: 'string'},
{
key: 'seriesColor',
    value:"auto",
    type: 'color'},
{
key: 'seriesHiddenFlag',
    value:false,
    type: 'boolean'},
{
key: 'includeInLegendFlag',
    value:true,
    type: 'boolean'},
{
key: 'seriesStacked',
    value:false,
    type: 'boolean'},
{
key: 'yAxis',
    value:"primary",
    type: 'string'}
  ]);
}
exports.ChartSeriesProperties = ChartSeriesProperties;




function GaugeComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'gauge',
    value:new GaugeProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.GaugeComponentProperties = GaugeComponentProperties;




function GaugeProperties() {
  DataColumnProperties.call(this);

  this.register([
    {
key: 'caption',
    value:"",
    type: 'string'},
{
key: 'subcaption',
    value:"",
    type: 'string'},
{
key: 'min',
    value:0,
    type: 'number'},
{
key: 'max',
    value:100,
    type: 'number'},
{
key: 'value',
    value:50,
    type: 'number'}
  ]);
}
exports.GaugeProperties = GaugeProperties;




function TableComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'table',
    value:new TableProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.TableComponentProperties = TableComponentProperties;




function TableProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'columns',
    value:new PropertyList(TableColumnProperties),
    type: 'PropertyList'},
{
key: 'cellConditionalFormatters',
    value:new PropertyList(TableCellConditionalFormat),
    type: 'PropertyList'},
{
key: 'rowsPerPage',
    value:10,
    type: 'number'},
{
key: 'currentPageNumber',
    value:0,
    type: 'number'},
{
key: 'totalRows',
    value:0,
    type: 'number'}
  ]);
}
exports.TableProperties = TableProperties;




function TableCellConditionalFormat() {
  PropertyBase.call(this);

  this.register([
    {
key: 'conditionalExpression',
    value:new ConditionalExpressionProperties(),
    type: 'PropertyBase'},
{
key: 'format',
    value:new TableCellFormatProperties(),
    type: 'PropertyBase'},
{
key: 'column_id',
    value:"",
    type: 'string'}
  ]);
}
exports.TableCellConditionalFormat = TableCellConditionalFormat;




function ConditionalExpressionProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'expression',
    value:"",
    type: 'string'},
{
key: 'type',
    value:"",
    type: 'string'}
  ]);
}
exports.ConditionalExpressionProperties = ConditionalExpressionProperties;




function TableCellFormatProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'cellBackgroundColor',
    value:"auto",
    type: 'string'},
{
key: 'cellTextColor',
    value:"auto",
    type: 'string'}
  ]);
}
exports.TableCellFormatProperties = TableCellFormatProperties;




function TableColumnProperties() {
  DataColumnProperties.call(this);

  this.register([
    {
key: 'name',
    value:"",
    type: 'string'},
{
key: 'columnType',
    value:"text",
    type: 'string'},
{
key: 'sortable',
    value:false,
    type: 'boolean'},
{
key: 'columnWidth',
    value:null,
    type: 'number'},
{
key: 'textAlign',
    value:null,
    type: 'string'},
{
key: 'textBoldFlag',
    value:false,
    type: 'boolean'},
{
key: 'textItalicFlag',
    value:false,
    type: 'boolean'},
{
key: 'rawHTML',
    value:false,
    type: 'boolean'},
{
key: 'subCaption',
    value:false,
    type: 'boolean'},
{
key: 'subCaptionUnits',
    value:null,
    type: 'string'}
  ]);
}
exports.TableColumnProperties = TableColumnProperties;




function FormComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'form',
    value:new FormProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.FormComponentProperties = FormComponentProperties;




function FormProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'items',
    value:new PropertyList(FormItemProperties),
    type: 'PropertyList'}
  ]);
}
exports.FormProperties = FormProperties;




function FormItemProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'type',
    value:"",
    type: 'string'},
{
key: 'label',
    value:"",
    type: 'string'},
{
key: 'list',
    value:"string",
    type: 'string'},
{
key: 'options',
    value:"",
    type: 'string'},
{
key: 'range',
    value:"",
    type: 'string'},
{
key: 'value',
    value:"",
    type: 'string'}
  ]);
}
exports.FormItemProperties = FormItemProperties;




function KPITableComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'kpitable',
    value:new KPITableProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.KPITableComponentProperties = KPITableComponentProperties;




function KPITableProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'items',
    value:new PropertyList(KPIDisplayProperties),
    type: 'PropertyList'}
  ]);
}
exports.KPITableProperties = KPITableProperties;




function KPITableItem() {
  PropertyBase.call(this);

  this.register([
    {
key: 'caption',
    value:"",
    type: 'string'},
{
key: 'value',
    value:"",
    type: 'number'}
  ]);
}
exports.KPITableItem = KPITableItem;




function TabbedComponentProperties() {
  ComponentProperties.call(this);

  this.register([
    {
key: 'children',
    value:new PropertyList(TabItemProperties),
    type: 'PropertyList'},
{
key: 'tabbed',
    value:new TabbedCoreProperties(),
    type: 'PropertyBase'}
  ]);
}
exports.TabbedComponentProperties = TabbedComponentProperties;




function TabbedCoreProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'activeIndex',
    value:0,
    type: 'number'}
  ]);
}
exports.TabbedCoreProperties = TabbedCoreProperties;




function TabItemProperties() {
  PropertyBase.call(this);

  this.register([
    {
key: 'name',
    value:"",
    type: 'string'},
{
key: 'componentId',
    value:"",
    type: 'string'}
  ]);
}
exports.TabItemProperties = TabItemProperties;




  return exports;
});

define('components/kpicomponentcore',[
  "components/component",
  "renderers/kpirenderer",
  "prop/properties",
  'vendor/lodash'
], function (Component, KPIRenderer, Properties, _) {
  /**
   * This is the base class for all the kpi components
   * @class KPIComponentCore
   * @augments {Component}
   * @access private
   */
  function KPIComponentCore() {
    Component.apply(this, Array.prototype.slice.call(arguments));

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};


    Public = {
      /**
       * Sets a numeric value to the KPI which is displayed on the dashboard.
       * @method setValue
       * @param  {Number} numberValue  The value to be displayed
       * @param  {KPIDisplayProperties} opts options to configure the display
       */
      setValue: function (numberValue, opts) {
        opts = opts || {};
        var _opts = _.extend(pro.pb.getObjectAtPath('kpi.display'), opts);
        _opts.value = numberValue;
        pro.pb.setObjectAtPath("kpi.display", _opts);
      },

      valueConditionalFormat: function (formatRule, appliedStyle) {
        var opts = {};
        opts.expression = formatRule;
        opts.valueColor = appliedStyle;
        pro.pb.pushItemToList("kpi.valueConditionalFormatters", opts);
      }
    };

    Protected = {
      overriddenDimensions: {
        'sm': {
          w: 12,
          h: 3
        },
        'xs': {
          w: 12,
          h: 4
        },
        'md': {
          w: 3,
          h: 3
        },
        'lg': {
          w: 3,
          h: 3
        }
      }
    };

    /**
     * This is the actual constructor of the object
     */
    var construct = function () {
      pro.pb = new Properties.KPIComponentProperties();
    };

    raw._registerClassName("KPIComponent");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    construct();
  }

  return KPIComponentCore;
});

define('components/kpicomponent',[
  "components/kpicomponentcore",
  "renderers/kpirenderer",
  "prop/properties",
  'vendor/lodash'
], function (KPIComponentCore, KPIRenderer, Properties, _) {
  /**
   * Creates a kpi component
   * @class KPIComponent
   * @augments {KPIComponentCore}
   */
  function KPIComponent() {
    KPIComponentCore.apply(this, Array.prototype.slice.call(arguments));
    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};


    Public = {
      /**
       * sets the values to be displayed by the spark
       * @method setSparkValues
       * @param  {Array} labels  Array of labels as strings
       * @param  {Array} values  The values used by the spark
       */
      setSparkValues: function (labels, values) {
        pro.pb.setValue('kpi.display.sparkFlag', true);
        self.ds.addColumn('sparkValue', values);
        self.ds.addColumn('sparkLabel', labels);
      },

      setValueIcon: function(id, props) {
        pro.pb.setValue('kpi.display.icon', id);
        pro.pb.setValue('kpi.display.iconprops', JSON.stringify(props || {}));
      }
    };

    Protected = {
      init: function () {
        _bp.init();
      },
      createRenderer: function () {
        var raw = self.ds.getRawData(),
            labels = _.pluck(raw, 'sparkLabel'),
            values = _.pluck(raw, 'sparkValue');

        pro.renderer = new KPIRenderer();
        pro.renderer.setConfig({
          labels: labels,
          values: values
        });
        pro.renderer.pro.bind("click", function (params) {
          pro.handleComponentEvent ("click", params);
        });
        pro.onRendererCreate();
      },
      renderCore: function () {
        pro.renderer.renderCore();
      },
      resizeCore: function (width, height) {
        pro.renderer.resizeCore(width, height);
      },
      addListeners: function () {
        _bp.addListeners();
        pro.pushListeners([
          {
            path: 'kpi.display',
            callback: updateValue
          }
        ]);
      }
    };

    var updateValue = function(newValue, oldValue) {
      self.trigger("beforeComponentUpdate");
      pro.renderer.updateValue(newValue, oldValue);
      self.trigger("componentUpdate");
    };

    /**
     * This is the actual constructor of the object
     */
      // var construct = function () {
      //     pro.pb = new Properties.KPIComponentProperties();
      // };

    raw._registerClassName("KPIComponent");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    // construct();
  }

  return KPIComponent;
});

define('components/gaugecomponent',[
  "components/kpicomponentcore",
  "renderers/kpirenderer",
  "prop/properties"
], function (KPIComponentCore, KPIRenderer, Properties) {
  /**
   * Creates a gauge component
   * @class GaugeComponent
   * @augments {KPIComponentCore}
   */
  function GaugeComponent() {
  
    KPIComponentCore.apply(this, Array.prototype.slice.call(arguments));

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};


    Public = {
      /**
       * Sets the maximum and minimum values of the gauge.
       * @method setLimits
       * @param  {Number} min Lower bound of the gauge
       * @param  {Number} max Upper bound of the gauge
       */
      setLimits: function (min, max) {
        pro.pb.setValue('kpi.display.minimum', min);
        pro.pb.setValue('kpi.display.maximum', max);
      }
    };

    Protected = {
      init: function () {
        _bp.init();
      },
      createRenderer: function () {
        // var raw = self.ds.getRawData(),
        //     labels = _.pluck(raw, 'sparkLabel'),
        //     values = _.pluck(raw, 'sparkValue');

        pro.renderer = new KPIRenderer();
        pro.renderer.setConfig({
          gaugeFlag: true,
          limits: {
            min: pro.pb.getValue('kpi.display.minimum'),
            max: pro.pb.getValue('kpi.display.maximum')
          }
        });
        pro.onRendererCreate();
      },
      renderCore: function () {
        pro.renderer.renderCore();
      },
      resizeCore: function (width, height) {
        pro.renderer.resizeCore(width, height);
      },
      addListeners: function () {
        _bp.addListeners();
        pro.pushListeners([
          {
            path: 'kpi.display',
            callback: updateValue
          }
        ]);
      }
    };

    var updateValue = function(newValue, oldValue) {
      self.trigger("beforeComponentUpdate");
      pro.renderer.updateValue(newValue, oldValue);
      self.trigger("componentUpdate");
    };

    /**
     * This is the actual constructor of the object
     */
    var construct = function () {
      pro.pb = new Properties.KPIComponentProperties();
      pro.pb.setValue('kpi.display.gaugeFlag', true);
    };

    raw._registerClassName("GaugeComponent");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    construct();
  }

  return GaugeComponent;
});

define('renderers/table/sortingrenderer',[], function () {
  var TableSortingRenderer = function (pro) {
    var self = this;

    var privFunc = function () {
      console.log("New private function");
    };

    /*
     PROTECTED FUNCTIONS
     */
    return {
      initSorting: function () {
      },
      addSortListeners: function () {
        self.managedBind(self.$core.find('.rfTable > thead > tr > th'), 'click', function (e) {
          e.preventDefault();
          self.pro.trigger('sortColumn', $(this).data('id'));
        });
      }
    };
  };

  return TableSortingRenderer;
});

define('renderers/table/paginationrenderer',['utils/media',
  "generated/templates",
  "vendor/Modernizr"
  ], function (MediaUtils, JST, Modernizr) {
  var TablePaginationRenderer = function (pro) {
    var self = this;

    var tPaginator;

    /*
     PROTECTED FUNCTIONS
     */
    return {
      pagination: {
        init: function () {
          tPaginator = self.$core.find(".rfPaginationContainer");
        },
        setData: function (d) {
          if(d.totalPages > 1) {
            var m = (self.db.pro.media.mediaSelect({"sm+xs":true}, false) || Modernizr.touch);
                // hack implelented on not letting the width go too less.
            if (tPaginator.width()<=450) {
              m = true;
            }
            tPaginator.html(JST.table_paginator({
              totalPages: d.totalPages,
              activePage: d.activePage,
              startPage: d.startPage,
              lastPage: d.lastPage,
              media: m
            }));
          }
        },
        addDomListeners: function () {

          // UGLY HACK, TODO(anirudh): remove this
          // 
          self.$core.find(".rfPrevButton").off();
          self.$core.find(".rfNextButton").off();
          self.$core.find(".rfPageNumber").off();

          self.managedBind(self.$core.find(".rfPrevButton"), 'click', function (e) {
            e.preventDefault();
            self.pro.trigger("prevPage");
            self.trigger("pageChange");
            self.trigger("prevPage");
          });
          self.managedBind(self.$core.find(".rfNextButton"), 'click', function (e) {
            e.preventDefault();
            self.pro.trigger("nextPage");
            self.trigger("pageChange");
            self.trigger("nextPage");  
          });
          self.managedBind(self.$core.find(".rfPageNumber"), 'click', function (e) {
            e.preventDefault();
            var pageNumber = $(this).data("page-number");
            self.pro.trigger("jumpToPage", pageNumber);
            self.trigger("pageChange");
          });
        }
      }
    };
  };

  return TablePaginationRenderer;
});

define('utils/styleformatter',["utils/evalexpression", "vendor/klass"], function (EvalExpression, klass) {

  var StyleFormatter = klass({
    textAlign: "",
    textBoldFlag: "",
    textItalicFlag: "",
    rawHTML: null,
    RIGHT_ALIGN: 'right',
    LEFT_ALIGN: 'left',
    CENTER_ALIGN: 'center',
    conditionExpn: {},
    format: {},
    textBoldString: "rfBold",
    textItalicString: "rfItalic",

    setConfig: function (c) {
      var config = c;
      if (typeof(config.textAlign) === 'string') {
        this.textAlign = config.textAlign;
      }

      if (typeof(config.textBoldFlag) === 'boolean') {
        this.textBoldFlag = config.textBoldFlag;
      }

      if (typeof(config.textItalicFlag) === 'boolean') {
        this.textItalicFlag = config.textItalicFlag;
      }

      if (typeof(config.rawHTML) === 'boolean') {
        this.rawHTML = config.rawHTML;
      }

      this.conditionExpn = config.conditionalExpression;
      this.format = config.format;
    },

    formatColumn: function (data, key) {
      data[key]['style'] = this.addStyles();
      return data;
    },

    formatCell: function (data, key) {
      var value = null;
      var cellStyle = [];
      for(var i=0; i<data.length; i++) {
        cellStyle[i] = {};
        if(EvalExpression(this.conditionExpn.expression, data[i][key])) {
          cellStyle[i]["cellBackgroundColor"] = this.format.cellBackgroundColor;
          cellStyle[i]["cellTextColor"] = this.format.cellTextColor;
        }
      }
      return cellStyle;
    },

    filterHTML: function(data, key){
      if(data && !this.rawHTML){
        for(var i=0; i<data.length; i++){
          data[i][key] = this.cleanHTML(data[i][key]);
        }
      }

      return data;
    },

    addStyles: function() {
      var styles = [];

      if (this.textAlign){
        styles.push(this.addTextAlign());
      }

      if (this.textBoldFlag) {
       styles.push(this.textBoldString);
      }

      if (this.textItalicFlag) {
        styles.push(this.textItalicString);
      }

      return styles.join(" ");
    },

    addTextAlign: function(){
      var align = "";

      switch(this.textAlign) {
        case this.CENTER_ALIGN:
          align = 'rfCenter';
          break;
        case this.LEFT_ALIGN:
          align = 'rfLeft';
          break;
        case this.RIGHT_ALIGN:
          align = 'rfRight';
          break;
      }

      return align;
    },

    cleanHTML: function(data) {
      return this.htmlEntities(data);
    },

    htmlEntities: function(str) {
      return String(str).replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;');
    }

  });

  return StyleFormatter;
});

define ('utils/colorutils',[], function () {
  var colorUtils = {
    getColor: function(key) {
      var $element;
      if($("body").find('.canary-' + key).get(0)) {
        $element = $("body").find('.canary-' + key);
        return $element.css('background-color');
      }
      else {
        $element = $('<div/>', { 'class': 'canary-' + key });
        $element.css({
          display: 'none'
        });
        $("body").append($element);
      }

      return $element.css('background-color');
    }
  };

  return colorUtils;
});

define('renderers/tablerenderer',[
  "generated/templates",
  "renderers/componentrenderer",
  "renderers/table/sortingrenderer",
  "renderers/table/paginationrenderer",
  "utils/numberformatter",
  "utils/styleformatter",
  "graphics/rfsparkline",
  "utils/colorutils",
  'vendor/lodash'
], function (JST, ComponentRenderer, TableSortingRenderer, TablePaginationRenderer, NumberFormatter, StyleFormatter, RFSparkline, ColorUtils, _) {
  function TableRenderer() {
    ComponentRenderer.call(this);

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    var tBody = null,
        tHead = null,
        tContainer = null,
        sparkCanvasContainers = [];
    Public = {
      renderCore: function () {
        self.$core.html(JST.table_base({
          columns: formatColumns(self.props.table.columns)
        }));

        self.pagination.init();
        tContainer = self.$core.find('.rfTableContainer');
        tBody = tContainer.find(".rfTableBody");
        tHead = tContainer.find(".rfTableHeader");
        addListeners();
      },
      resizeCore: function (width, height) {
        adjustTableHeight(height);
        adjustCellWidths();
      },
      setTableData: function (d) {
        setTableBody(d);
        self.pagination.setData(d);
        adjustCellWidths();
        headScroller();
        self.pagination.addDomListeners();
      },
      dispose: function () {
        base.dispose();
        tBody = null;
        tHead = null;
        tContainer = null;
      }
    };
    /*
     * Sets the body of the table with columns and data.
     */
    var setTableBody = function (d) {
      var formattedData = formatData(d);
      tBody.html(JST.table_body({
        columns: self.props.table.columns,
        data: formattedData,
        styleClass: formatColumnStyle(formattedData),
        cellStyle: formatCellStyle(d)
      }));

      renderSparkline(formattedData);
      // drawSparkColumn(formattedData);
    };

    var drawSparkColumn = function(data, key, options) {
      for(var i=0; i<data.length; i++) {
        var one = $("<canvas />", { id: "spark" + i });
        var $child = $(tBody.find("#rfTableCell-" + key + "-" + i).children()[0]);

        if($child) {
          var spark = new RFSparkline();
          var config = {
            sparkValues: data[i][key],
            width: $child.width(),
            height: $child.height(),
            id: "spark-" + key + "-" + i,
            strokeColor: options.strokeColor
          };

          spark.configure(config);
          spark.renderTo($child);
        }
      }
    };

    var renderSparkline = function(data) {
      var columnProps = self.props.table.columns;
      var strokeColor = ColorUtils.getColor('tableSparkline');
      for(var key in columnProps) {
        if(columnProps.hasOwnProperty(key)) {
          if(columnProps[key].columnType === 'spark') {
            drawSparkColumn(data, key, {
              strokeColor: strokeColor
            });
          }
        }
      }
    };

    /*
     * Formats table data
     */
    var formatData = function (data) {
      var _data = _.cloneDeep(data);
      var formattedData = null;
      var columnProps = self.props.table.columns;
      for (var key in columnProps) {
        if (columnProps.hasOwnProperty(key)) {
          if(columnProps[key].columnType !== 'spark'){
            var formatter = new NumberFormatter();
            formatter.setConfig(columnProps[key]);
            formattedData = formatter.formatColumn(_data, key);
          }
          else{
            renderSparkline(_data, key);
          }
        }
      }

      return formattedData;
    };

    /*
     * Format table column style
     */
    var formatColumnStyle = function(data){
      var columnProps = _.cloneDeep(self.props.table.columns);
      var cellProps = _.cloneDeep(self.props.table.cellConditionalFormatters);
      var formattedStyle = null;
      for(var key in columnProps){
        if(columnProps.hasOwnProperty(key)){
          var formatter = new StyleFormatter();
          formatter.setConfig(columnProps[key]);
          formattedStyle = formatter.formatColumn(columnProps, key);
          formatter.filterHTML(data, key);
        }
      }
      return formattedStyle;
    };

    var formatCellStyle = function (data) {
      var cellProps = _.cloneDeep(self.props.table.cellConditionalFormatters),
          formattedStyle = {},
          key,
          formatter,
          prevStyle;

      for(var i=0; i< cellProps.length; i++) {
        formatter = new StyleFormatter();
        key = cellProps[i].column_id;
        formatter.setConfig(cellProps[i]);
        if(formattedStyle.hasOwnProperty(key)) {
          formattedStyle[key] = compactObject(formattedStyle[key], formatter.formatCell(data, key));
        } else {
          formattedStyle[key] = formatter.formatCell(data, key);
        }
      }
      return formattedStyle;
    };

    var compactObject = function (oldArr, newArr) {
      _.map(newArr, function(value, key, newArr) {
          if (_.isNull(value) || 
              _.isUndefined(value) || 
              _.keys(value).length === 0 || 
              (_.isString(value) && _.trim(value).length === 0) || 
              (_.isBoolean(value) && value === false))
          {
              newArr[key] = oldArr[key];
          }
      });
      return newArr;
    };

    var addListeners = function () {
      self.pagination.addDomListeners();
      // Sorting disabled need to enable it later
      //self.addSortListeners();
    };

    var adjustTableHeight = function (height) {
      height = height ? height : self.$core.height();
      if (self.locked) {
        return;
      }
      var tcHeight = height - self.$core.find('.rfPaginationContainer').height();
      var thHeight = tHead.height();
      tContainer.height(tcHeight);
      tBody.height(tcHeight - thHeight);

      if (tContainer.height() <= (tHead.find("table").height() + tBody.find("table").height())) {
        tBody.find("table").css({
          "border-bottom" : "0px"
        });
      }
    };

    var headScroller = function () {
      var tbodyDiv = self.$core.find('.rfTableBody'),
          theadDiv = self.$core.find('.rfTableHeader');

      tbodyDiv.on('scroll', function () {
        theadDiv.css({
          'margin-left': -this.scrollLeft
        });
      });
    };

    var formatColumns = function(props) {
      for(var key in props) {
        if(props.hasOwnProperty(key)) {
          if(props[key]['subCaption']) {
            props[key]['subCaptionUnits'] = getSubCaptionUnits(props[key]);
          }
        } 
      }

      return props;
    };

    var getSubCaptionUnits = function(key) {
      if(key.numberPrefix && key.numberSuffix) {
        return key.numberPrefix;
      }
      
      if(key.numberPrefix) {
        return key.numberPrefix;
      }

      if(key.numberSuffix) {
        return key.numberSuffix;
      }

      return null;
    };

    var adjustCellWidths = function () {
      var tbody = self.$core.find('tbody'),
          theadTable = self.$core.find('.rfTableHeader > table'),
          tbodyDiv = self.$core.find('.rfTableBody > table'),
          theadDiv = self.$core.find('.rfTableHeader > table'),
          ths = self.$core.find('th'),
          tableBody = self.$core.find('.rfTableBody'),
          tbodyWidth = null,
          columnProps = null,
          tbodyContainerWidth = tableBody.width();
          firstRowTds = self.$core.find('.rfTableBody > table > tbody > tr').first().find('td'),
          $tp = null,
          $tdWidth = 0,
          tdWidths = [];
      // Reset all the widths
      ths.css('width', 'auto');

      theadDiv.css({
        width: 'auto'
      });
      tbodyDiv.css({
        width: '100%'
      });
      theadTable.css({
        width: '100%'
      });

      columnProps = self.props.table.columns;
      for (var key in columnProps) {
        if (columnProps.hasOwnProperty(key)) {
          if (columnProps[key].columnWidth !== null) {
            $("[data-id="+key+"]").css({
              "min-width" : columnProps[key].columnWidth,
              "width" : columnProps[key].columnWidth
            });
          }
        }
      }

      firstRowTds.each(function (idx, td) {
        $tp = $('<p/>').text($(ths[idx]).text())
            .addClass('canaryTH');
        $(td).append($tp);
      });
      if (tbodyWidth < tbodyContainerWidth) {
        tbodyWidth = tbodyContainerWidth;
      }
      theadDiv.css({
        'width': tbodyWidth
      });
      tbodyDiv.css({
        'width': tbodyWidth
      });
      theadTable.css({
        'width': tbodyWidth
      });
      tbody.css({
        'width': tbodyWidth
      });

      tbody.find('tr').first().find('td').each(function (idx, td) {
        td = $(td);
        //TODO: Hack implemented need a better solution
        $(ths[idx]).find('p').width(td.width());

        tdWidths.push(td.width());
        // td.find('p').width(td.width());
      });

      tbody.find('tr').find('td').each(function (idx, td) {
        $(td).find('p').width(tdWidths[idx]);
      });
      tbody.find('.canaryTH').remove();

      tableBody.scrollTop(0);
    };

    Protected = {
      adjustTableHeight: function() {
        adjustTableHeight();
      }
    };

    raw._registerClassName("TableRenderer");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    raw.registerPublicExtensions(TablePaginationRenderer);
    raw.registerPublicExtensions(TableSortingRenderer);
  }

  return TableRenderer;
});

define('components/table/sortingcore',[], function () {
  var TableSortingCore = function (pro) {
    var self = this;

    return {
      sortColumn: function (className) {
        pro.query.sort(className).triggerUpdates();
      },
      initSortingRender: function () {
        pro.renderer.pro.bind("sortColumn", self.pro.sortColumn);
      }
    };
  };

  return TableSortingCore;
});

define('components/table/paginationcore',['vendor/lodash'], function (_) {
  var TablePaginationCore = function (pro) {
    var self = this,
        table_profiles = {
          pagination: {
            maxPages: 5
          }
        };


    var handlePageNumberUpdated = function (pageNumber) {
      var rowsPerPage = pro.pb.getValue('table.rowsPerPage');
      pro.query.limit(pageNumber * rowsPerPage, rowsPerPage).triggerUpdates(self);
    };


    /*
     * Returns the starting number to be rendered in the pagination.
     */
    var getStartPage = function () {
      var pageNum = pro.pb.getValue("table.currentPageNumber");
      pageNum++;
      if (notMaxPages(pageNum)) {
        if (pageNum < paginationLimit()) {
          return 0;
        }
        else {
          return Math.abs(paginationLimit() - pageNum) + 1;
        }
      }
      else {
        return (getTotalPages() - paginationLimit());
      }
    };

    /*
     * Returns the last page number to be rendered in the pagination.
     */
    var getLastPage = function () {
      return getStartPage() + (paginationLimit() - 1);
    };

    /*
     * Returns the total number of page numbers to be displayed in the pagination.
     */
    var paginationLimit = function () {
      var maxPages = table_profiles.pagination.maxPages;
      if(getTotalPages() < maxPages){
        return getTotalPages();
      }

      return maxPages;
    };

    /*
     * Checks if the current page number is lesser than the maximum/total number of pages.
     */
    var notMaxPages = function (pageNumber) {
      return (pageNumber < getTotalPages());
    };

    /**
     * Returns the total number of pages.
     */
    var getTotalPages = function () {
      var totalRows = pro.pb.getValue("table.totalRows") ? pro.pb.getValue("table.totalRows") : self.ds.getRawData().length;
      var totalPages = (totalRows / pro.pb.getValue("table.rowsPerPage"));
      return Math.ceil(totalPages);
    };


    return {
      pagination: {
        initRender: function () {
          pro.renderer.pro.bind("nextPage", self.pro.pagination.nextPage);
          pro.renderer.pro.bind("prevPage", self.pro.pagination.previousPage);
          pro.renderer.pro.bind("jumpToPage", self.pro.pagination.jumpToPage);

          handlePageNumberUpdated(pro.pb.getValue("table.currentPageNumber"));

        },
        addListeners: function () {
          pro.pushListeners([
            {
              path: "table.currentPageNumber",
              callback: handlePageNumberUpdated
            }
          ]);
        },
        previousPage: function () {
          var pageNum = pro.pb.getValue("table.currentPageNumber");
          if (pageNum !== 0) {
            pageNum--;
            pro.pb.setValue("table.currentPageNumber", pageNum);
          }
        },
        nextPage: function () {
          var pageNum = pro.pb.getValue("table.currentPageNumber");
          if (pageNum !== getTotalPages() - 1) {
            pageNum++;
            pro.pb.setValue("table.currentPageNumber", pageNum);
          }
        },
        jumpToPage: function (pageNumber) {
          if (notMaxPages(pageNumber)) {
            pro.pb.setValue("table.currentPageNumber", pageNumber);
            pro.query.subscribe(pro.onDataReady);
          }
        },
        extendData: function (data) {
          return _.extend(data, {
            totalPages: getTotalPages(),
            activePage: pro.pb.getValue("table.currentPageNumber"),
            startPage: getStartPage(),
            lastPage: getLastPage()
          });
        }
      }
    };
  };

  return TablePaginationCore;
});

define('components/tablecomponent',[
  "components/component",
  "renderers/tablerenderer",
  "prop/properties",
  "components/table/sortingcore",
  "components/table/paginationcore",
  "utils/errorutils",
  "vendor/lodash"
], function (Component, TableRenderer, Properties, TableSortingCore, TablePaginationCore, errorUtils, _) {
  /**
   * Creates a component which displays a table
   * @class TableComponent
   * @augments {Component}
   */
  function TableComponent() {
    Component.apply(this, Array.prototype.slice.call(arguments));

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    //noinspection JSUnusedGlobalSymbols
    Public = {
      /**
       * Add a row of data to the table.
       * This will need to be provided as a key-value object whose keys correspond to individual column keys
       * @method addRow
       * @param  {RowObject} rowData an key-value object containing the data to be displayed in a row.
       */
      addRow: function (rowData) {
        self.ds.pushRow(rowData);
      },

      /**
       * Adds a column definition to the table
       * @method addColumn
       * @param  {String} id      A unique id for this column which also corrresponds to the keys of row objects
       * @param  {String} name    The name of the column which is displayed in the table
       * @param  {TableColumnProperties} options Configure how the data is displayed
       */
      addColumn: function (id, name, options) {
        options = options ? options : {};
        pro.aspect.provide("addColumn");
        options.name = name;
        if(options.dataType === 'number' && !options.textAlign) {
          options.textAlign = 'right';
        }
        pro.pb.addItemToList("table.columns", id, options);
      },

      addSparkColumn: function(id, name, options) {
        options = options ? options : {};
        options.name = name;
        options.columnType = 'spark';
        options.rawHTML = true;
        pro.pb.addItemToList("table.columns", id, options);
      },

      /**
       * Sets the number of rows per page in the table
       * @method setRowsPerPage
       * @param  {Number} numRows the number of rows in a single page on the table
       */
      setRowsPerPage: function (numRows) {
        numRows = +numRows;
        if (_.isNumber(numRows) && !_.isNaN(numRows)) {
          pro.pb.setValue('table.rowsPerPage', numRows);
        } else {
          console.error('Error in `setRowsPerPage`, expected a number and found ' + numRows + '. Defaulting it to ' + pro.pb.getValue('table.rowsPerPage'));
        }
      },

      /**
       * Adds multiple rows of data to the table at once.
       * Note that the each row need to be provided as a key-value object whose keys match the column keys
       * @method addMultipleRows
       * @param  {Array} rows An array of objects
       */
      addMultipleRows: function (rows) {
        for (var i = -1; ++i < rows.length;) {
          self.ds.pushRow(rows[i]);
        }
      },

      /**
       * Clears all the rows from the table
       * @method clearRows
       */
      clearRows: function () {
        self.ds.clearRows();
      },

      cellConditionalFormat: function (id, formatRule, appliedStyle) {
        options = {};
        options.column_id = id;
        options.conditionalExpression = _.isString(formatRule) ? {"type": "valueComparator", "expression": formatRule } : formatRule;
        options.format = _.isString(appliedStyle) ? {"cellBackgroundColor" : appliedStyle} : appliedStyle;

        pro.pb.pushItemToList("table.cellConditionalFormatters", options);
      }
    };


    Protected = {
      init: function () {
        _bp.init();

          if(pro.props.data) {
            if(pro.props.data.sources) {
              if(pro.props.data.sources.tableRowDataSource) {
                if(typeof(pro.props.data.sources.tableRowDataSource.url) !== "undefined") {
                  self.ds.url = pro.props.data.sources.tableRowDataSource.url;
                }
              }
            }
          }
      },
      validate: function () {
        _bp.validate();
        pro.errMsg = pro.aspect.require({
          "addColumn": errorUtils.getError ("1004")
        });
        if(pro.errMsg.length > 0) {
          pro.showError(pro.errMsg);
        } else {
          pro.hideError();
        }
      },
      createRenderer: function () {
        pro.renderer = new TableRenderer();
        pro.onRendererCreate();
      },
      query: self.ds.createQuery(),
      renderCore: function () {
        // Sorting disabled need to enable it later
        //pro.initSortingRender();
        pro.renderer.renderCore();

        // Listen to the events from the renderer to get info whenever the page
        // number changes.

        pro.query.subscribe(pro.onDataReady);
        pro.pagination.initRender();
      },
      resizeCore: function (width, height) {
        pro.renderer.resizeCore(width, height);
      },
      addListeners: function () {
        _bp.addListeners();
        pro.pushListeners([
        ]);

        pro.pagination.addListeners();
      },
      onDataReady: function (data) {
        var rendererData = {
          data: data
        };
        rendererData = pro.pagination.extendData(data);
        pro.renderer.setTableData(rendererData);

        if(self.ds.url) {
          pro.resize();
        }
      }

    };


    /**
     * This is the actual constructor of the object
     */
    var construct = function () {
      pro.pb = new Properties.TableComponentProperties();
    };

    raw._registerClassName("TableComponent");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);
    raw.registerProtectedExtensions(TableSortingCore);
    raw.registerProtectedExtensions(TablePaginationCore);

    construct();
  }

  return TableComponent;
});

define('utils/dataformatter',[], function () {
    var formatType = function (value, type) {
        switch(type) {
            case 'string':
                return '' + value;
            case 'number':
                var iv = +value, fv = parseFloat(value);
                if(iv === fv) {
                    if(isNaN(iv)) {
                        return 0;
                    }
                    return iv;
                }
                if(isNaN(fv)) {
                    return 0;
                }
                return fv;
            case 'datetime':
                var timestamp = Date.parse(value);
                if(isNaN(timestamp)) {
                    console.error ("cannot parse date", value);
                }
                return new Date(timestamp);
        }
        return value;
    };

    var DataFormatter = {
        normalizeIndexedData: function (data, schema) {
            var res = [],
                rowLen = data.length,
                schemaKeys = _.keys(schema),
                schemaKeyLen = schemaKeys.length,
                j = 0;

            for(var i = 0; i < rowLen; i++) {
                var row = {};

                for (j = 0; j < schemaKeyLen; j ++) {
                    var key = schemaKeys[j],
                        item = schema[key],
                        value = data[i][item.index];

                    row[key] = formatType(value, item.type);
                }
                res.push (row);
            }

            return res;
        },
        cleanDictionaryData: function (data, schema) {
            var res = [],
                rowLen = data.length,
                schemaKeys = _.keys(schema),
                schemaKeyLen = schemaKeys.length,
                j = 0;

            for(var i = 0; i < rowLen; i++) {
                var row = {};

                for (j = 0; j < schemaKeyLen; j ++) {
                    var key = schemaKeys[j],
                        item = schema[key],
                        value = data[i][key];

                    row[key] = formatType(value, item.type);
                }
                res.push (row);
            }

            return res;
        },
        realignLabels: function (ol, newLabels, data, displayValues) {
            // Get a lookup table, such that given a label, you will get the corresponding
            // index in the new label
            var rLookup = {};

            for (var i = newLabels.length - 1; i >= 0; i--) {
                rLookup[newLabels[i]] = i;
            }

            var resData = [];
            var resDv = [];

            for(i = 0; i < data.length; i++) {
                var resDataRow = [];
                var resDvRow = [];

                for(var j = 0; j < ol.length; j++) {
                    var label = ol[j];
                    var dataValue = 0;
                    var dispValue = '0';

                    if(rLookup.hasOwnProperty(label)) {
                        var newIndex = rLookup[label];

                        dataValue = data[i][newIndex];
                        dispValue = displayValues[i][newIndex];
                    }
                    resDataRow.push(dataValue);
                    resDvRow.push(dispValue);
                }
                resData.push(resDataRow);
                resDv.push(resDvRow);
            }

            return {
                data: resData,
                displayValues: resDv
            };
        }
    };

    return DataFormatter;

});

define('utils/tooltip',['generated/templates'], function(JST) {
    var MIN_WIDTH = 100;
    var Tooltip = function() {
        var self = this,
            options = null,
            $core = null,
            $tooltip = null;

        self.config = function(_options) {
            options = _options;
            $core = options.core || $('body');
        };

        self.renderTo = function($core) {
            options.popupType = options.popupType || 'top';
            $tooltip = $(JST.tooltip(options));
            $core.append($tooltip);
            $tooltip.hide();
        };


        self.show = function(x, y, data) {
            x = x + (options.type === 'popup' ? window.pageXOffset : 0);
            y = y + (options.type === 'popup' ? window.pageYOffset : 0);

            var mainLabel = $tooltip.find('.rfTooltipMainLabel'),
                label = $tooltip.find('.rfTooltipLabel'),
                value = $tooltip.find('.rfTooltipValue'),
                row = $tooltip.find('.rfTooltipValueRow'),
                arrow = $tooltip.find(options.popupType === 'top' ? '.downArrow' : '.leftArrow'),
                arrowBorder = $tooltip.find(options.popupType === 'top' ? '.downArrowBorder' : '.leftArrowBorder');

            if(options.type === 'popup') {
                mainLabel.text(data.label);    
            } else {
                mainLabel.hide();
                row.removeClass('rfTooltipValueRow');
                arrow.hide();
                arrowBorder.hide();
                row.css({
                    padding: '8px 0'
                });
            }
            
            label.text(data.seriesLabels[0]);
            value.text(data.data[0]);
            removeAllChartColorClasses(label);
            if(data.color === 'auto') {
                label.css({
                    color: 'none'
                });
                label.addClass('chart-color-' + data.seriesIndex[0]);    
            } else {
                label.css({
                    color: data.color
                });
            }
            
            label.css({
                background: 'none'
            });
            $tooltip.show();
            var mainLabelWidth = mainLabel.width(),
                labelWidth = label.width(),
                valueWidth = value.width(),
                maxWidth = mainLabelWidth > (labelWidth + valueWidth) ? mainLabelWidth : labelWidth + valueWidth,
                tooltipWidth = (maxWidth > MIN_WIDTH ? maxWidth : MIN_WIDTH) + 10,
                tooltipHeight = ( options.type === 'popup' ? mainLabel.height() : 0 ) + label.height() + (options.type === 'popup' ? 22 : 14);

            $tooltip.css({
                width: tooltipWidth,
                height: tooltipHeight
            });
            var left, top; 
            if(options.popupType === 'left') {
                left = x + 8,
                top = y - tooltipHeight / 2;
            } else if(options.popupType === 'top') {
                left = x - tooltipWidth / 2,
                top = y - tooltipHeight - 10;
            }
            
            $tooltip.css({
                left: left,
                top: top 
            });
            if(options.type === 'popup') {
                if(options.popupType === 'left') {
                    arrow.css({
                        left: -8,
                        top: Math.floor(tooltipHeight/ 2 - 8)
                    });
                    arrowBorder.css({
                        left: -8,
                        top: Math.floor(tooltipHeight / 2 - 8)
                    });
                } else {
                    arrow.css({
                        left: Math.floor(tooltipWidth / 2 - 8),
                        top: tooltipHeight
                    });
                    arrowBorder.css({
                        left: Math.floor(tooltipWidth / 2 - 8),
                        top: tooltipHeight
                    });
                }
            }
        };

        self.hide = function() {
            $tooltip.hide();
        };

        self.dispose = function() {
            if($tooltip) {
                $tooltip.remove();    
            }
        };

        var removeAllChartColorClasses = function($node) {
            for(var i=-1; ++i<9;) {
                $node.removeClass('chart-color-' + i);
            }
        };
    };

    return Tooltip;
});
/*jshint -W083 */
define('renderers/chartrenderer',[
  "generated/templates",
  "renderers/componentrenderer",
  "utils/dataformatter",
  "utils/numberformatter",
  "razorcharts/core/chart",
  "utils/tooltip",
  'vendor/lodash'
], function (JST, ComponentRenderer, DataFormatter, NumberFormatter, RazorChart, Tooltip, _) {
  function ChartRenderer() {
    ComponentRenderer.call(this);

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    var chart,
        labels,
        data,
        series,
        displayValues,
        state = {},
        legendBools = {},
        firstDraw = true,
        legendVisible = true,
        firstAnimation = true,
        chartBaseColors = ["#5A9BD4", "#7AC36A", "#F15A60", "#FAA65B", "#9E67AB", "#D77FB4", "#CE7058", "#737373", "#333333"],
        numBaseColors = chartBaseColors.length,
        coreChartType = '',
        tooltip = new Tooltip(),
        axesTooltip = new Tooltip(),
        hasItemClickSubscribed = false;

    for(var i=-1; ++i<numBaseColors;) {
      var color = Raphael.color(chartBaseColors[i]);
      chartBaseColors[9 + i] = Raphael.hsl(color.h, color.s, color.l * 0.8);
      chartBaseColors[18 + i] = Raphael.hsl(color.h, color.s, color.l * 1.2);
    }
    Public = {
      setAnimation: function(b) {
        firstAnimation = b;
        if(pro.chart) {
          // pro.chart.setAnimation(b);
        }
      },
      itemClickSubscribed: function() {
        hasItemClickSubscribed = true;
      },
      setData: function (opts) {
        labels = opts.labels;
        data = opts.data;
        series = opts.series;
        displayValues = opts.displayValues;
      },
      setState: function(_state) {
        state = _state;
      },
      renderCore: function () {
        var tSeries = [], tData = [], tDisplayValues = [], i = 0;
        // Temp hack
        legendVisible = self.props.chart.showLegendFlag;
        self.$core.css({"padding" : "0px 10px"});
        var _series = [];
        if(series[0].displayType === 'pie') {
          for(i=-1; ++i<labels.length;) {
            _series[i] = {
              seriesName: labels[i],
              seriesHiddenFlag: false,
              seriesColor: chartBaseColors[i]
            };
          }
        }

        tooltip.config({
          core: self.$core,
          type: series[0].displayType === 'pie' ? 'value': 'popup',
          popupType: series[0].displayType === 'bar' ? 'left' : 'top'
        });

        axesTooltip.config({
          core: self.$core,
          type: 'value'
        });

        self.$core.html(JST.chart_base({
          displayType: series[0].displayType,
          series: series[0].displayType === 'pie' ? _series : series,
          legendVisible: legendVisible
        }));

        tooltip.renderTo($('body'));
        axesTooltip.renderTo($('body'));

        pro.$chartCore = self.$core.find('.chartCore');
        pro.$legendContainer = self.$core.find('.rfLegendContainer');
        attachLegendEventHandlers();
        for(i=0; i<series.length; i++) {
          if(!series[i].seriesHiddenFlag) {
            series[i].seriesIndex = i;
            tSeries.push(series[i]);
            tData.push(data[i]);
            tDisplayValues.push(displayValues[i]);
          }
        }

        selectAndCreateChart(labels, tData, tSeries, tDisplayValues);
        // pro.chart.renderTo(pro.$chartCore, 0, 0);
        pro.chart.renderTo(pro.$chartCore[0], 600, 600);
        firstDraw = true;
        attachItemEventHandler();
        if(state.isDrillDownable) {
          self.$header.html(JST.bread_crumb({
            drillLabelList: state.drillLabelList,
            startString: self.props.core.breadcrumbStartString
          }));
          self.$header.find('.rfBreadCrumb > ul > li:not(:last-child)').on('click', function() {
            pro.trigger('drillDownListClick', {index: +$(this).data('index')});
          });
          self.$core.find(".rc-plot-item").css({
            "cursor" : "pointer"
          });
        }
      },
      resizeCore: function (width, height) {
        var coreHeight = height;
        if(coreHeight > 0){
          coreHeight = height - ((legendVisible || !self.props.chart.showPieValues) ? pro.$legendContainer.height() : 0);
          // if(firstDraw) {
          //   pro.chart.renderTo(pro.$chartCore[0], width, coreHeight);
          // } else {
            pro.chart.resizeTo(width, coreHeight);  
          // }
        }

        if (pro.$chartCore && pro.$chartCore.find('.rc-axis')[1]) {
          var legendLeft = Math.floor(pro.$chartCore.find('.rc-axis')[1].getBBox().width);
          pro.$legendContainer.css({
            "padding-left" : legendLeft - 1
          });
        }
        firstDraw = false;
        if(coreChartType === 'pie') {
          tLegendVisible = !pro.chart.callFunction('hasLabels');
          if(tLegendVisible !== legendVisible) {
            legendVisible = tLegendVisible;
            if(!legendVisible && self.props.chart.showPieValues) {
              pro.$legendContainer.hide();
            } else {
              pro.$legendContainer.show();
            }
            
            coreHeight = height - ((legendVisible || !self.props.chart.showPieValues) ? pro.$legendContainer.height() : 0);
            // setTimeout(function() {
            //   pro.$chartCore.find('.rc-chart').remove();
            pro.chart.resizeTo(width, coreHeight);
            // }, 300);
            
          }
        }
      },
      realignData: function (originalLabels, labels, seriesData, displayValues) {
        if (!firstDraw) {
          var realigned = DataFormatter.realignLabels (originalLabels, labels, seriesData, displayValues);
          // pro.chart.updateData(originalLabels, realigned.data, realigned.displayValues);
          pro.chart.updateSeries(seriesData);
        }
      },
      dispose: function () {
        base.dispose();
        // pro.chart.dispose();
        pro.$chartCore = null;
        pro.$legendContainer = null;
        tooltip.dispose();
        axesTooltip.dispose();
      }
    };

    Protected = {
      $chartCore: null,
      $legendContainer: null,
      chart: null,
      chartModal: null
    };

    var attachLegendEventHandlers = function() {
      // Get the seriesVisibleFlag and initialize them to legend bools
      for(var i=-1; ++i<series.length;) {

        legendBools[series[i].key] = series[i].seriesHiddenFlag;
      }
      pro.$legendContainer.find('.rfLegendKey').on('click', function() {
        var key = $(this).data('key');
        if(_.filter(legendBools, function(val) {return !val;}).length <= 1 && !legendBools[key]) {
          return;
        }
        
        legendBools[key] = !legendBools[key];
        if(legendBools[key]) {
          $(this).addClass('disabled');  
        } else {
          $(this).removeClass('disabled');
        }
        pro.trigger('legendClick', {key: key, value: legendBools[key]});
      });
      pro.$legendContainer.find('.rfLegendKey').hover(function () {
        if(series[0].displayType === 'pie') {
          return;
        }
        $(this).addClass("disabled");
      },function () {
        $(this).removeClass("disabled");
      });

      pro.$legendContainer.find(".disabled").hover(function () {
        $(this).removeClass("disabled");
      },function () {
        $(this).addClass("disabled");
      });
    };

    var attachItemEventHandler = function(){
        pro.chart.on('plotItemClick', function(params) {
          self.trigger("plotItemActivate");
          pro.trigger('itemClick', params);
        });

        pro.chart.on('plotItemMouseOver', function(params) {
          pro.trigger("plotItemMouseOver", params);
        });

        pro.chart.on('plotItemMouseOut', function(params) {
          pro.trigger("plotItemMouseOut", params);
        });

        // pro.chart.on('labelActivate', function(params) {
        //   pro.trigger("labelActivate", params);
        // });

        pro.chart.on('plotItemActivate', function(params) {
          pro.trigger("plotItemActivate", params);
        });
    };

    var selectAndCreateChart = function (labels, data, series, displayValues) {
      var _series = [],
          customColors = [],
          dualY = self.props.chart.dualY,
          showLabelFlag = self.props.chart.showLabelFlag;
      coreChartType = series[0].displayType === 'pie' ? 'pie' : series[0].displayType === 'bar' ? 'bar' : 'linear';
      for(var i=-1; ++i<series.length;) {
        if(series) {
          _series[i] = {
            seriesIndex: series[i].seriesIndex,
            displayType: series[i].displayType,
            id: series[i].key,
            data: data[i],
            colors: coreChartType === 'pie' ? chartBaseColors : null,
            color: series[i].seriesColor,
            caption: series[i].seriesName,
            stacked: series[i].seriesStacked,
            yAxis: series[i].yAxis === 'primary' ? 'left' : 'right',
            format: (function(i) {
              return function(item) {
                var numberFormatter = new NumberFormatter();
                numberFormatter.setConfig(self.props.chart.series[series[i].key]);
                return numberFormatter.formatValue(item);
              };
            })(i)
          };
        }
      }

      var yConfig = self.props.chart.yaxis,
          syConfig = self.props.chart.secondaryYAxis,
          primarySeries = _.where (series, {yAxis: 'primary'}),
          secondarySeries = _.difference(series, primarySeries),
          primarySeriesConfig = primarySeries.length === 1  ? self.props.chart.series[primarySeries[0].key] : {},
          secondarySeriesConfig = secondarySeries.length === 1 ? self.props.chart.series[secondarySeries[0].key] : {};

      var yAxisFormatter = new NumberFormatter(),
          secondaryYAxisFormatter =  new NumberFormatter(),
          seriesFormatter = new NumberFormatter();

      yAxisFormatter.setConfig(NumberFormatter.pickFirstValid([
        yConfig,
        primarySeriesConfig
      ]));
      secondaryYAxisFormatter.setConfig(NumberFormatter.pickFirstValid([
        syConfig,
        secondarySeriesConfig
      ]));
    
      var yAxisFormatFunc = function(item) {
        return yAxisFormatter.formatValue(item);
      };
      var secondaryYFormatFunc= function(item) {
        return secondaryYAxisFormatter.formatValue(item);
      };

      var yAxisConfig = {
        label: self.props.chart.yaxis.axisName,
        minValue: self.props.chart.yaxis.minValue,
        maxValue: self.props.chart.yaxis.maxValue,
        numTicks: self.props.chart.yaxis.numTicks,
        axisLine: false,
        axisTick: false,
        format: coreChartType === 'linear' ? yAxisFormatFunc : null
      };
      if(dualY) {
        yAxisConfig = [
          {
            type: 'left',
            label: self.props.chart.yaxis.axisName,
            minValue: self.props.chart.yaxis.minValue,
            maxValue: self.props.chart.yaxis.maxValue,
            numTicks: self.props.chart.yaxis.numTicks,
            axisLine: false,
            axisTick: false,
            format: coreChartType === 'linear' ? yAxisFormatFunc : null    
          },
          {
            type: 'right',
            label: self.props.chart.secondaryYAxis.axisName,
            minValue: self.props.chart.secondaryYAxis.minValue,
            maxValue: self.props.chart.secondaryYAxis.maxValue,
            numTicks: self.props.chart.secondaryYAxis.numTicks,
            axisLine: false,
            axisTick: false,
            format: coreChartType === 'linear' ? secondaryYFormatFunc : null
          }
        ];
      }

      pro.chart = new RazorChart();
      pro.chart.config({
        labels: labels,
        type: coreChartType,
        grid: true,
        animateOnRender: false,
        dualAxis: dualY,
        showPieLabels: self.props.chart.showPieValues,
        stackedTotalDisplay: self.props.chart.stackedTotalDisplay,
        plotItemClasses: hasItemClickSubscribed ? 'activate' : '',
        xAxis: {
          axisLine: true,
          axisTick: false,
          format: coreChartType === 'bar' ? yAxisFormatFunc : null,
          minValue: self.props.chart.xaxis.minValue,
          maxValue: self.props.chart.xaxis.maxValue,
          numTicks: self.props.chart.xaxis.numTicks,
        },
        yAxis: yAxisConfig,
        tooltip: {
          onShow: function(x, y, data) {
            var tooltipFormatter = new NumberFormatter();
            if(coreChartType === 'pie') {
              tooltipFormatter.setConfig(self.props.chart.series[series[0].key]);
            } else {
              var seriesIndex = data.seriesIndex[0] - 1;
                //This is a quick fix to resolve error that occurs when hovering over a series and a series between the first and the last is hidden 
              if (typeof self.props.chart.series[series[seriesIndex]] !== 'undefined') {
                  tooltipFormatter.setConfig(NumberFormatter.pickFirstValid([
                    self.props.chart.series[series[seriesIndex].key],
                    self.props.chart.series[series[seriesIndex].key].yAxis !== 'primary' ? syConfig : yConfig
                  ]));
              }
            }     
            data.data[0] = tooltipFormatter.formatValue(data.data[0]);       
            tooltip.show(x, y, data);
          },
          onHide: function() {
            tooltip.hide();
          }
        },
        axesTooltip: {
          onShow: function(x, y, data) {
            axesTooltip.show(x, y, data);
          },
          onHide: function() {
            axesTooltip.hide();
          }
        },
        series: coreChartType === 'pie' ? _series[0] : _series,
        showLabelFlag: showLabelFlag,
        labelStep: self.props.chart.labelStep,
        trendline: self.props.chart.trendline
      });

    };

    raw._registerClassName("ComponentRenderer");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);
  }

  return ChartRenderer;
});

define('components/chartcomponent',[
  "components/component",
  "renderers/chartrenderer",
  "prop/properties",
  "utils/numberformatter",
  "utils/assert",
  'vendor/lodash'
], function (Component, ChartRenderer, Properties, NumberFormatter, Assert, _) {

  /**
   * Chart Component is used to create a chart component
   * @class  ChartComponent
   * @augments {Component}
   */
  function ChartComponent() {
    Component.apply(this, Array.prototype.slice.call(arguments));

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    var seriesColors = [],
        itemClickHandler,
        originalLabels = [],
        firstAnimation = true,
        isDrillDownable = false,
        drillDownSteps = [],
        drillDownList = [],
        drillLabelList = [],
        currentDrillDownStep = 0,
        chartModal = null,
        currentParams;

    Public = {
      /**
       * Adds a series to the chart. The number of data points provided using the seriesData array should be the same as the other series and the number of labels.
       * @method addSeries
       * @param  {String} id         Unique id of the series
       * @param  {String} name       The name of the series
       * @param  {Array} seriesData  The series data
       * @param  {ChartSeriesProperties} opts       A bunch of options passed to as an object
       * @example
       *
       * var c1 = new rf.ChartComponent ('c1');
       *
       * c1.addSeries ("foo", "Foo", [1, 2, -3], {
             *     numberPrefix: "~",
             *     numberSuffix: "%",
             *     seriesDisplayType: 'column'
             * });
       */
      addSeries: function (id, name, seriesData, opts) {

        // Allow for a single addSeries using just the array and options
        if(_.isArray(id)) {
          name = _.isObject(name) ? name : {};
          self.addSeries("series_0", "", id, name);
          self.setOption ("showLegendFlag", false);
          return;
        }
        opts = opts ? opts : {};
        pro.aspect.provide("series");
        Assert.isIDString(id, 'seriesId', 'error', self);
        Assert.isString(name, 'seriesName', 'warn', self);
        Assert.isArray(seriesData, 'seriesData', 'error', self);
        opts['seriesName'] = name;
        pro.pb.addItemToList('chart.series', id, opts);
        self.ds.addColumn(id, seriesData);
      },

      /**
       * Set an array of data points which will be used for the pie chart.
       * @method setPieValues
       * @param  {Array} seriesData  The data array
       * @param  {ChartSeriesProperties} opts The series options
       */
      setPieValues: function (seriesData, opts) {
        opts = opts || {};
        self.addSeries('pie0', 'Pie', seriesData, _.extend(opts, {seriesDisplayType: 'pie'}));
      },

      /**
       * updates the series data
       * @method updateSeries
       * @param  {String} id  The id of the series
       * @param  {Array} newData  The updated data array
       */
      updateSeries: function (id, newData) {
        // TODO: do we need to do some more? This seems far too little
        // for such a major function
        self.trigger("beforeComponentUpdate");
        firstAnimation = true;
        pro.renderer.setAnimation(firstAnimation);
        self.ds.addColumn(id, newData);
        pro.renderer.setAnimation(!firstAnimation);
        self.trigger("componentUpdate");
      },

      /**
       * Set the labels of the chart, which are the names on the X-Axis.
       * @method setLabels
       * @param  {Array} labelArray  An array of labels as strings
       */
      setLabels: function (labelArray) {
        pro.aspect.provide("labels");
        Assert.isArray(labelArray, 'labelArray', 'error', self);
        self.ds.addColumn('rfLabels', labelArray);
      },

      /**
       * Configure the Y-Axis of the chart.
       * @method setYAxis
       * @param  {String} name The name of the axis
       * @param  {Object} options An option array. See the guide for available options.
       */
      setYAxis: function (name, options) {
        options = options ? options : {};
        options['axisName'] = name;

        pro.pb.setObjectAtPath('chart.yaxis', options);
      },

      /**
       * Configure the X-Axis of the chart.
       * @method setXAxis
       * @param  {String} name The name of the axis
       * @param  {Object} options An option array. See the guide for available options.
       */
      setXAxis: function (name, options) {
        options = options ? options : {};
        options['axisName'] = name;

        pro.pb.setObjectAtPath('chart.xaxis', options);
      },

      /**
       * Add another Y-Axis to the chart.
       * @method addYAxis
       * @param  {String} id The unique id of this axis
       * @param  {String} name The name of the axis
       * @param  {Object} options An option array. See the guide for available options.
       */
      addYAxis: function (id, name, options) {
        options = options ? options : {};
        options['id'] = id;
        options['axisName'] = name;

        pro.pb.setObjectAtPath('chart.secondaryYAxis', options);
        pro.pb.setValue('chart.dualY', true);
      },

      /**
      * Attach a handler for the event when a chart plot item is clicked.
      *
      * @access public
      * @memberOf ChartComponent
      * @method onItemClick
      * @instance
      * @param  {Function} callback The callback function to be called
      */
      onItemClick: function (callback){
        if(pro.renderer) {
          pro.renderer.pro.bind('itemClick', callback);
          pro.renderer.itemClickSubscribed();
        }
        else {
          itemClickHandler = callback;
        }

      },

      /**
      * Clears all the data in the chart. Use this function if you want to update the
      * chart with new data and labels.
      *
      * Be sure to lock the component before 
      * @method clearChart
      */
      clearChart: function () {
        self.ds.clearRows();
        pro.pb.emptyList ("chart.series");
        pro.requestRedraw();
        pro.aspect.revoke('series');
      },
      resetBreadCrumbs: function() { 
        drillLabelList = []; 
        currentDrillDownStep = 0; 
      },
      addDrillStep: function(cb) {
        pro.isDrillDownable = true;
        drillDownSteps.push(cb);
        self.onItemClick(function(params) {
          if(drillDownSteps[currentDrillDownStep]) {
            drillDownList[currentDrillDownStep] = {
              props: pro.pb.getRootObject(),
              data: self.ds.getRawData()
            };
            params.label = self.ds.getRawData()[params.labelIndex].rfLabels;
            params.drillLabelList = _.cloneDeep(drillLabelList);
            drillLabelList[currentDrillDownStep] = params.label;
            self.lock();
            self.clearChart();
            drillDownSteps[currentDrillDownStep++](drillDownDoneCallback, params, self);
          }

        });
      },

      stacked: function() {
        pro.pb.setValue('chart.stacked', true);
      },
      setLabelStep: function (step, start) {
        pro.pb.setValue ('chart.labelStep.interval', step || null);
        pro.pb.setValue ('chart.labelStep.startIndex', start || 0);
      }
    };

    Protected = {
      isDrillDownable: false,

      totalDrills: 0,

      init: function () {
        _bp.init();
      },
      getErrorCodes: function () {
        return pro.aspect.require({
          "series": 1000,
          "labels": 1001
        });
      },
      createRenderer: function () {
        pro.renderer = new ChartRenderer();
        pro.renderer.setAnimation(firstAnimation);
        pro.renderer.pro.bind('legendClick', function(legend) {
          pro.pb.setValue('chart.series[' + legend.key + '].seriesHiddenFlag', legend.value);
        });
        if(itemClickHandler) {
          pro.renderer.itemClickSubscribed();
          pro.renderer.pro.bind('itemClick', itemClickHandler);
        }
        else {
          pro.renderer.pro.bind("itemClick", function (params) {
            currentParams = params;

            if(pro.isDrillDownable) {
              if(currentDrillDownStep < pro.totalDrills) {
                _.extend(params, { drillLabelList:  drillLabelList });
                pro.handleComponentEvent ("itemClick", params, currentDrillDownStep);
              }
            }
            else {
              pro.handleComponentEvent ("itemClick", params);
            }
          });
        }

        pro.renderer.pro.bind('labelActivate', function(params) {
          self.trigger('labelActivate', params);
        });

        pro.renderer.pro.bind('plotItemMouseOver', function(params) {
          self.trigger('plotItemMouseOver', params);
        });

        pro.renderer.pro.bind('plotItemMouseOut', function(params) {
          self.trigger('plotItemMouseOut', params);
        });

        pro.renderer.pro.bind('plotItemActivate', function(params) {
          self.trigger('plotItemActivate', params);
        });

        pro.renderer.setState({isDrillDownable: pro.isDrillDownable, drillLabelList: drillLabelList});
        pro.renderer.pro.bind('drillDownListClick', function(params) {
          self.lock();
          pro.pb.setRootObject(drillDownList[params.index].props);
          self.ds.setRawData(drillDownList[params.index].data);
          drillDownList.splice(params.index, drillDownList.length - params.index);
          drillLabelList.splice(params.index, drillLabelList.length - params.index);
          currentDrillDownStep = params.index;
          pro.requestRedraw();
          self.unlock();
        });
        pro.onRendererCreate();
      },

      query: self.ds.createQuery(),

      handleData: function (data) {
        var labels = _.pluck(data, 'rfLabels'),
            series = pro.pb.getObjectAtPath('chart.series');
        if(self.isLocked()) {
          return; // don't render a locked component
        }
        pro.renderer.setData({
          labels: labels,
          data: pro.seriesData(series, data),
          series: pro.seriesConfig(series),
          displayValues: pro.displayValues(series, data)
        });
        pro.updateChartData (data, labels, series);
      },

      updateChartData: function (data, labels, series) {
        var i = 0;

        for(var key in series) {
          if (series.hasOwnProperty(key)) {
            series[key].seriesIndex = i++;
            if(series[key].seriesHiddenFlag) {
              delete series[key];
            }
          }
        }
        originalLabels = labels;
        pro.renderer.realignData (originalLabels, labels, pro.seriesData(series, data), pro.displayValues(series, data));
      },


      seriesConfig: function (series) {

        var color = 1;

        return _.map(series, function (val, key, idx) {
          return {
            color: 'chart-color-' + color++,
            key: key,
            seriesName: val.seriesName,
            seriesHiddenFlag: val.seriesHiddenFlag,
            displayType: val.seriesDisplayType,
            seriesColor: val.seriesColor,
            seriesStacked: val.seriesStacked,
            yAxis: val.yAxis
          };
        });
      },

      seriesData: function (series, data) {
        return _.map(series, function (val, key) {
          return _.map(_.pluck (data, key), parseFloat);
        });
      },

      displayValues: function (series, data) {
        return _.map(series, function (val, key) {
          var values = _.pluck(data, key),
              formatter = new NumberFormatter();
          formatter.setConfig(val);

          return _.map(values, function (num) {
            if (num) {
              return formatter.formatValue(num);
            }
          });
        });
      },

      renderCore: function () {
        pro.query.runAndSubscribe(pro.handleData);
        pro.renderer.renderCore();
      },
      resizeCore: function (width, height) {
        pro.renderer.resizeCore(width, height);
        firstAnimation = false;
        pro.renderer.setAnimation(firstAnimation);
      },
      addListeners: function () {
        _bp.addListeners();
        pro.pushListeners([

        ]);
      },
      onApplyPatch: function() {
        firstAnimation = true;
      },
      configureRemoteDrilldown: function() {
        if(currentDrillDownStep < pro.totalDrills) {
          var propsS = _.cloneDeep(pro.pb.getRootObject());
          var dataS = _.cloneDeep(self.ds.getRawData());
          drillDownList[currentDrillDownStep] = {
            props: propsS,
            data: dataS
          };

          drillLabelList[currentDrillDownStep++] = currentParams.label;
          pro.drillCount = drillDownList.length;
        }
      },
      cobjSetOption: function (key, value) {
        if(key === "showLegendFlag") {
          pro.pb.setValue ("chart.showLegendFlag", value);
        } else if(key === "showPieValues") {
          pro.pb.setValue("chart.showPieValues", value);
        } else if(key === "showLabelFlag") {
          pro.pb.setValue("chart.showLabelFlag", value);
        } else if(key === "stackedTotalDisplay") {
          pro.pb.setValue("chart.stackedTotalDisplay", value);
        }
      }
    };

    var drillDownDoneCallback = function() {
      self.unlock();
      self.trigger("drillActivate");
    };

    /**
     * This is the actual constructor of the object
     */
    var construct = function () {
      pro.pb = new Properties.ChartComponentProperties();
    };

    var extractDefaultColors = function () {
      seriesColors = _.map([1, 2, 3, 4, 5], function (i) {
        return rf.utils.getColor('cs-' + i);
      });
    };

    raw._registerClassName("ChartComponent");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    construct();
  }

  return ChartComponent;
});

/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.calendar',[ "./kendo.core" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        support = kendo.support,
        ui = kendo.ui,
        Widget = ui.Widget,
        keys = kendo.keys,
        parse = kendo.parseDate,
        adjustDST = kendo.date.adjustDST,
        extractFormat = kendo._extractFormat,
        template = kendo.template,
        getCulture = kendo.getCulture,
        transitions = kendo.support.transitions,
        transitionOrigin = transitions ? transitions.css + "transform-origin" : "",
        cellTemplate = template('<td#=data.cssClass# role="gridcell"><a tabindex="-1" class="k-link" href="\\#" data-#=data.ns#value="#=data.dateString#">#=data.value#</a></td>', { useWithBlock: false }),
        emptyCellTemplate = template('<td role="gridcell">&nbsp;</td>', { useWithBlock: false }),
        browser = kendo.support.browser,
        isIE8 = browser.msie && browser.version < 9,
        ns = ".kendoCalendar",
        CLICK = "click" + ns,
        KEYDOWN_NS = "keydown" + ns,
        ID = "id",
        MIN = "min",
        LEFT = "left",
        SLIDE = "slideIn",
        MONTH = "month",
        CENTURY = "century",
        CHANGE = "change",
        NAVIGATE = "navigate",
        VALUE = "value",
        HOVER = "k-state-hover",
        DISABLED = "k-state-disabled",
        FOCUSED = "k-state-focused",
        OTHERMONTH = "k-other-month",
        OTHERMONTHCLASS = ' class="' + OTHERMONTH + '"',
        TODAY = "k-nav-today",
        CELLSELECTOR = "td:has(.k-link)",
        BLUR = "blur" + ns,
        FOCUS = "focus",
        FOCUS_WITH_NS = FOCUS + ns,
        MOUSEENTER = support.touch ? "touchstart" : "mouseenter",
        MOUSEENTER_WITH_NS = support.touch ? "touchstart" + ns : "mouseenter" + ns,
        MOUSELEAVE = support.touch ? "touchend" + ns + " touchmove" + ns : "mouseleave" + ns,
        MS_PER_MINUTE = 60000,
        MS_PER_DAY = 86400000,
        PREVARROW = "_prevArrow",
        NEXTARROW = "_nextArrow",
        ARIA_DISABLED = "aria-disabled",
        ARIA_SELECTED = "aria-selected",
        proxy = $.proxy,
        extend = $.extend,
        DATE = Date,
        views = {
            month: 0,
            year: 1,
            decade: 2,
            century: 3
        };

    var Calendar = Widget.extend({
        init: function(element, options) {
            var that = this, value, id;

            Widget.fn.init.call(that, element, options);

            element = that.wrapper = that.element;
            options = that.options;

            options.url = window.unescape(options.url);

            that._templates();

            that._header();

            that._footer(that.footer);

            id = element
                    .addClass("k-widget k-calendar")
                    .on(MOUSEENTER_WITH_NS + " " + MOUSELEAVE, CELLSELECTOR, mousetoggle)
                    .on(KEYDOWN_NS, "table.k-content", proxy(that._move, that))
                    .on(CLICK, CELLSELECTOR, function(e) {
                        var link = e.currentTarget.firstChild;

                        if (link.href.indexOf("#") != -1) {
                            e.preventDefault();
                        }

                        that._click($(link));
                    })
                    .on("mouseup" + ns, "table.k-content, .k-footer", function() {
                        that._focusView(that.options.focusOnNav !== false);
                    })
                    .attr(ID);

            if (id) {
                that._cellID = id + "_cell_selected";
            }

            normalize(options);
            value = parse(options.value, options.format, options.culture);

            that._index = views[options.start];
            that._current = new DATE(+restrictValue(value, options.min, options.max));

            that._addClassProxy = function() {
                that._active = true;
                that._cell.addClass(FOCUSED);
            };

            that._removeClassProxy = function() {
                that._active = false;
                that._cell.removeClass(FOCUSED);
            };

            that.value(value);

            kendo.notify(that);
        },

        options: {
            name: "Calendar",
            value: null,
            min: new DATE(1900, 0, 1),
            max: new DATE(2099, 11, 31),
            dates: [],
            url: "",
            culture: "",
            footer : "",
            format : "",
            month : {},
            start: MONTH,
            depth: MONTH,
            animation: {
                horizontal: {
                    effects: SLIDE,
                    reverse: true,
                    duration: 500,
                    divisor: 2
                },
                vertical: {
                    effects: "zoomIn",
                    duration: 400
                }
            }
        },

        events: [
            CHANGE,
            NAVIGATE
        ],

        setOptions: function(options) {
            var that = this;

            normalize(options);

            if (!options.dates[0]) {
                options.dates = that.options.dates;
            }

            Widget.fn.setOptions.call(that, options);

            that._templates();

            that._footer(that.footer);
            that._index = views[that.options.start];

            that.navigate();
        },

        destroy: function() {
            var that = this,
                today = that._today;

            that.element.off(ns);
            that._title.off(ns);
            that[PREVARROW].off(ns);
            that[NEXTARROW].off(ns);

            kendo.destroy(that._table);

            if (today) {
                kendo.destroy(today.off(ns));
            }

            Widget.fn.destroy.call(that);
        },

        current: function() {
            return this._current;
        },

        view: function() {
            return this._view;
        },

        focus: function(table) {
            table = table || this._table;
            this._bindTable(table);
            table.focus();
        },

        min: function(value) {
            return this._option(MIN, value);
        },

        max: function(value) {
            return this._option("max", value);
        },

        navigateToPast: function() {
            this._navigate(PREVARROW, -1);
        },

        navigateToFuture: function() {
            this._navigate(NEXTARROW, 1);
        },

        navigateUp: function() {
            var that = this,
                index = that._index;

            if (that._title.hasClass(DISABLED)) {
                return;
            }

            that.navigate(that._current, ++index);
        },

        navigateDown: function(value) {
            var that = this,
            index = that._index,
            depth = that.options.depth;

            if (!value) {
                return;
            }

            if (index === views[depth]) {
                if (+that._value != +value) {
                    that.value(value);
                    that.trigger(CHANGE);
                }
                return;
            }

            that.navigate(value, --index);
        },

        navigate: function(value, view) {
            view = isNaN(view) ? views[view] : view;

            var that = this,
                options = that.options,
                culture = options.culture,
                min = options.min,
                max = options.max,
                title = that._title,
                from = that._table,
                old = that._oldTable,
                selectedValue = that._value,
                currentValue = that._current,
                future = value && +value > +currentValue,
                vertical = view !== undefined && view !== that._index,
                to, currentView, compare,
                disabled;

            if (!value) {
                value = currentValue;
            }

            that._current = value = new DATE(+restrictValue(value, min, max));

            if (view === undefined) {
                view = that._index;
            } else {
                that._index = view;
            }

            that._view = currentView = calendar.views[view];
            compare = currentView.compare;

            disabled = view === views[CENTURY];
            title.toggleClass(DISABLED, disabled).attr(ARIA_DISABLED, disabled);

            disabled = compare(value, min) < 1;
            that[PREVARROW].toggleClass(DISABLED, disabled).attr(ARIA_DISABLED, disabled);

            disabled = compare(value, max) > -1;
            that[NEXTARROW].toggleClass(DISABLED, disabled).attr(ARIA_DISABLED, disabled);

            if (from && old && old.data("animating")) {
                old.kendoStop(true, true);
                from.kendoStop(true, true);
            }

            that._oldTable = from;

            if (!from || that._changeView) {
                title.html(currentView.title(value, min, max, culture));

                that._table = to = $(currentView.content(extend({
                    min: min,
                    max: max,
                    date: value,
                    url: options.url,
                    dates: options.dates,
                    format: options.format,
                    culture: culture
                }, that[currentView.name])));

                makeUnselectable(to);

                that._animate({
                    from: from,
                    to: to,
                    vertical: vertical,
                    future: future
                });

                that._focus(value);
                that.trigger(NAVIGATE);
            }

            if (view === views[options.depth] && selectedValue) {
                that._class("k-state-selected", currentView.toDateString(selectedValue));
            }

            that._class(FOCUSED, currentView.toDateString(value));

            if (!from && that._cell) {
                that._cell.removeClass(FOCUSED);
            }

            that._changeView = true;
        },

        value: function(value) {
            var that = this,
            view = that._view,
            options = that.options,
            old = that._view,
            min = options.min,
            max = options.max;

            if (value === undefined) {
                return that._value;
            }

            value = parse(value, options.format, options.culture);

            if (value !== null) {
                value = new DATE(+value);

                if (!isInRange(value, min, max)) {
                    value = null;
                }
            }

            that._value = value;

            if (old && value === null && that._cell) {
                that._cell.removeClass("k-state-selected");
            } else {
                that._changeView = !value || view && view.compare(value, that._current) !== 0;
                that.navigate(value);
            }
        },

        _move: function(e) {
            var that = this,
                options = that.options,
                key = e.keyCode,
                view = that._view,
                index = that._index,
                currentValue = new DATE(+that._current),
                isRtl = kendo.support.isRtl(that.wrapper),
                value, prevent, method, temp;

            if (e.target === that._table[0]) {
                that._active = true;
            }

            if (e.ctrlKey) {
                if (key == keys.RIGHT && !isRtl || key == keys.LEFT && isRtl) {
                    that.navigateToFuture();
                    prevent = true;
                } else if (key == keys.LEFT && !isRtl || key == keys.RIGHT && isRtl) {
                    that.navigateToPast();
                    prevent = true;
                } else if (key == keys.UP) {
                    that.navigateUp();
                    prevent = true;
                } else if (key == keys.DOWN) {
                    that._click($(that._cell[0].firstChild));
                    prevent = true;
                }
            } else {
                if (key == keys.RIGHT && !isRtl || key == keys.LEFT && isRtl) {
                    value = 1;
                    prevent = true;
                } else if (key == keys.LEFT && !isRtl || key == keys.RIGHT && isRtl) {
                    value = -1;
                    prevent = true;
                } else if (key == keys.UP) {
                    value = index === 0 ? -7 : -4;
                    prevent = true;
                } else if (key == keys.DOWN) {
                    value = index === 0 ? 7 : 4;
                    prevent = true;
                } else if (key == keys.ENTER) {
                    that._click($(that._cell[0].firstChild));
                    prevent = true;
                } else if (key == keys.HOME || key == keys.END) {
                    method = key == keys.HOME ? "first" : "last";
                    temp = view[method](currentValue);
                    currentValue = new DATE(temp.getFullYear(), temp.getMonth(), temp.getDate(), currentValue.getHours(), currentValue.getMinutes(), currentValue.getSeconds(), currentValue.getMilliseconds());
                    prevent = true;
                } else if (key == keys.PAGEUP) {
                    prevent = true;
                    that.navigateToPast();
                } else if (key == keys.PAGEDOWN) {
                    prevent = true;
                    that.navigateToFuture();
                }

                if (value || method) {
                    if (!method) {
                        view.setDate(currentValue, value);
                    }

                    that._focus(restrictValue(currentValue, options.min, options.max));
                }
            }

            if (prevent) {
                e.preventDefault();
            }

            return that._current;
        },

        _animate: function(options) {
            var that = this,
                from = options.from,
                to = options.to,
                active = that._active;

            if (!from) {
                to.insertAfter(that.element[0].firstChild);
                that._bindTable(to);
            } else if (from.parent().data("animating")) {
                from.parent().kendoStop(true, true).remove();
                from.remove();

                to.insertAfter(that.element[0].firstChild);
                that._focusView(active);
            } else if (!from.is(":visible") || that.options.animation === false) {
                to.insertAfter(from);
                from.remove();

                that._focusView(active);
            } else {
                that[options.vertical ? "_vertical" : "_horizontal"](from, to, options.future);
            }
        },

        _horizontal: function(from, to, future) {
            var that = this,
                active = that._active,
                horizontal = that.options.animation.horizontal,
                effects = horizontal.effects,
                viewWidth = from.outerWidth();

            if (effects && effects.indexOf(SLIDE) != -1) {
                from.add(to).css({ width: viewWidth });

                from.wrap("<div/>");

                that._focusView(active, from);

                from.parent()
                    .css({
                        position: "relative",
                        width: viewWidth * 2,
                        "float": LEFT,
                        "margin-left": future ? 0 : -viewWidth
                    });

                to[future ? "insertAfter" : "insertBefore"](from);

                extend(horizontal, {
                    effects: SLIDE + ":" + (future ? "right" : LEFT),
                    complete: function() {
                        from.remove();
                        to.unwrap();

                        that._focusView(active);

                        that._oldTable = undefined;
                    }
                });

                from.parent().kendoStop(true, true).kendoAnimate(horizontal);
            }
        },

        _vertical: function(from, to) {
            var that = this,
                vertical = that.options.animation.vertical,
                effects = vertical.effects,
                active = that._active, //active state before from's blur
                cell, position;

            if (effects && effects.indexOf("zoom") != -1) {
                to.css({
                    position: "absolute",
                    top: from.prev().outerHeight(),
                    left: 0
                }).insertBefore(from);

                if (transitionOrigin) {
                    cell = that._cellByDate(that._view.toDateString(that._current));
                    position = cell.position();
                    position = (position.left + parseInt(cell.width() / 2, 10)) + "px" + " " + (position.top + parseInt(cell.height() / 2, 10) + "px");
                    to.css(transitionOrigin, position);
                }

                from.kendoStop(true, true).kendoAnimate({
                    effects: "fadeOut",
                    duration: 600,
                    complete: function() {
                        from.remove();

                        to.css({
                            position: "static",
                            top: 0,
                            left: 0
                        });

                        that._focusView(active);

                        that._oldTable = undefined;
                    }
                });

                to.kendoStop(true, true).kendoAnimate(vertical);
            }
        },

        _cellByDate: function(value) {
            return this._table.find("td:not(." + OTHERMONTH + ")")
                       .filter(function() {
                           return $(this.firstChild).attr(kendo.attr(VALUE)) === value;
                       });
        },

        _class: function(className, value) {
            var that = this,
                id = that._cellID,
                cell = that._cell;

            if (cell) {
                cell.removeAttr(ARIA_SELECTED)
                    .removeAttr("aria-label")
                    .removeAttr(ID);
            }

            cell = that._table
                       .find("td:not(." + OTHERMONTH + ")")
                       .removeClass(className)
                       .filter(function() {
                          return $(this.firstChild).attr(kendo.attr(VALUE)) === value;
                       })
                       .attr(ARIA_SELECTED, true);

            if (className === FOCUSED && !that._active && that.options.focusOnNav !== false) {
                className = "";
            }

            cell.addClass(className);

            if (cell[0]) {
                that._cell = cell;
            }

            if (id) {
                cell.attr(ID, id);
                that._table.removeAttr("aria-activedescendant").attr("aria-activedescendant", id);
            }
        },

        _bindTable: function (table) {
            table
                .on(FOCUS_WITH_NS, this._addClassProxy)
                .on(BLUR, this._removeClassProxy);
        },

        _click: function(link) {
            var that = this,
                options = that.options,
                currentValue = new Date(+that._current),
                value = link.attr(kendo.attr(VALUE)).split("/");

            //Safari cannot create correctly date from "1/1/2090"
            value = new DATE(value[0], value[1], value[2]);
            adjustDST(value, 0);

            that._view.setDate(currentValue, value);

            that.navigateDown(restrictValue(currentValue, options.min, options.max));
        },

        _focus: function(value) {
            var that = this,
                view = that._view;

            if (view.compare(value, that._current) !== 0) {
                that.navigate(value);
            } else {
                that._current = value;
                that._class(FOCUSED, view.toDateString(value));
            }
        },

        _focusView: function(active, table) {
            if (active) {
                this.focus(table);
            }
        },

        _footer: function(template) {
            var that = this,
                today = getToday(),
                element = that.element,
                footer = element.find(".k-footer");

            if (!template) {
                that._toggle(false);
                footer.hide();
                return;
            }

            if (!footer[0]) {
                footer = $('<div class="k-footer"><a href="#" class="k-link k-nav-today"></a></div>').appendTo(element);
            }

            that._today = footer.show()
                                .find(".k-link")
                                .html(template(today))
                                .attr("title", kendo.toString(today, "D", that.options.culture));

            that._toggle();
        },

        _header: function() {
            var that = this,
            element = that.element,
            links;

            if (!element.find(".k-header")[0]) {
                element.html('<div class="k-header">' +
                             '<a href="#" role="button" class="k-link k-nav-prev"><span class="k-icon k-i-arrow-w"></span></a>' +
                             '<a href="#" role="button" aria-live="assertive" aria-atomic="true" class="k-link k-nav-fast"></a>' +
                             '<a href="#" role="button" class="k-link k-nav-next"><span class="k-icon k-i-arrow-e"></span></a>' +
                             '</div>');
            }

            links = element.find(".k-link")
                           .on(MOUSEENTER_WITH_NS + " " + MOUSELEAVE + " " + FOCUS_WITH_NS + " " + BLUR, mousetoggle)
                           .click(false);

            that._title = links.eq(1).on(CLICK, function() { that._focusView(that.options.focusOnNav !== false); that.navigateUp(); });
            that[PREVARROW] = links.eq(0).on(CLICK, function() { that._focusView(that.options.focusOnNav !== false); that.navigateToPast(); });
            that[NEXTARROW] = links.eq(2).on(CLICK, function() { that._focusView(that.options.focusOnNav !== false); that.navigateToFuture(); });
        },

        _navigate: function(arrow, modifier) {
            var that = this,
                index = that._index + 1,
                currentValue = new DATE(+that._current);

            arrow = that[arrow];

            if (!arrow.hasClass(DISABLED)) {
                if (index > 3) {
                    currentValue.setFullYear(currentValue.getFullYear() + 100 * modifier);
                } else {
                    calendar.views[index].setDate(currentValue, modifier);
                }

                that.navigate(currentValue);
            }
        },

        _option: function(option, value) {
            var that = this,
                options = that.options,
                currentValue = that._value || that._current,
                isBigger;

            if (value === undefined) {
                return options[option];
            }

            value = parse(value, options.format, options.culture);

            if (!value) {
                return;
            }

            options[option] = new DATE(+value);

            if (option === MIN) {
                isBigger = value > currentValue;
            } else {
                isBigger = currentValue > value;
            }

            if (isBigger || isEqualMonth(currentValue, value)) {
                if (isBigger) {
                    that._value = null;
                }
                that._changeView = true;
            }

            if (!that._changeView) {
                that._changeView = !!(options.month.content || options.month.empty);
            }

            that.navigate(that._value);

            that._toggle();
        },

        _toggle: function(toggle) {
            var that = this,
                options = that.options,
                link = that._today;

            if (toggle === undefined) {
                toggle = isInRange(getToday(), options.min, options.max);
            }

            if (link) {
                link.off(CLICK);

                if (toggle) {
                    link.addClass(TODAY)
                        .removeClass(DISABLED)
                        .on(CLICK, proxy(that._todayClick, that));
                } else {
                    link.removeClass(TODAY)
                        .addClass(DISABLED)
                        .on(CLICK, prevent);
                }
            }
        },

        _todayClick: function(e) {
            var that = this,
                depth = views[that.options.depth],
                today = getToday();

            e.preventDefault();

            if (that._view.compare(that._current, today) === 0 && that._index == depth) {
                that._changeView = false;
            }

            that._value = today;
            that.navigate(today, depth);

            that.trigger(CHANGE);
        },

        _templates: function() {
            var that = this,
                options = that.options,
                footer = options.footer,
                month = options.month,
                content = month.content,
                empty = month.empty;

            that.month = {
                content: template('<td#=data.cssClass# role="gridcell"><a tabindex="-1" class="k-link#=data.linkClass#" href="#=data.url#" ' + kendo.attr("value") + '="#=data.dateString#" title="#=data.title#">' + (content || "#=data.value#") + '</a></td>', { useWithBlock: !!content }),
                empty: template('<td role="gridcell">' + (empty || "&nbsp;") + "</td>", { useWithBlock: !!empty })
            };

            that.footer = footer !== false ? template(footer || '#= kendo.toString(data,"D","' + options.culture +'") #', { useWithBlock: false }) : null;
        }
    });

    ui.plugin(Calendar);

    var calendar = {
        firstDayOfMonth: function (date) {
            return new DATE(
                date.getFullYear(),
                date.getMonth(),
                1
            );
        },

        firstVisibleDay: function (date, calendarInfo) {
            calendarInfo = calendarInfo || kendo.culture().calendar;

            var firstDay = calendarInfo.firstDay,
            firstVisibleDay = new DATE(date.getFullYear(), date.getMonth(), 0, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());

            while (firstVisibleDay.getDay() != firstDay) {
                calendar.setTime(firstVisibleDay, -1 * MS_PER_DAY);
            }

            return firstVisibleDay;
        },

        setTime: function (date, time) {
            var tzOffsetBefore = date.getTimezoneOffset(),
            resultDATE = new DATE(date.getTime() + time),
            tzOffsetDiff = resultDATE.getTimezoneOffset() - tzOffsetBefore;

            date.setTime(resultDATE.getTime() + tzOffsetDiff * MS_PER_MINUTE);
        },
        views: [{
            name: MONTH,
            title: function(date, min, max, culture) {
                return getCalendarInfo(culture).months.names[date.getMonth()] + " " + date.getFullYear();
            },
            content: function(options) {
                var that = this,
                idx = 0,
                min = options.min,
                max = options.max,
                date = options.date,
                dates = options.dates,
                format = options.format,
                culture = options.culture,
                navigateUrl = options.url,
                hasUrl = navigateUrl && dates[0],
                currentCalendar = getCalendarInfo(culture),
                firstDayIdx = currentCalendar.firstDay,
                days = currentCalendar.days,
                names = shiftArray(days.names, firstDayIdx),
                shortNames = shiftArray(days.namesShort, firstDayIdx),
                start = calendar.firstVisibleDay(date, currentCalendar),
                firstDayOfMonth = that.first(date),
                lastDayOfMonth = that.last(date),
                toDateString = that.toDateString,
                today = new DATE(),
                html = '<table tabindex="0" role="grid" class="k-content" cellspacing="0"><thead><tr role="row">';

                for (; idx < 7; idx++) {
                    html += '<th scope="col" title="' + names[idx] + '">' + shortNames[idx] + '</th>';
                }

                today = new DATE(today.getFullYear(), today.getMonth(), today.getDate());
                adjustDST(today, 0);
                today = +today;

                return view({
                    cells: 42,
                    perRow: 7,
                    html: html += '</tr></thead><tbody><tr role="row">',
                    start: new DATE(start.getFullYear(), start.getMonth(), start.getDate()),
                    min: new DATE(min.getFullYear(), min.getMonth(), min.getDate()),
                    max: new DATE(max.getFullYear(), max.getMonth(), max.getDate()),
                    content: options.content,
                    empty: options.empty,
                    setter: that.setDate,
                    build: function(date) {
                        var cssClass = [],
                            day = date.getDay(),
                            linkClass = "",
                            url = "#";

                        if (date < firstDayOfMonth || date > lastDayOfMonth) {
                            cssClass.push(OTHERMONTH);
                        }

                        if (+date === today) {
                            cssClass.push("k-today");
                        }

                        if (day === 0 || day === 6) {
                            cssClass.push("k-weekend");
                        }

                        if (hasUrl && inArray(+date, dates)) {
                            url = navigateUrl.replace("{0}", kendo.toString(date, format, culture));
                            linkClass = " k-action-link";
                        }

                        return {
                            date: date,
                            dates: dates,
                            ns: kendo.ns,
                            title: kendo.toString(date, "D", culture),
                            value: date.getDate(),
                            dateString: toDateString(date),
                            cssClass: cssClass[0] ? ' class="' + cssClass.join(" ") + '"' : "",
                            linkClass: linkClass,
                            url: url
                        };
                    }
                });
            },
            first: function(date) {
                return calendar.firstDayOfMonth(date);
            },
            last: function(date) {
                var last = new DATE(date.getFullYear(), date.getMonth() + 1, 0),
                    first = calendar.firstDayOfMonth(date),
                    timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());

                if (timeOffset) {
                    last.setHours(first.getHours() + (timeOffset / 60));
                }

                return last;
            },
            compare: function(date1, date2) {
                var result,
                month1 = date1.getMonth(),
                year1 = date1.getFullYear(),
                month2 = date2.getMonth(),
                year2 = date2.getFullYear();

                if (year1 > year2) {
                    result = 1;
                } else if (year1 < year2) {
                    result = -1;
                } else {
                    result = month1 == month2 ? 0 : month1 > month2 ? 1 : -1;
                }

                return result;
            },
            setDate: function(date, value) {
                var hours = date.getHours();
                if (value instanceof DATE) {
                    date.setFullYear(value.getFullYear(), value.getMonth(), value.getDate());
                } else {
                    calendar.setTime(date, value * MS_PER_DAY);
                }
                adjustDST(date, hours);
            },
            toDateString: function(date) {
                return date.getFullYear() + "/" + date.getMonth() + "/" + date.getDate();
            }
        },
        {
            name: "year",
            title: function(date) {
                return date.getFullYear();
            },
            content: function(options) {
                var namesAbbr = getCalendarInfo(options.culture).months.namesAbbr,
                toDateString = this.toDateString,
                min = options.min,
                max = options.max;

                return view({
                    min: new DATE(min.getFullYear(), min.getMonth(), 1),
                    max: new DATE(max.getFullYear(), max.getMonth(), 1),
                    start: new DATE(options.date.getFullYear(), 0, 1),
                    setter: this.setDate,
                    build: function(date) {
                        return {
                            value: namesAbbr[date.getMonth()],
                            ns: kendo.ns,
                            dateString: toDateString(date),
                            cssClass: ""
                        };
                    }
                });
            },
            first: function(date) {
                return new DATE(date.getFullYear(), 0, date.getDate());
            },
            last: function(date) {
                return new DATE(date.getFullYear(), 11, date.getDate());
            },
            compare: function(date1, date2){
                return compare(date1, date2);
            },
            setDate: function(date, value) {
                var month,
                    hours = date.getHours();

                if (value instanceof DATE) {
                    month = value.getMonth();

                    date.setFullYear(value.getFullYear(), month, date.getDate());

                    if (month !== date.getMonth()) {
                        date.setDate(0);
                    }
                } else {
                    month = date.getMonth() + value;

                    date.setMonth(month);

                    if (month > 11) {
                        month -= 12;
                    }

                    if (month > 0 && date.getMonth() != month) {
                        date.setDate(0);
                    }
                }

                adjustDST(date, hours);
            },
            toDateString: function(date) {
                return date.getFullYear() + "/" + date.getMonth() + "/1";
            }
        },
        {
            name: "decade",
            title: function(date, min, max) {
                return title(date, min, max, 10);
            },
            content: function(options) {
                var year = options.date.getFullYear(),
                toDateString = this.toDateString;

                return view({
                    start: new DATE(year - year % 10 - 1, 0, 1),
                    min: new DATE(options.min.getFullYear(), 0, 1),
                    max: new DATE(options.max.getFullYear(), 0, 1),
                    setter: this.setDate,
                    build: function(date, idx) {
                        return {
                            value: date.getFullYear(),
                            ns: kendo.ns,
                            dateString: toDateString(date),
                            cssClass: idx === 0 || idx == 11 ? OTHERMONTHCLASS : ""
                        };
                    }
                });
            },
            first: function(date) {
                var year = date.getFullYear();
                return new DATE(year - year % 10, date.getMonth(), date.getDate());
            },
            last: function(date) {
                var year = date.getFullYear();
                return new DATE(year - year % 10 + 9, date.getMonth(), date.getDate());
            },
            compare: function(date1, date2) {
                return compare(date1, date2, 10);
            },
            setDate: function(date, value) {
                setDate(date, value, 1);
            },
            toDateString: function(date) {
                return date.getFullYear() + "/0/1";
            }
        },
        {
            name: CENTURY,
            title: function(date, min, max) {
                return title(date, min, max, 100);
            },
            content: function(options) {
                var year = options.date.getFullYear(),
                min = options.min.getFullYear(),
                max = options.max.getFullYear(),
                toDateString = this.toDateString,
                minYear = min,
                maxYear = max;

                minYear = minYear - minYear % 10;
                maxYear = maxYear - maxYear % 10;

                if (maxYear - minYear < 10) {
                    maxYear = minYear + 9;
                }

                return view({
                    start: new DATE(year - year % 100 - 10, 0, 1),
                    min: new DATE(minYear, 0, 1),
                    max: new DATE(maxYear, 0, 1),
                    setter: this.setDate,
                    build: function(date, idx) {
                        var start = date.getFullYear(),
                            end = start + 9;

                        if (start < min) {
                            start = min;
                        }

                        if (end > max) {
                            end = max;
                        }

                        return {
                            ns: kendo.ns,
                            value: start + " - " + end,
                            dateString: toDateString(date),
                            cssClass: idx === 0 || idx == 11 ? OTHERMONTHCLASS : ""
                        };
                    }
                });
            },
            first: function(date) {
                var year = date.getFullYear();
                return new DATE(year - year % 100, date.getMonth(), date.getDate());
            },
            last: function(date) {
                var year = date.getFullYear();
                return new DATE(year - year % 100 + 99, date.getMonth(), date.getDate());
            },
            compare: function(date1, date2) {
                return compare(date1, date2, 100);
            },
            setDate: function(date, value) {
                setDate(date, value, 10);
            },
            toDateString: function(date) {
                var year = date.getFullYear();
                return (year - year % 10) + "/0/1";
            }
        }]
    };

    function title(date, min, max, modular) {
        var start = date.getFullYear(),
            minYear = min.getFullYear(),
            maxYear = max.getFullYear(),
            end;

        start = start - start % modular;
        end = start + (modular - 1);

        if (start < minYear) {
            start = minYear;
        }
        if (end > maxYear) {
            end = maxYear;
        }

        return start + "-" + end;
    }

    function view(options) {
        var idx = 0,
            data,
            min = options.min,
            max = options.max,
            start = options.start,
            setter = options.setter,
            build = options.build,
            length = options.cells || 12,
            cellsPerRow = options.perRow || 4,
            content = options.content || cellTemplate,
            empty = options.empty || emptyCellTemplate,
            html = options.html || '<table tabindex="0" role="grid" class="k-content k-meta-view" cellspacing="0"><tbody><tr role="row">';

        for(; idx < length; idx++) {
            if (idx > 0 && idx % cellsPerRow === 0) {
                html += '</tr><tr role="row">';
            }

            data = build(start, idx);

            html += isInRange(start, min, max) ? content(data) : empty(data);

            setter(start, 1);
        }

        return html + "</tr></tbody></table>";
    }

    function compare(date1, date2, modifier) {
        var year1 = date1.getFullYear(),
            start  = date2.getFullYear(),
            end = start,
            result = 0;

        if (modifier) {
            start = start - start % modifier;
            end = start - start % modifier + modifier - 1;
        }

        if (year1 > end) {
            result = 1;
        } else if (year1 < start) {
            result = -1;
        }

        return result;
    }

    function getToday() {
        var today = new DATE();
        return new DATE(today.getFullYear(), today.getMonth(), today.getDate());
    }

    function restrictValue (value, min, max) {
        var today = getToday();

        if (value) {
            today = new DATE(+value);
        }

        if (min > today) {
            today = new DATE(+min);
        } else if (max < today) {
            today = new DATE(+max);
        }
        return today;
    }

    function isInRange(date, min, max) {
        return +date >= +min && +date <= +max;
    }

    function shiftArray(array, idx) {
        return array.slice(idx).concat(array.slice(0, idx));
    }

    function setDate(date, value, multiplier) {
        value = value instanceof DATE ? value.getFullYear() : date.getFullYear() + multiplier * value;
        date.setFullYear(value);
    }

    function mousetoggle(e) {
        $(this).toggleClass(HOVER, MOUSEENTER.indexOf(e.type) > -1 || e.type == FOCUS);
    }

    function prevent (e) {
        e.preventDefault();
    }

    function getCalendarInfo(culture) {
        return getCulture(culture).calendars.standard;
    }

    function normalize(options) {
        var start = views[options.start],
            depth = views[options.depth],
            culture = getCulture(options.culture);

        options.format = extractFormat(options.format || culture.calendars.standard.patterns.d);

        if (isNaN(start)) {
            start = 0;
            options.start = MONTH;
        }

        if (depth === undefined || depth > start) {
            options.depth = MONTH;
        }

        if (!options.dates) {
            options.dates = [];
        }
    }

    function makeUnselectable(element) {
        if (isIE8) {
            element.find("*").attr("unselectable", "on");
        }
    }

    function inArray(date, dates) {
        for(var i = 0, length = dates.length; i < length; i++) {
            if (date === +dates[i]) {
                return true;
            }
        }
        return false;
    }

    function isEqualDatePart(value1, value2) {
        if (value1) {
            return value1.getFullYear() === value2.getFullYear() &&
                   value1.getMonth() === value2.getMonth() &&
                   value1.getDate() === value2.getDate();
        }

        return false;
    }

    function isEqualMonth(value1, value2) {
        if (value1) {
            return value1.getFullYear() === value2.getFullYear() &&
                   value1.getMonth() === value2.getMonth();
        }

        return false;
    }

    calendar.isEqualDatePart = isEqualDatePart;
    calendar.makeUnselectable =  makeUnselectable;
    calendar.restrictValue = restrictValue;
    calendar.isInRange = isInRange;
    calendar.normalize = normalize;
    calendar.viewsEnum = views;

    kendo.calendar = calendar;
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.datepicker',[ "./kendo.calendar", "./kendo.popup" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
    ui = kendo.ui,
    Widget = ui.Widget,
    parse = kendo.parseDate,
    keys = kendo.keys,
    template = kendo.template,
    activeElement = kendo._activeElement,
    DIV = "<div />",
    SPAN = "<span />",
    ns = ".kendoDatePicker",
    CLICK = "click" + ns,
    OPEN = "open",
    CLOSE = "close",
    CHANGE = "change",
    DATEVIEW = "dateView",
    DISABLED = "disabled",
    READONLY = "readonly",
    DEFAULT = "k-state-default",
    FOCUSED = "k-state-focused",
    SELECTED = "k-state-selected",
    STATEDISABLED = "k-state-disabled",
    HOVER = "k-state-hover",
    KEYDOWN = "keydown" + ns,
    HOVEREVENTS = "mouseenter" + ns + " mouseleave" + ns,
    MOUSEDOWN = "mousedown" + ns,
    ID = "id",
    MIN = "min",
    MAX = "max",
    MONTH = "month",
    ARIA_DISABLED = "aria-disabled",
    ARIA_EXPANDED = "aria-expanded",
    ARIA_HIDDEN = "aria-hidden",
    ARIA_READONLY = "aria-readonly",
    calendar = kendo.calendar,
    isInRange = calendar.isInRange,
    restrictValue = calendar.restrictValue,
    isEqualDatePart = calendar.isEqualDatePart,
    extend = $.extend,
    proxy = $.proxy,
    DATE = Date;

    function normalize(options) {
        var parseFormats = options.parseFormats,
            format = options.format;

        calendar.normalize(options);

        parseFormats = $.isArray(parseFormats) ? parseFormats : [parseFormats];
        if ($.inArray(format, parseFormats) === -1) {
            parseFormats.splice(0, 0, options.format);
        }

        options.parseFormats = parseFormats;
    }

    function preventDefault(e) {
        e.preventDefault();
    }

    var DateView = function(options) {
        var that = this, id,
            body = document.body,
            div = $(DIV).attr(ARIA_HIDDEN, "true")
                        .addClass("k-calendar-container")
                        .appendTo(body);

        that.options = options = options || {};
        id = options.id;

        if (id) {
            id += "_dateview";

            div.attr(ID, id);
            that._dateViewID = id;
        }

        that.popup = new ui.Popup(div, extend(options.popup, options, { name: "Popup", isRtl: kendo.support.isRtl(options.anchor) }));
        that.div = div;

        that.value(options.value);
    };

    DateView.prototype = {
        _calendar: function() {
            var that = this;
            var calendar = that.calendar;
            var options = that.options;
            var div;

            if (!calendar) {
                div = $(DIV).attr(ID, kendo.guid())
                            .appendTo(that.popup.element)
                            .on(MOUSEDOWN, preventDefault)
                            .on(CLICK, "td:has(.k-link)", proxy(that._click, that));

                that.calendar = calendar = new ui.Calendar(div);
                that._setOptions(options);

                kendo.calendar.makeUnselectable(calendar.element);

                calendar.navigate(that._value || that._current, options.start);

                that.value(that._value);
            }
        },

        _setOptions: function(options) {
            this.calendar.setOptions({
                focusOnNav: false,
                change: options.change,
                culture: options.culture,
                dates: options.dates,
                depth: options.depth,
                footer: options.footer,
                format: options.format,
                max: options.max,
                min: options.min,
                month: options.month,
                start: options.start
            });
        },

        setOptions: function(options) {
            var old = this.options;

            this.options = extend(old, options, {
                change: old.change,
                close: old.close,
                open: old.open
            });

            if (this.calendar) {
                this._setOptions(this.options);
            }
        },

        destroy: function() {
            this.popup.destroy();
        },

        open: function() {
            var that = this;

            that._calendar();
            that.popup.open();
        },

        close: function() {
            this.popup.close();
        },

        min: function(value) {
            this._option(MIN, value);
        },

        max: function(value) {
            this._option(MAX, value);
        },

        toggle: function() {
            var that = this;

            that[that.popup.visible() ? CLOSE : OPEN]();
        },

        move: function(e) {
            var that = this,
                key = e.keyCode,
                calendar = that.calendar,
                selectIsClicked = e.ctrlKey && key == keys.DOWN || key == keys.ENTER;

            if (key == keys.ESC) {
                that.close();
                return;
            }

            if (e.altKey) {
                if (key == keys.DOWN) {
                    that.open();
                    e.preventDefault();
                } else if (key == keys.UP) {
                    that.close();
                    e.preventDefault();
                }
                return;
            }

            if (!that.popup.visible()){
                return;
            }

            if (selectIsClicked && calendar._cell.hasClass(SELECTED)) {
                that.close();
                e.preventDefault();
                return;
            }

            that._current = calendar._move(e);
        },

        current: function(date) {
            this._current = date;
            this.calendar._focus(date);
        },

        value: function(value) {
            var that = this,
                calendar = that.calendar,
                options = that.options;

            that._value = value;
            that._current = new DATE(+restrictValue(value, options.min, options.max));

            if (calendar) {
                calendar.value(value);
            }
        },

        _click: function(e) {
            if (e.currentTarget.className.indexOf(SELECTED) !== -1) {
                this.close();
            }
        },

        _option: function(option, value) {
            var that = this;
            var calendar = that.calendar;

            that.options[option] = value;

            if (calendar) {
                calendar[option](value);
            }
        }
    };

    DateView.normalize = normalize;

    kendo.DateView = DateView;

    var DatePicker = Widget.extend({
        init: function(element, options) {
            var that = this,
                disabled,
                div;

            Widget.fn.init.call(that, element, options);
            element = that.element;
            options = that.options;

            options.min = parse(element.attr("min")) || parse(options.min);
            options.max = parse(element.attr("max")) || parse(options.max);

            normalize(options);

            that._wrapper();

            that.dateView = new DateView(extend({}, options, {
                id: element.attr(ID),
                anchor: that.wrapper,
                change: function() {
                    // calendar is the current scope
                    that._change(this.value());
                    that.close();
                },
                close: function(e) {
                    if (that.trigger(CLOSE)) {
                        e.preventDefault();
                    } else {
                        element.attr(ARIA_EXPANDED, false);
                        div.attr(ARIA_HIDDEN, true);
                    }
                },
                open: function(e) {
                    var options = that.options,
                        date;

                    if (that.trigger(OPEN)) {
                        e.preventDefault();
                    } else {
                        if (that.element.val() !== that._oldText) {
                            date = parse(element.val(), options.parseFormats, options.culture);

                            that.dateView[date ? "current" : "value"](date);
                        }

                        element.attr(ARIA_EXPANDED, true);
                        div.attr(ARIA_HIDDEN, false);

                        that._updateARIA(date);

                    }
                }
            }));
            div = that.dateView.div;

            that._icon();

            try {
                element[0].setAttribute("type", "text");
            } catch(e) {
                element[0].type = "text";
            }

            element
                .addClass("k-input")
                .attr({
                    role: "combobox",
                    "aria-expanded": false,
                    "aria-owns": that.dateView._dateViewID
                });

            that._reset();
            that._template();

            disabled = element.is("[disabled]");
            if (disabled) {
                that.enable(false);
            } else {
                that.readonly(element.is("[readonly]"));
            }

            that._old = that._update(options.value || that.element.val());
            that._oldText = element.val();

            kendo.notify(that);
        },
        events: [
        OPEN,
        CLOSE,
        CHANGE],
        options: {
            name: "DatePicker",
            value: null,
            footer: "",
            format: "",
            culture: "",
            parseFormats: [],
            min: new Date(1900, 0, 1),
            max: new Date(2099, 11, 31),
            start: MONTH,
            depth: MONTH,
            animation: {},
            month : {},
            dates: [],
            ARIATemplate: 'Current focused date is #=kendo.toString(data.current, "D")#'
        },

        setOptions: function(options) {
            var that = this;
            var value = that._value;

            Widget.fn.setOptions.call(that, options);

            options = that.options;

            options.min = parse(options.min);
            options.max = parse(options.max);

            normalize(options);

            that.dateView.setOptions(options);

            if (value) {
                that.element.val(kendo.toString(value, options.format, options.culture));
                that._updateARIA(value);
            }
        },

        _editable: function(options) {
            var that = this,
                icon = that._dateIcon.off(ns),
                element = that.element.off(ns),
                wrapper = that._inputWrapper.off(ns),
                readonly = options.readonly,
                disable = options.disable;

            if (!readonly && !disable) {
                wrapper
                    .addClass(DEFAULT)
                    .removeClass(STATEDISABLED)
                    .on(HOVEREVENTS, that._toggleHover);

                element.removeAttr(DISABLED)
                       .removeAttr(READONLY)
                       .attr(ARIA_DISABLED, false)
                       .attr(ARIA_READONLY, false)
                       .on("keydown" + ns, proxy(that._keydown, that))
                       .on("blur" + ns, proxy(that._blur, that))
                       .on("focus" + ns, function() {
                           that._inputWrapper.addClass(FOCUSED);
                       });

               icon.on(CLICK, proxy(that._click, that))
                   .on(MOUSEDOWN, preventDefault);
            } else {
                wrapper
                    .addClass(disable ? STATEDISABLED : DEFAULT)
                    .removeClass(disable ? DEFAULT : STATEDISABLED);

                element.attr(DISABLED, disable)
                       .attr(READONLY, readonly)
                       .attr(ARIA_DISABLED, disable)
                       .attr(ARIA_READONLY, readonly);
            }
        },

        readonly: function(readonly) {
            this._editable({
                readonly: readonly === undefined ? true : readonly,
                disable: false
            });
        },

        enable: function(enable) {
            this._editable({
                readonly: false,
                disable: !(enable = enable === undefined ? true : enable)
            });
        },

        destroy: function() {
            var that = this;

            Widget.fn.destroy.call(that);

            that.dateView.destroy();

            that.element.off(ns);
            that._dateIcon.off(ns);
            that._inputWrapper.off(ns);

            if (that._form) {
                that._form.off("reset", that._resetHandler);
            }
        },

        open: function() {
            this.dateView.open();
        },

        close: function() {
            this.dateView.close();
        },

        min: function(value) {
            return this._option(MIN, value);
        },

        max: function(value) {
            return this._option(MAX, value);
        },

        value: function(value) {
            var that = this;

            if (value === undefined) {
                return that._value;
            }

            that._old = that._update(value);

            if (that._old === null) {
                that.element.val("");
            }

            that._oldText = that.element.val();
        },

        _toggleHover: function(e) {
            $(e.currentTarget).toggleClass(HOVER, e.type === "mouseenter");
        },

        _blur: function() {
            var that = this,
                value = that.element.val();

            that.close();
            if (value !== that._oldText) {
                that._change(value);
            }

            that._inputWrapper.removeClass(FOCUSED);
        },

        _click: function() {
            var that = this,
                element = that.element;

            that.dateView.toggle();

            if (!kendo.support.touch && element[0] !== activeElement()) {
                element.focus();
            }
        },

        _change: function(value) {
            var that = this;

            value = that._update(value);

            if (+that._old != +value) {
                that._old = value;
                that._oldText = that.element.val();

                that.trigger(CHANGE);

                // trigger the DOM change event so any subscriber gets notified
                that.element.trigger(CHANGE);
            }
        },

        _keydown: function(e) {
            var that = this,
                dateView = that.dateView,
                value = that.element.val();

            if (!dateView.popup.visible() && e.keyCode == keys.ENTER && value !== that._oldText) {
                that._change(value);
            } else {
                dateView.move(e);
                that._updateARIA(dateView._current);
            }
        },

        _icon: function() {
            var that = this,
                element = that.element,
                icon;

            icon = element.next("span.k-select");

            if (!icon[0]) {
                icon = $('<span unselectable="on" class="k-select"><span unselectable="on" class="k-icon k-i-calendar">select</span></span>').insertAfter(element);
            }

            that._dateIcon = icon.attr({
                "role": "button",
                "aria-controls": that.dateView._dateViewID
            });
        },

        _option: function(option, value) {
            var that = this,
                options = that.options;

            if (value === undefined) {
                return options[option];
            }

            value = parse(value, options.parseFormats, options.culture);

            if (!value) {
                return;
            }

            options[option] = new DATE(+value);
            that.dateView[option](value);
        },

        _update: function(value) {
            var that = this,
                options = that.options,
                min = options.min,
                max = options.max,
                current = that._value,
                date = parse(value, options.parseFormats, options.culture),
                isSameType = (date === null && current === null) || (date instanceof Date && current instanceof Date),
                formattedValue;

            if (+date === +current && isSameType) {
                formattedValue = kendo.toString(date, options.format, options.culture);

                if (formattedValue !== value) {
                    that.element.val(date === null ? value : formattedValue);
                }

                return date;
            }

            if (date !== null && isEqualDatePart(date, min)) {
                date = restrictValue(date, min, max);
            } else if (!isInRange(date, min, max)) {
                date = null;
            }

            that._value = date;
            that.dateView.value(date);
            that.element.val(date ? kendo.toString(date, options.format, options.culture) : value);
            that._updateARIA(date);

            return date;
        },

        _wrapper: function() {
            var that = this,
                element = that.element,
                wrapper;

            wrapper = element.parents(".k-datepicker");

            if (!wrapper[0]) {
                wrapper = element.wrap(SPAN).parent().addClass("k-picker-wrap k-state-default");
                wrapper = wrapper.wrap(SPAN).parent();
            }

            wrapper[0].style.cssText = element[0].style.cssText;
            element.css({
                width: "100%",
                height: element[0].style.height
            });

            that.wrapper = wrapper.addClass("k-widget k-datepicker k-header")
                                  .addClass(element[0].className);

            that._inputWrapper = $(wrapper[0].firstChild);
        },

        _reset: function() {
            var that = this,
                element = that.element,
                formId = element.attr("form"),
                form = formId ? $("#" + formId) : element.closest("form");

            if (form[0]) {
                that._resetHandler = function() {
                    that.value(element[0].defaultValue);
                };

                that._form = form.on("reset", that._resetHandler);
            }
        },

        _template: function() {
            this._ariaTemplate = template(this.options.ARIATemplate);
        },

        _updateARIA: function(date) {
            var cell;
            var that = this;
            var calendar = that.dateView.calendar;

            that.element.removeAttr("aria-activedescendant");

            if (calendar) {
                cell = calendar._cell;
                cell.attr("aria-label", that._ariaTemplate({ current: date || calendar.current() }));

                that.element.attr("aria-activedescendant", cell.attr("id"));
            }
        }
    });

    ui.plugin(DatePicker);

})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.fx',[ "./kendo.core" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        fx = kendo.effects,
        each = $.each,
        extend = $.extend,
        proxy = $.proxy,
        support = kendo.support,
        browser = support.browser,
        transforms = support.transforms,
        transitions = support.transitions,
        scaleProperties = { scale: 0, scalex: 0, scaley: 0, scale3d: 0 },
        translateProperties = { translate: 0, translatex: 0, translatey: 0, translate3d: 0 },
        hasZoom = (typeof document.documentElement.style.zoom !== "undefined") && !transforms,
        matrix3dRegExp = /matrix3?d?\s*\(.*,\s*([\d\.\-]+)\w*?,\s*([\d\.\-]+)\w*?,\s*([\d\.\-]+)\w*?,\s*([\d\.\-]+)\w*?/i,
        cssParamsRegExp = /^(-?[\d\.\-]+)?[\w\s]*,?\s*(-?[\d\.\-]+)?[\w\s]*/i,
        translateXRegExp = /translatex?$/i,
        oldEffectsRegExp = /(zoom|fade|expand)(\w+)/,
        singleEffectRegExp = /(zoom|fade|expand)/,
        unitRegExp = /[xy]$/i,
        transformProps = ["perspective", "rotate", "rotatex", "rotatey", "rotatez", "rotate3d", "scale", "scalex", "scaley", "scalez", "scale3d", "skew", "skewx", "skewy", "translate", "translatex", "translatey", "translatez", "translate3d", "matrix", "matrix3d"],
        transform2d = ["rotate", "scale", "scalex", "scaley", "skew", "skewx", "skewy", "translate", "translatex", "translatey", "matrix"],
        transform2units = { "rotate": "deg", scale: "", skew: "px", translate: "px" },
        cssPrefix = transforms.css,
        round = Math.round,
        BLANK = "",
        PX = "px",
        NONE = "none",
        AUTO = "auto",
        WIDTH = "width",
        HEIGHT = "height",
        HIDDEN = "hidden",
        ORIGIN = "origin",
        ABORT_ID = "abortId",
        OVERFLOW = "overflow",
        TRANSLATE = "translate",
        POSITION = "position",
        COMPLETE_CALLBACK = "completeCallback",
        TRANSITION = cssPrefix + "transition",
        TRANSFORM = cssPrefix + "transform",
        BACKFACE = cssPrefix + "backface-visibility",
        PERSPECTIVE = cssPrefix + "perspective",
        DEFAULT_PERSPECTIVE = "1500px",
        TRANSFORM_PERSPECTIVE = "perspective(" + DEFAULT_PERSPECTIVE + ")",
        ios7 = support.mobileOS && support.mobileOS.majorVersion == 7,
        directions = {
            left: {
                reverse: "right",
                property: "left",
                transition: "translatex",
                vertical: false,
                modifier: -1
            },
            right: {
                reverse: "left",
                property: "left",
                transition: "translatex",
                vertical: false,
                modifier: 1
            },
            down: {
                reverse: "up",
                property: "top",
                transition: "translatey",
                vertical: true,
                modifier: 1
            },
            up: {
                reverse: "down",
                property: "top",
                transition: "translatey",
                vertical: true,
                modifier: -1
            },
            top: {
                reverse: "bottom"
            },
            bottom: {
                reverse: "top"
            },
            "in": {
                reverse: "out",
                modifier: -1
            },
            out: {
                reverse: "in",
                modifier: 1
            },

            vertical: {
                reverse: "vertical"
            },

            horizontal: {
                reverse: "horizontal"
            }
        };

    kendo.directions = directions;

    extend($.fn, {
        kendoStop: function(clearQueue, gotoEnd) {
            if (transitions) {
                return fx.stopQueue(this, clearQueue || false, gotoEnd || false);
            } else {
                return this.stop(clearQueue, gotoEnd);
            }
        }
    });

    /* jQuery support for all transform animations (FF 3.5/3.6, Opera 10.x, IE9 */

    if (transforms && !transitions) {
        each(transform2d, function(idx, value) {
            $.fn[value] = function(val) {
                if (typeof val == "undefined") {
                    return animationProperty(this, value);
                } else {
                    var that = $(this)[0],
                        transformValue = value + "(" + val + transform2units[value.replace(unitRegExp, "")] + ")";

                    if (that.style.cssText.indexOf(TRANSFORM) == -1) {
                        $(this).css(TRANSFORM, transformValue);
                    } else {
                        that.style.cssText = that.style.cssText.replace(new RegExp(value + "\\(.*?\\)", "i"), transformValue);
                    }
                }
                return this;
            };

            $.fx.step[value] = function (fx) {
                $(fx.elem)[value](fx.now);
            };
        });

        var curProxy = $.fx.prototype.cur;
        $.fx.prototype.cur = function () {
            if (transform2d.indexOf(this.prop) != -1) {
                return parseFloat($(this.elem)[this.prop]());
            }

            return curProxy.apply(this, arguments);
        };
    }

    kendo.toggleClass = function(element, classes, options, add) {
        if (classes) {
            classes = classes.split(" ");

            if (transitions) {
                options = extend({
                    exclusive: "all",
                    duration: 400,
                    ease: "ease-out"
                }, options);

                element.css(TRANSITION, options.exclusive + " " + options.duration + "ms " + options.ease);
                setTimeout(function() {
                    element.css(TRANSITION, "").css(HEIGHT);
                }, options.duration); // TODO: this should fire a kendoAnimate session instead.
            }

            each(classes, function(idx, value) {
                element.toggleClass(value, add);
            });
        }

        return element;
    };

    kendo.parseEffects = function(input, mirror) {
        var effects = {};

        if (typeof input === "string") {
            each(input.split(" "), function(idx, value) {
                var redirectedEffect = !singleEffectRegExp.test(value),
                    resolved = value.replace(oldEffectsRegExp, function(match, $1, $2) {
                        return $1 + ":" + $2.toLowerCase();
                    }), // Support for old zoomIn/fadeOut style, now deprecated.
                    effect = resolved.split(":"),
                    direction = effect[1],
                    effectBody = {};

                if (effect.length > 1) {
                    effectBody.direction = (mirror && redirectedEffect ? directions[direction].reverse : direction);
                }

                effects[effect[0]] = effectBody;
            });
        } else {
            each(input, function(idx) {
                var direction = this.direction;

                if (direction && mirror && !singleEffectRegExp.test(idx)) {
                    this.direction = directions[direction].reverse;
                }

                effects[idx] = this;
            });
        }

        return effects;
    };

    function parseInteger(value) {
        return parseInt(value, 10);
    }

    function parseCSS(element, property) {
        return parseInteger(element.css(property));
    }

    function keys(obj) {
        var acc = [];
        for (var propertyName in obj) {
            acc.push(propertyName);
        }
        return acc;
    }

    function strip3DTransforms(properties) {
        for (var key in properties) {
            if (transformProps.indexOf(key) != -1 && transform2d.indexOf(key) == -1) {
                delete properties[key];
            }
        }

        return properties;
    }

    function normalizeCSS(element, properties) {
        var transformation = [], cssValues = {}, lowerKey, key, value, isTransformed;

        for (key in properties) {
            lowerKey = key.toLowerCase();
            isTransformed = transforms && transformProps.indexOf(lowerKey) != -1;

            if (!support.hasHW3D && isTransformed && transform2d.indexOf(lowerKey) == -1) {
                delete properties[key];
            } else {
                value = properties[key];

                if (isTransformed) {
                    transformation.push(key + "(" + value + ")");
                } else {
                    cssValues[key] = value;
                }
            }
        }

        if (transformation.length) {
            cssValues[TRANSFORM] = transformation.join(" ");
        }

        return cssValues;
    }

    if (transitions) {
        extend(fx, {
            transition: function(element, properties, options) {
                var css,
                    delay = 0,
                    oldKeys = element.data("keys") || [],
                    timeoutID;

                options = extend({
                        duration: 200,
                        ease: "ease-out",
                        complete: null,
                        exclusive: "all"
                    },
                    options
                );

                var stopTransitionCalled = false;

                var stopTransition = function() {
                    if (!stopTransitionCalled) {
                        stopTransitionCalled = true;

                        if (timeoutID) {
                            clearTimeout(timeoutID);
                            timeoutID = null;
                        }

                        element
                        .removeData(ABORT_ID)
                        .dequeue()
                        .css(TRANSITION, "")
                        .css(TRANSITION);

                        options.complete.call(element);
                    }
                };

                options.duration = $.fx ? $.fx.speeds[options.duration] || options.duration : options.duration;

                css = normalizeCSS(element, properties);

                $.merge(oldKeys, keys(css));
                element
                    .data("keys", $.unique(oldKeys))
                    .height();

                element.css(TRANSITION, options.exclusive + " " + options.duration + "ms " + options.ease).css(TRANSITION);
                element.css(css).css(TRANSFORM);

                /**
                 * Use transitionEnd event for browsers who support it - but duplicate it with setTimeout, as the transitionEnd event will not be triggered if no CSS properties change.
                 * This should be cleaned up at some point (widget by widget), and refactored to widgets not relying on the complete callback if no transition occurs.
                 *
                 * For IE9 and below, resort to setTimeout.
                 */
                if (transitions.event) {
                    element.one(transitions.event, stopTransition);
                    if (options.duration !== 0) {
                        delay = 500;
                    }
                }

                timeoutID = setTimeout(stopTransition, options.duration + delay);
                element.data(ABORT_ID, timeoutID);
                element.data(COMPLETE_CALLBACK, stopTransition);
            },

            stopQueue: function(element, clearQueue, gotoEnd) {
                var cssValues,
                    taskKeys = element.data("keys"),
                    retainPosition = (!gotoEnd && taskKeys),
                    completeCallback = element.data(COMPLETE_CALLBACK);

                if (retainPosition) {
                    cssValues = kendo.getComputedStyles(element[0], taskKeys);
                }

                if (completeCallback) {
                    completeCallback();
                }

                if (retainPosition) {
                    element.css(cssValues);
                }

                return element
                        .removeData("keys")
                        .stop(clearQueue);
            }
        });
    }

    function animationProperty(element, property) {
        if (transforms) {
            var transform = element.css(TRANSFORM);
            if (transform == NONE) {
                return property == "scale" ? 1 : 0;
            }

            var match = transform.match(new RegExp(property + "\\s*\\(([\\d\\w\\.]+)")),
                computed = 0;

            if (match) {
                computed = parseInteger(match[1]);
            } else {
                match = transform.match(matrix3dRegExp) || [0, 0, 0, 0, 0];
                property = property.toLowerCase();

                if (translateXRegExp.test(property)) {
                    computed = parseFloat(match[3] / match[2]);
                } else if (property == "translatey") {
                    computed = parseFloat(match[4] / match[2]);
                } else if (property == "scale") {
                    computed = parseFloat(match[2]);
                } else if (property == "rotate") {
                    computed = parseFloat(Math.atan2(match[2], match[1]));
                }
            }

            return computed;
        } else {
            return parseFloat(element.css(property));
        }
    }

    var EffectSet = kendo.Class.extend({
        init: function(element, options) {
            var that = this;

            that.element = element;
            that.effects = [];
            that.options = options;
            that.restore = [];
        },

        run: function(effects) {
            var that = this,
                effect,
                idx, jdx,
                length = effects.length,
                element = that.element,
                options = that.options,
                deferred = $.Deferred(),
                start = {},
                end = {},
                target,
                children,
                childrenLength;

            that.effects = effects;

            deferred.then($.proxy(that, "complete"));

            element.data("animating", true);

            for (idx = 0; idx < length; idx ++) {
                effect = effects[idx];

                effect.setReverse(options.reverse);
                effect.setOptions(options);

                that.addRestoreProperties(effect.restore);

                effect.prepare(start, end);

                children = effect.children();

                for (jdx = 0, childrenLength = children.length; jdx < childrenLength; jdx ++) {
                    children[jdx].duration(options.duration).run();
                }
            }

            // legacy support for options.properties
            for (var effectName in options.effects) {
                extend(end, options.effects[effectName].properties);
            }

            // Show the element initially
            if (!element.is(":visible")) {
                extend(start, { display: element.data("olddisplay") || "block" });
            }

            if (transforms && !options.reset) {
                target = element.data("targetTransform");

                if (target) {
                    start = extend(target, start);
                }
            }

            start = normalizeCSS(element, start);

            if (transforms && !transitions) {
                start = strip3DTransforms(start);
            }

            element.css(start)
                   .css(TRANSFORM); // Nudge

            for (idx = 0; idx < length; idx ++) {
                effects[idx].setup();
            }

            if (options.init) {
                options.init();
            }

            element.data("targetTransform", end);
            fx.animate(element, end, extend({}, options, { complete: deferred.resolve }));

            return deferred.promise();
        },

        stop: function() {
            $(this.element).kendoStop(true, true);
        },

        addRestoreProperties: function(restore) {
            var element = this.element,
                value,
                i = 0,
                length = restore.length;

            for (; i < length; i ++) {
                value = restore[i];

                this.restore.push(value);

                if (!element.data(value)) {
                    element.data(value, element.css(value));
                }
            }
        },

        restoreCallback: function() {
            var element = this.element;

            for (var i = 0, length = this.restore.length; i < length; i ++) {
                var value = this.restore[i];
                element.css(value, element.data(value));
            }
        },

        complete: function() {
            var that = this,
                idx = 0,
                element = that.element,
                options = that.options,
                effects = that.effects,
                length = effects.length;

            element
                .removeData("animating")
                .dequeue(); // call next animation from the queue

            if (options.hide) {
                element.data("olddisplay", element.css("display")).hide();
            }

            this.restoreCallback();

            if (hasZoom && !transforms) {
                setTimeout($.proxy(this, "restoreCallback"), 0); // Again jQuery callback in IE8-
            }

            for (; idx < length; idx ++) {
                effects[idx].teardown();
            }

            if (options.completeCallback) {
                options.completeCallback(element);
            }
        }
    });

    fx.promise = function(element, options) {
        var effects = [],
            effectClass,
            effectSet = new EffectSet(element, options),
            parsedEffects = kendo.parseEffects(options.effects),
            effect;

        options.effects = parsedEffects;

        for (var effectName in parsedEffects) {
            effectClass = fx[capitalize(effectName)];

            if (effectClass) {
                effect = new effectClass(element, parsedEffects[effectName].direction);
                effects.push(effect);
           }
        }

        if (effects[0]) {
            effectSet.run(effects);
        } else { // Not sure how would an fx promise reach this state - means that you call kendoAnimate with no valid effects? Why?
            if (!element.is(":visible")) {
                element.css({ display: element.data("olddisplay") || "block" }).css("display");
            }

            if (options.init) {
                options.init();
            }

            element.dequeue();
            effectSet.complete();
        }
    };

    extend(fx, {
        animate: function(elements, properties, options) {
            var useTransition = options.transition !== false;
            delete options.transition;

            if (transitions && "transition" in fx && useTransition) {
                fx.transition(elements, properties, options);
            } else {
                if (transforms) {
                    elements.animate(strip3DTransforms(properties), { queue: false, show: false, hide: false, duration: options.duration, complete: options.complete }); // Stop animate from showing/hiding the element to be able to hide it later on.
                } else {
                    elements.each(function() {
                        var element = $(this),
                            multiple = {};

                        each(transformProps, function(idx, value) { // remove transforms to avoid IE and older browsers confusion
                            var params,
                                currentValue = properties ? properties[value]+ " " : null; // We need to match

                            if (currentValue) {
                                var single = properties;

                                if (value in scaleProperties && properties[value] !== undefined) {
                                    params = currentValue.match(cssParamsRegExp);
                                    if (transforms) {
                                        extend(single, { scale: +params[0] });
                                    }
                                } else {
                                    if (value in translateProperties && properties[value] !== undefined) {
                                        var position = element.css(POSITION),
                                            isFixed = (position == "absolute" || position == "fixed");

                                        if (!element.data(TRANSLATE)) {
                                            if (isFixed) {
                                                element.data(TRANSLATE, {
                                                    top: parseCSS(element, "top") || 0,
                                                    left: parseCSS(element, "left") || 0,
                                                    bottom: parseCSS(element, "bottom"),
                                                    right: parseCSS(element, "right")
                                                });
                                            } else {
                                                element.data(TRANSLATE, {
                                                    top: parseCSS(element, "marginTop") || 0,
                                                    left: parseCSS(element, "marginLeft") || 0
                                                });
                                            }
                                        }

                                        var originalPosition = element.data(TRANSLATE);

                                        params = currentValue.match(cssParamsRegExp);
                                        if (params) {

                                            var dX = value == TRANSLATE + "y" ? +null : +params[1],
                                                dY = value == TRANSLATE + "y" ? +params[1] : +params[2];

                                            if (isFixed) {
                                                if (!isNaN(originalPosition.right)) {
                                                    if (!isNaN(dX)) { extend(single, { right: originalPosition.right - dX }); }
                                                } else {
                                                    if (!isNaN(dX)) { extend(single, { left: originalPosition.left + dX }); }
                                                }

                                                if (!isNaN(originalPosition.bottom)) {
                                                    if (!isNaN(dY)) { extend(single, { bottom: originalPosition.bottom - dY }); }
                                                } else {
                                                    if (!isNaN(dY)) { extend(single, { top: originalPosition.top + dY }); }
                                                }
                                            } else {
                                                if (!isNaN(dX)) { extend(single, { marginLeft: originalPosition.left + dX }); }
                                                if (!isNaN(dY)) { extend(single, { marginTop: originalPosition.top + dY }); }
                                            }
                                        }
                                    }
                                }

                                if (!transforms && value != "scale" && value in single) {
                                    delete single[value];
                                }

                                if (single) {
                                    extend(multiple, single);
                                }
                            }
                        });

                        if (browser.msie) {
                            delete multiple.scale;
                        }

                        element.animate(multiple, { queue: false, show: false, hide: false, duration: options.duration, complete: options.complete }); // Stop animate from showing/hiding the element to be able to hide it later on.
                    });
                }
            }
        }
    });

    fx.animatedPromise = fx.promise;

    var Effect = kendo.Class.extend({
        init: function(element, direction) {
            var that = this;
            that.element = element;
            that._direction = direction;
            that.options = {};
            that._additionalEffects = [];

            if (!that.restore) {
                that.restore = [];
            }
        },

// Public API
        reverse: function() {
            this._reverse = true;
            return this.run();
        },

        play: function() {
            this._reverse = false;
            return this.run();
        },

        add: function(additional) {
            this._additionalEffects.push(additional);
            return this;
        },

        direction: function(value) {
            this._direction = value;
            return this;
        },

        duration: function(duration) {
            this._duration = duration;
            return this;
        },

        compositeRun: function() {
            var that = this,
                effectSet = new EffectSet(that.element, { reverse: that._reverse, duration: that._duration }),
                effects = that._additionalEffects.concat([ that ]);

            return effectSet.run(effects);
        },

        run: function() {
            if (this._additionalEffects && this._additionalEffects[0]) {
                return this.compositeRun();
            }

            var that = this,
                element = that.element,
                idx = 0,
                restore = that.restore,
                length = restore.length,
                value,
                deferred = $.Deferred(),
                start = {},
                end = {},
                target,
                children = that.children(),
                childrenLength = children.length;

            deferred.then($.proxy(that, "_complete"));

            element.data("animating", true);

            for (idx = 0; idx < length; idx ++) {
                value = restore[idx];

                if (!element.data(value)) {
                    element.data(value, element.css(value));
                }
            }

            for (idx = 0; idx < childrenLength; idx ++) {
                children[idx].duration(that._duration).run();
            }

            that.prepare(start, end);

            if (!element.is(":visible")) {
                extend(start, { display: element.data("olddisplay") || "block" });
            }

            if (transforms) {
                target = element.data("targetTransform");

                if (target) {
                    start = extend(target, start);
                }
            }

            start = normalizeCSS(element, start);

            if (transforms && !transitions) {
                start = strip3DTransforms(start);
            }

            element.css(start).css(TRANSFORM); // Trick webkit into re-rendering

            that.setup();

            element.data("targetTransform", end);
            fx.animate(element, end, { duration: that._duration, complete: deferred.resolve });

            return deferred.promise();
        },

        stop: function() {
            var idx = 0,
                children = this.children(),
                childrenLength = children.length;

            for (idx = 0; idx < childrenLength; idx ++) {
                children[idx].stop();
            }

            $(this.element).kendoStop(true, true);
            return this;
        },

        restoreCallback: function() {
            var element = this.element;

            for (var i = 0, length = this.restore.length; i < length; i ++) {
                var value = this.restore[i];
                element.css(value, element.data(value));
            }
        },

        _complete: function() {
            var that = this,
                element = that.element;

            element
                .removeData("animating")
                .dequeue(); // call next animation from the queue

            that.restoreCallback();

            if (that.shouldHide()) {
                element.data("olddisplay", element.css("display")).hide();
            }

            if (hasZoom && !transforms) {
                setTimeout($.proxy(that, "restoreCallback"), 0); // Again jQuery callback in IE8-
            }

            that.teardown();
        },

        /////////////////////////// Support for kendo.animate;
        setOptions: function(options) {
            extend(true, this.options, options);
        },

        children: function() {
            return [];
        },

        shouldHide: $.noop,

        setup: $.noop,
        prepare: $.noop,
        teardown: $.noop,
        directions: [],

        setReverse: function(reverse) {
            this._reverse = reverse;
            return this;
        }
    });

    function capitalize(word) {
        return word.charAt(0).toUpperCase() + word.substring(1);
    }

    function createEffect(name, definition) {
        var effectClass = Effect.extend(definition),
            directions = effectClass.prototype.directions;

        fx[capitalize(name)] = effectClass;

        fx.Element.prototype[name] = function(direction, opt1, opt2, opt3) {
            return new effectClass(this.element, direction, opt1, opt2, opt3);
        };

        each(directions, function(idx, theDirection) {
            fx.Element.prototype[name + capitalize(theDirection)] = function(opt1, opt2, opt3) {
                return new effectClass(this.element, theDirection, opt1, opt2, opt3);
            };
        });
    }

    var FOUR_DIRECTIONS = ["left", "right", "up", "down"],
        IN_OUT = ["in", "out"];

    createEffect("slideIn", {
        directions: FOUR_DIRECTIONS,

        divisor: function(value) {
            this.options.divisor = value;
            return this;
        },

        prepare: function(start, end) {
            var that = this,
                tmp,
                element = that.element,
                direction = directions[that._direction],
                offset = -direction.modifier * (direction.vertical ? element.outerHeight() : element.outerWidth()),
                startValue = offset / (that.options && that.options.divisor || 1) + PX,
                endValue = "0px";

            if (that._reverse) {
                tmp = start;
                start = end;
                end = tmp;
            }

            if (transforms) {
                start[direction.transition] = startValue;
                end[direction.transition] = endValue;
            } else {
                start[direction.property] = startValue;
                end[direction.property] = endValue;
            }
        }
    });

    createEffect("tile", {
        directions: FOUR_DIRECTIONS,

        init: function(element, direction, previous) {
            Effect.prototype.init.call(this, element, direction);
            this.options = { previous: previous };
        },

        previousDivisor: function(value) {
            this.options.previousDivisor = value;
            return this;
        },

        children: function() {
            var that = this,
                reverse = that._reverse,
                previous = that.options.previous,
                divisor = that.options.previousDivisor || 1,
                dir = that._direction;

            var children = [ kendo.fx(that.element).slideIn(dir).setReverse(reverse) ];

            if (previous) {
                children.push( kendo.fx(previous).slideIn(directions[dir].reverse).divisor(divisor).setReverse(!reverse) );
            }

            return children;
        }
    });

    function createToggleEffect(name, property, defaultStart, defaultEnd) {
        createEffect(name, {
            directions: IN_OUT,

            startValue: function(value) {
                this._startValue = value;
                return this;
            },

            endValue: function(value) {
                this._endValue = value;
                return this;
            },

            shouldHide: function() {
               return this._shouldHide;
            },

            prepare: function(start, end) {
                var that = this,
                    startValue,
                    endValue,
                    out = this._direction === "out",
                    startDataValue = that.element.data(property),
                    startDataValueIsSet = !(isNaN(startDataValue) || startDataValue == defaultStart);

                if (startDataValueIsSet) {
                    startValue = startDataValue;
                } else if (typeof this._startValue !== "undefined") {
                    startValue = this._startValue;
                } else {
                    startValue = out ? defaultStart : defaultEnd;
                }

                if (typeof this._endValue !== "undefined") {
                    endValue = this._endValue;
                } else {
                    endValue = out ? defaultEnd : defaultStart;
                }

                if (this._reverse) {
                    start[property] = endValue;
                    end[property] = startValue;
                } else {
                    start[property] = startValue;
                    end[property] = endValue;
                }

                that._shouldHide = end[property] === defaultEnd;
            }
        });
    }

    createToggleEffect("fade", "opacity", 1, 0);
    createToggleEffect("zoom", "scale", 1, 0.01);

    createEffect("slideMargin", {
        prepare: function(start, end) {
            var that = this,
                element = that.element,
                options = that.options,
                origin = element.data(ORIGIN),
                offset = options.offset,
                margin,
                reverse = that._reverse;

            if (!reverse && origin === null) {
                element.data(ORIGIN, parseFloat(element.css("margin-" + options.axis)));
            }

            margin = (element.data(ORIGIN) || 0);
            end["margin-" + options.axis] = !reverse ? margin + offset : margin;
        }
    });

    createEffect("slideTo", {
        prepare: function(start, end) {
            var that = this,
                element = that.element,
                options = that.options,
                offset = options.offset.split(","),
                reverse = that._reverse;

            if (transforms) {
                end.translatex = !reverse ? offset[0] : 0;
                end.translatey = !reverse ? offset[1] : 0;
            } else {
                end.left = !reverse ? offset[0] : 0;
                end.top = !reverse ? offset[1] : 0;
            }
            element.css("left");
        }
    });

    createEffect("expand", {
        directions: ["horizontal", "vertical"],

        restore: [ OVERFLOW ],

        prepare: function(start, end) {
            var that = this,
                element = that.element,
                options = that.options,
                reverse = that._reverse,
                property = that._direction === "vertical" ? HEIGHT : WIDTH,
                setLength = element[0].style[property],
                oldLength = element.data(property),
                length = parseFloat(oldLength || setLength),
                realLength = round(element.css(property, AUTO)[property]());

            start.overflow = HIDDEN;

            length = (options && options.reset) ? realLength || length : length || realLength;

            end[property] = (reverse ? 0 : length) + PX;
            start[property] = (reverse ? length : 0) + PX;

            if (oldLength === undefined) {
                element.data(property, setLength);
            }
        },

        shouldHide: function() {
           return this._reverse;
        },

        teardown: function() {
            var that = this,
                element = that.element,
                property = that._direction === "vertical" ? HEIGHT : WIDTH,
                length = element.data(property);

            if (length == AUTO || length === BLANK) {
                setTimeout(function() { element.css(property, AUTO).css(property); }, 0); // jQuery animate complete callback in IE is called before the last animation step!
            }
        }
    });

    var TRANSFER_START_STATE = { position: "absolute", marginLeft: 0, marginTop: 0, scale: 1 };
    /**
     * Intersection point formulas are taken from here - http://zonalandeducation.com/mmts/intersections/intersectionOfTwoLines1/intersectionOfTwoLines1.html
     * Formula for a linear function from two points from here - http://demo.activemath.org/ActiveMath2/search/show.cmd?id=mbase://AC_UK_calculus/functions/ex_linear_equation_two_points
     * The transform origin point is the intersection point of the two lines from the top left corners/top right corners of the element and target.
     * The math and variables below MAY BE SIMPLIFIED (zeroes removed), but this would make the formula too cryptic.
     */
    createEffect("transfer", {
        init: function(element, target) {
            this.element = element;
            this.options = { target: target };
            this.restore = [];
        },

        setup: function() {
            this.element.appendTo(document.body);
        },

        prepare: function(start, end) {
            var that = this,
                element = that.element,
                options = that.options,
                reverse = that._reverse,
                target = options.target,
                offset,
                currentScale = animationProperty(element, "scale"),
                targetOffset = target.offset(),
                scale = target.outerHeight() / element.outerHeight();

            extend(start, TRANSFER_START_STATE);
            end.scale = 1;

            element.css(TRANSFORM, "scale(1)").css(TRANSFORM);
            offset = element.offset();
            element.css(TRANSFORM, "scale(" + currentScale + ")");

            var x1 = 0,
                y1 = 0,

                x2 = targetOffset.left - offset.left,
                y2 = targetOffset.top - offset.top,

                x3 = x1 + element.outerWidth(),
                y3 = y1,

                x4 = x2 + target.outerWidth(),
                y4 = y2,

                Z1 = (y2 - y1) / (x2 - x1),
                Z2 = (y4 - y3) / (x4 - x3),

                X = (y1 - y3 - Z1 * x1 + Z2 * x3) / (Z2 - Z1),
                Y = y1 + Z1 * (X - x1);

            start.top = offset.top;
            start.left = offset.left;
            start.transformOrigin = X + PX + " " + Y + PX;

            if (reverse) {
                start.scale = scale;
            } else {
                end.scale = scale;
            }
        }
    });


    var CLIPS = {
        top: "rect(auto auto $size auto)",
        bottom: "rect($size auto auto auto)",
        left: "rect(auto $size auto auto)",
        right: "rect(auto auto auto $size)"
    };

    var ROTATIONS = {
        top:    { start: "rotatex(0deg)", end: "rotatex(180deg)" },
        bottom: { start: "rotatex(-180deg)", end: "rotatex(0deg)" },
        left:   { start: "rotatey(0deg)", end: "rotatey(-180deg)" },
        right:  { start: "rotatey(180deg)", end: "rotatey(0deg)" }
    };

    function clipInHalf(container, direction) {
        var vertical = kendo.directions[direction].vertical,
            size = (container[vertical ? HEIGHT : WIDTH]() / 2) + "px";

        return CLIPS[direction].replace("$size", size);
    }

    createEffect("turningPage", {
        directions: FOUR_DIRECTIONS,

        init: function(element, direction, container) {
            Effect.prototype.init.call(this, element, direction);
            this._container = container;
        },

        prepare: function(start, end) {
            var that = this,
                reverse = that._reverse,
                direction = reverse ? directions[that._direction].reverse : that._direction,
                rotation = ROTATIONS[direction];

            start.zIndex = 1;

            if (that._clipInHalf) {
               start.clip = clipInHalf(that._container, kendo.directions[direction].reverse);
            }

            start[BACKFACE] = HIDDEN;

            end[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.start : rotation.end);
            start[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.end : rotation.start);
        },

        setup: function() {
            this._container.append(this.element);
        },

        face: function(value) {
            this._face = value;
            return this;
        },

        shouldHide: function() {
            var that = this,
                reverse = that._reverse,
                face = that._face;

            return (reverse && !face) || (!reverse && face);
        },

        clipInHalf: function(value) {
            this._clipInHalf = value;
            return this;
        },

        temporary: function() {
            this.element.addClass('temp-page');
            return this;
        }
    });

    createEffect("staticPage", {
        directions: FOUR_DIRECTIONS,

        init: function(element, direction, container) {
            Effect.prototype.init.call(this, element, direction);
            this._container = container;
        },

        restore: ["clip"],

        prepare: function(start, end) {
            var that = this,
                direction = that._reverse ? directions[that._direction].reverse : that._direction;

            start.clip = clipInHalf(that._container, direction);
            start.opacity = 0.999;
            end.opacity = 1;
        },

        shouldHide: function() {
            var that = this,
                reverse = that._reverse,
                face = that._face;

            return (reverse && !face) || (!reverse && face);
        },

        face: function(value) {
            this._face = value;
            return this;
        }
    });

    createEffect("pageturn", {
        directions: ["horizontal", "vertical"],

        init: function(element, direction, face, back) {
            Effect.prototype.init.call(this, element, direction);
            this.options = {};
            this.options.face = face;
            this.options.back = back;
        },

        children: function() {
            var that = this,
                options = that.options,
                direction = that._direction === "horizontal" ? "left" : "top",
                reverseDirection = kendo.directions[direction].reverse,
                reverse = that._reverse,
                temp,
                faceClone = options.face.clone(true).removeAttr("id"),
                backClone = options.back.clone(true).removeAttr("id"),
                element = that.element;

            if (reverse) {
                temp = direction;
                direction = reverseDirection;
                reverseDirection = temp;
            }

            return [
                kendo.fx(options.face).staticPage(direction, element).face(true).setReverse(reverse),
                kendo.fx(options.back).staticPage(reverseDirection, element).setReverse(reverse),
                kendo.fx(faceClone).turningPage(direction, element).face(true).clipInHalf(true).temporary().setReverse(reverse),
                kendo.fx(backClone).turningPage(reverseDirection, element).clipInHalf(true).temporary().setReverse(reverse)
            ];
        },

        prepare: function(start, end) {
            start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;
            start.transformStyle = "preserve-3d";
            // hack to trigger transition end.
            start.opacity = 0.999;
            end.opacity = 1;
        },

        teardown: function() {
            this.element.find(".temp-page").remove();
        }
    });

    createEffect("flip", {
        directions: ["horizontal", "vertical"],

        init: function(element, direction, face, back) {
            Effect.prototype.init.call(this, element, direction);
            this.options = {};
            this.options.face = face;
            this.options.back = back;
        },

        children: function() {
            var that = this,
                options = that.options,
                direction = that._direction === "horizontal" ? "left" : "top",
                reverseDirection = kendo.directions[direction].reverse,
                reverse = that._reverse,
                temp,
                element = that.element;

            if (reverse) {
                temp = direction;
                direction = reverseDirection;
                reverseDirection = temp;
            }

            return [
                kendo.fx(options.face).turningPage(direction, element).face(true).setReverse(reverse),
                kendo.fx(options.back).turningPage(reverseDirection, element).setReverse(reverse)
            ];
        },

        prepare: function(start) {
            start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;
            start.transformStyle = "preserve-3d";
        }
    });

    var RESTORE_OVERFLOW = !support.mobileOS.android;

    createEffect("replace", {
        init: function(element, previous, transitionClass) {
            Effect.prototype.init.call(this, element);
            this._previous = $(previous);
            this._transitionClass = transitionClass;
        },

        duration: function() {
            throw new Error("The replace effect does not support duration setting; the effect duration may be customized through the transition class rule");
        },

        _both: function() {
            return $().add(this._element).add(this._previous);
        },

        _containerClass: function() {
            var direction = this._direction,
                containerClass = "k-fx k-fx-start k-fx-" + this._transitionClass;

            if (direction) {
                containerClass += " k-fx-" + direction;
            }

            if (this._reverse) {
                containerClass += " k-fx-reverse";
            }

            return containerClass;
        },

        complete: function() {
            if (!this.deferred) {
                return;
            }
            var container = this.container;

            container.removeClass("k-fx-end").removeClass(this._containerClass());
            this._previous.hide().removeClass("k-fx-current");
            this.element.removeClass("k-fx-next");

            if (RESTORE_OVERFLOW) {
                container.css(OVERFLOW, "");
            }

            if (!this.isAbsolute) {
                this._both().css(POSITION, "");
            }

            this.deferred.resolve();
            delete this.deferred;
        },

        run: function() {
            if (this._additionalEffects && this._additionalEffects[0]) {
                return this.compositeRun();
            }

            var that = this,
                element = that.element,
                previous = that._previous,
                direction = that._direction,
                container = element.parents().filter(previous.parents()).first(),
                both = that._both(),
                deferred = $.Deferred(),
                originalPosition = element.css(POSITION),
                originalOverflow;

            // edge case for grid/scheduler, where the previous is already destroyed.
            if (!container.length) {
                container = element.parent();
            }

            this.container = container;
            this.deferred = deferred;
            this.isAbsolute = originalPosition  == "absolute";

            if (!this.isAbsolute) {
                both.css(POSITION, "absolute");
            }

            if (RESTORE_OVERFLOW) {
                originalOverflow = container.css(OVERFLOW);
                container.css(OVERFLOW, "hidden");
            }

            if (!transitions) {
                this.complete();
            } else {
                element.addClass("k-fx-hidden");

                container.addClass(this._containerClass());

                container.one(transitions.event, $.proxy(this, "complete"));

                kendo.animationFrame(function() {
                    element.removeClass("k-fx-hidden").addClass("k-fx-next");
                    previous.css("display", "").addClass("k-fx-current");

                    kendo.animationFrame(function() {
                        container.removeClass("k-fx-start").addClass("k-fx-end");
                    });
                });
            }

            return deferred.promise();
        },

        stop: function() {
            this.complete();
        }
    });

    var Animation = kendo.Class.extend({
        init: function() {
            var that = this;
            that._tickProxy = proxy(that._tick, that);
            that._started = false;
        },

        tick: $.noop,
        done: $.noop,
        onEnd: $.noop,
        onCancel: $.noop,

        start: function() {
            if (!this.enabled()) {
                return;
            }

            if (!this.done()) {
                this._started = true;
                kendo.animationFrame(this._tickProxy);
            } else {
                this.onEnd();
            }
        },

        enabled: function() {
            return true;
        },

        cancel: function() {
            this._started = false;
            this.onCancel();
        },

        _tick: function() {
            var that = this;
            if (!that._started) { return; }

            that.tick();

            if (!that.done()) {
                kendo.animationFrame(that._tickProxy);
            } else {
                that._started = false;
                that.onEnd();
            }
        }
    });

    var Transition = Animation.extend({
        init: function(options) {
            var that = this;
            extend(that, options);
            Animation.fn.init.call(that);
        },

        done: function() {
            return this.timePassed() >= this.duration;
        },

        timePassed: function() {
            return Math.min(this.duration, (new Date()) - this.startDate);
        },

        moveTo: function(options) {
            var that = this,
                movable = that.movable;

            that.initial = movable[that.axis];
            that.delta = options.location - that.initial;

            that.duration = typeof options.duration == "number" ? options.duration : 300;

            that.tick = that._easeProxy(options.ease);

            that.startDate = new Date();
            that.start();
        },

        _easeProxy: function(ease) {
            var that = this;

            return function() {
                that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
            };
        }
    });

    extend(Transition, {
        easeOutExpo: function (t, b, c, d) {
            return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
        },

        easeOutBack: function (t, b, c, d, s) {
            s = 1.70158;
            return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
        }
    });

    fx.Animation = Animation;
    fx.Transition = Transition;
    fx.createEffect = createEffect;
})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });
define('utils/datepicker',["generated/templates",
        "utils/browserutils", "kendo/kendo.datepicker", "kendo/kendo.fx"], function (JST, BrowserUtils, kDatePicker, kFX) {
  var DatePicker = function (_options){

        var self = this,
            options = _options,
            $core = options.core,
            $scrollable = _options.scrollable || $('body'),
            $picker = $(JST.date_picker({})),
            // $title = $picker.find('.title'),
            // $tbody = $picker.find('tbody'),
            $parent = rf.globals.dbRegistry.getCurrentDashboard()._getNinjaDiv(),
            // now = new Date(),
            // shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            // fullMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            // shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            visible = false,
            datePickerObj,
            range = options.range;


        self.setDate = function(start) {
          startDate = start;
        };

        self.setDateRange = function(start, end) {
          startDate = start;
          endDate = end;
        };

        self.render = function() {
          if(range) {
            renderRange();
            return;
          }

          renderNormal();
        };

        var renderRange = function() {

          var startChange = function() {
            start.max(makeDate(end.value(), true));
            end.min(makeDate(start.value(), true));

            if(start.value() > end.value()) {
              end.value(makeDate(start.value(), true));
            }
          };

          var endChange = function() {
            start.max(makeDate(end.value(), true));
          };

          var start = $core[0].kendoDatePicker({
            format: "dd MM yyyy",
            value: makeDate(options.defaultStartDate),
            change: startChange,
            footer: false,
            //culture: "da-DK"
          }).data('kendoDatePicker');

          var end = $core[1].kendoDatePicker({
            format: "dd MM yyyy",
            value: makeDate(options.defaultEndDate),
            change: endChange,
            footer: false,
            //culture: "da-DK"
          }).data('kendoDatePicker');

          start.max(makeDate(options.defaultEndDate));
          end.min(makeDate(options.defaultStartDate));
        };

        var renderNormal = function() {
          
          $core.kendoDatePicker({
            animation: {},
            format: "dd MM yyyy",
            value: makeDate(options.defaultDate),
            footer: false,
            //culture: "da-DK"
          }).data('kendoDatePicker');
        };

        var makeDate = function(dateString, fullDate) {
          if(fullDate) {
            return new Date(dateString);
          }

          var parts = dateString.split("-");

          return new Date(parts[0], parts[1]-1, parts[2]);
        };

        // $parent.append($picker);
        //
        // datePickerObj = $picker.kendoDatePicker();

        // now = $core.val() ? new Date($core.val()) : now;
        //
        // // The double eq is required here to support firefox ---signed -- Dragon
        // now = (now == 'Invalid Date' ? new Date() : now);
        //
        // // $core.parent().append($picker);
        // $parent.append($picker);
        //
        // $picker.hide();
        //
        // /**
        //  * Gets the number of days in a particular month in a particular year
        //  */
        // function daysInMonth(month, year) {
        //     return new Date(year, month + 1, 0).getDate();
        // }
        //
        // var prepareDatePicker = function() {
        //     var startDay,
        //         numDays,
        //         numRows,
        //         i, $trs,
        //         row, $td,
        //         c;
        //
        //     $title.text(fullMonths[now.getMonth()] + ' ' + now.getFullYear());
        //
        //     startDay = (new Date(1 + ' ' + shortMonths[now.getMonth()] + ' ' + now.getFullYear())).getDay();
        //
        //     numDays = daysInMonth(now.getMonth(), now.getFullYear());
        //
        //     numRows = Math.ceil((numDays + startDay) / 7);
        //     $tbody.empty();
        //
        //     for(i=0; i<numRows; i++) {
        //         $tbody.append($('<tr/>'));
        //     }
        //
        //     $trs = $tbody.find('tr');
        //
        //     for(i=0; i < 7 * numRows; i++) {
        //         row = Math.floor(i / 7);
        //
        //         $td = $('<td/>');
        //         c = i - startDay + 1;
        //         if(c > 0 && c <= numDays) {
        //             $td.append(
        //                     $('<p/>').text((i - startDay + 1))
        //                 ).addClass('date');
        //         }
        //
        //         if(now.getDate() === c) {
        //             $td.addClass('selected');
        //         }
        //
        //         $($trs[row]).append($td);
        //     }
        //
        //     reposition();
        //
        //     $picker.find('td.date').on('mousedown', function(e) {
        //         var newDate = $(this).text();
        //
        //         now = new Date(newDate + ' ' + shortMonths[now.getMonth()] + ' ' + now.getFullYear());
        //
        //         $picker.find('td.date').removeClass('selected');
        //
        //         $(this).addClass('selected');
        //
        //         changeDateInTextbox();
        //     });
        //
        // };
        //
        // var reposition = function() {
        //     var height = BrowserUtils.isIE() ? $core.innerHeight() : $core.height();
        //     $picker.css({
        //         position: 'absolute',
        //         top: $core.offset().top + height + 2 + $core.scrollTop(),
        //         left: $core.offset().left
        //     });
        // };
        //
        //
        // var changeVisibility = function (_visible) {
        //     if(_visible) {
        //         reposition();
        //         $picker.show();
        //     } else {
        //         $picker.hide();
        //     }
        //
        //     visible = _visible;
        // };
        //
        // var changeDateInTextbox = function () {
        //     $core.val(formatDate(now, 'Y-m-d'));
        //     $core.trigger('keyup');
        // };
        //
        // /**
        //  * Ameen's pathetic date formatter
        //  * fomat string processes the following characters for insertion
        //  *     D => Weekday, eg: Mon
        //  *     d => Date, eg: 2
        //  *     m => Month in number, eg: 11
        //  *     M => Month in letters, eg: Nov
        //  *     y => Short year, eg: 13
        //  *     Y => Full year, eg: 2013
        //  */
        // var formatDate = function(date, formatString) {
        //     var dateString = formatString;
        //
        //     dateString = dateString.replace(/D/g, shortDays[date.getDay()]);
        //
        //     dateString = dateString.replace(/d/g, date.getDate());
        //
        //     dateString = dateString.replace(/m/g, date.getMonth() + 1);
        //
        //     dateString = dateString
        //                  .replace(/M/g, shortMonths[date.getMonth()])
        //                  .replace(/y/g, date.getYear())
        //                  .replace(/Y/g, date.getFullYear());
        //
        //     return dateString;
        // };
        //
        // prepareDatePicker();
        //
        // $picker.find('.leftArrow').on('click', function() {
        //     var newMonth = now.getMonth() - 1,
        //         newYear = now.getFullYear();
        //
        //     if(newMonth < 0) {
        //         newYear --;
        //         newMonth = 11;
        //     }
        //
        //     now = new Date(now.getDate() + ' ' + shortMonths[newMonth] + ' ' + newYear);
        //
        //     prepareDatePicker();
        // });
        //
        // $picker.find('.rightArrow').on('click', function() {
        //     var newMonth = now.getMonth() + 1,
        //         newYear = now.getFullYear();
        //
        //     if(newMonth > 11) {
        //         newYear ++;
        //         newMonth = 0;
        //     }
        //
        //     now = new Date(now.getDate() + ' ' + shortMonths[newMonth] + ' ' + newYear);
        //
        //     prepareDatePicker();
        // });
        //
        // $picker.on('mousedown', function(e) {
        //     e.preventDefault();
        // });
        //
        // $core.on('focus.datepicker', function() {
        //     changeVisibility(true);
        // });
        //
        // $scrollable.on('scroll.datepicker', function() {
        //     reposition();
        // });
        //
        // $core.on('blur.datepicker', function() {
        //     changeVisibility(false);
        // });

  };

  return DatePicker;
});

/**
 * Copyright 2014 Telerik AD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(f, define){
    define('kendo/kendo.slider',[ "./kendo.draganddrop" ], f);
})(function(){

(function($, undefined) {
    var kendo = window.kendo,
        Widget = kendo.ui.Widget,
        Draggable = kendo.ui.Draggable,
        extend = $.extend,
        format = kendo.format,
        parse = kendo.parseFloat,
        proxy = $.proxy,
        isArray = $.isArray,
        math = Math,
        support = kendo.support,
        pointers = support.pointers,
        msPointers = support.msPointers,
        CHANGE = "change",
        SLIDE = "slide",
        NS = ".slider",
        MOUSE_DOWN = "touchstart" + NS + " mousedown" + NS,
        TRACK_MOUSE_DOWN = pointers ? "pointerdown" + NS : (msPointers ? "MSPointerDown" + NS : MOUSE_DOWN),
        MOUSE_UP = "touchend" + NS + " mouseup" + NS,
        TRACK_MOUSE_UP = pointers ? "pointerup" : (msPointers ? "MSPointerUp" + NS : MOUSE_UP),
        MOVE_SELECTION = "moveSelection",
        KEY_DOWN = "keydown" + NS,
        CLICK = "click" + NS,
        MOUSE_OVER = "mouseover" + NS,
        FOCUS = "focus" + NS,
        BLUR = "blur" + NS,
        DRAG_HANDLE = ".k-draghandle",
        TRACK_SELECTOR = ".k-slider-track",
        TICK_SELECTOR = ".k-tick",
        STATE_SELECTED = "k-state-selected",
        STATE_FOCUSED = "k-state-focused",
        STATE_DEFAULT = "k-state-default",
        STATE_DISABLED = "k-state-disabled",
        PRECISION = 3,
        DISABLED = "disabled",
        UNDEFINED = "undefined",
        TABINDEX = "tabindex",
        getTouches = kendo.getTouches;

    var SliderBase = Widget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            options = that.options;

            that._distance = options.max - options.min;
            that._isHorizontal = options.orientation == "horizontal";
            that._isRtl = that._isHorizontal && kendo.support.isRtl(element);
            that._position = that._isHorizontal ? "left" : "bottom";
            that._sizeFn = that._isHorizontal ? "width" : "height";
            that._outerSize = that._isHorizontal ? "outerWidth" : "outerHeight";

            options.tooltip.format = options.tooltip.enabled ? options.tooltip.format || "{0}" : "{0}";

            that._createHtml();
            that.wrapper = that.element.closest(".k-slider");
            that._trackDiv = that.wrapper.find(TRACK_SELECTOR);
            that._sliderBarAdjust = that.wrapper.find('.sliderBarAdjust');

            that._setTrackDivWidth();

            that._maxSelection = that._trackDiv[that._sizeFn]();

            that._sliderItemsInit();

            that._tabindex(that.wrapper.find(DRAG_HANDLE));
            that[options.enabled ? "enable" : "disable"]();

            var rtlDirectionSign = kendo.support.isRtl(that.wrapper) ? -1 : 1;

            that._keyMap = {
                37: step(-1 * rtlDirectionSign * options.smallStep), // left arrow
                40: step(-options.smallStep), // down arrow
                39: step(+1 * rtlDirectionSign * options.smallStep), // right arrow
                38: step(+options.smallStep), // up arrow
                35: setValue(options.max), // end
                36: setValue(options.min), // home
                33: step(+options.largeStep), // page up
                34: step(-options.largeStep)  // page down
            };

            kendo.notify(that);
        },

        events: [
            CHANGE,
            SLIDE
        ],

        options: {
            enabled: true,
            min: 0,
            max: 10,
            smallStep: 1,
            largeStep: 5,
            orientation: "horizontal",
            tickPlacement: "both",
            tooltip: { enabled: true, format: "{0}" }
        },

        _resize: function() {
            this._setTrackDivWidth();
            this.wrapper.find(".k-slider-items").remove();

            this._maxSelection = this._trackDiv[this._sizeFn]();
            this._sliderItemsInit();
            this._refresh();
        },

        _sliderItemsInit: function() {
            var that = this,
                options = that.options;

            var sizeBetweenTicks = that._maxSelection / ((options.max - options.min) / options.smallStep);
            var pixelWidths = that._calculateItemsWidth(math.floor(that._distance / options.smallStep));

            if (options.tickPlacement != "none" && sizeBetweenTicks >= 2) {
                that._trackDiv.before(createSliderItems(options, that._distance));
                that._setItemsWidth(pixelWidths);
                that._setItemsTitle();
            }

            that._calculateSteps(pixelWidths);

            if (options.tickPlacement != "none" && sizeBetweenTicks >= 2 &&
                options.largeStep >= options.smallStep) {
                that._setItemsLargeTick();
            }
        },

        getSize: function() {
            return kendo.dimensions(this.wrapper);
        },

        _setTrackDivWidth: function() {
            var that = this,
                trackDivPosition = parseFloat(that._trackDiv.css(that._isRtl ? "right" : that._position), 10) * 2;

            that._trackDiv[that._sizeFn]((that.wrapper[that._sizeFn]() - 4) - trackDivPosition - 0);
            that._sliderBarAdjust.width(that._trackDiv.width() + 24);
        },

        _setItemsWidth: function(pixelWidths) {
            var that = this,
                options = that.options,
                first = 0,
                last = pixelWidths.length - 1,
                items = that.wrapper.find(TICK_SELECTOR),
                i,
                paddingTop = 0,
                bordersWidth = 2,
                count = items.length,
                selection = 0;

            for (i = 0; i < count - 2; i++) {
                $(items[i + 1])[that._sizeFn](pixelWidths[i]);
            }

            if (that._isHorizontal) {
                $(items[first]).addClass("k-first")[that._sizeFn](pixelWidths[last - 1]);
                $(items[last]).addClass("k-last")[that._sizeFn](pixelWidths[last]);
            } else {
                $(items[last]).addClass("k-first")[that._sizeFn](pixelWidths[last]);
                $(items[first]).addClass("k-last")[that._sizeFn](pixelWidths[last - 1]);
            }

            if (that._distance % options.smallStep !== 0 && !that._isHorizontal) {
                for (i = 0; i < pixelWidths.length; i++) {
                    selection += pixelWidths[i];
                }

                paddingTop = that._maxSelection - selection;
                paddingTop += parseFloat(that._trackDiv.css(that._position), 10) + bordersWidth;

                that.wrapper.find(".k-slider-items").css("padding-top", paddingTop);
            }
        },

        _setItemsTitle: function() {
            var that = this,
                options = that.options,
                items = that.wrapper.find(TICK_SELECTOR),
                titleNumber = options.min,
                count = items.length,
                i = that._isHorizontal && !that._isRtl ? 0 : count - 1,
                limit = that._isHorizontal && !that._isRtl ? count : -1,
                increment = that._isHorizontal && !that._isRtl ? 1 : -1;

            for (; i - limit !== 0 ; i += increment) {
                $(items[i]).attr("title", format(options.tooltip.format, round(titleNumber)));
                titleNumber += options.smallStep;
            }
        },

        _setItemsLargeTick: function() {
            var that = this,
                options = that.options,
                items = that.wrapper.find(TICK_SELECTOR),
                i = 0, item, value;

            if ((1000 * options.largeStep) % (1000 * options.smallStep) === 0 || that._distance / options.largeStep >= 3) {
                if (that._isHorizontal && !that._isRtl) {
                    items = $.makeArray(items).reverse();
                }

                for (i = 0; i < items.length; i++) {
                    item = $(items[i]);
                    value = that._values[i];
                    if (value % options.smallStep === 0 && value % options.largeStep === 0) {
                        item.addClass("k-tick-large")
                            .html("<span class='k-label'>" + item.attr("title") + "</span>");

                        if (i !== 0 && i !== items.length - 1) {
                            item.css("line-height", item[that._sizeFn]() + "px");
                        }
                    }
                }
            }
        },

        _calculateItemsWidth: function(itemsCount) {
            var that = this,
                options = that.options,
                trackDivSize = parseFloat(that._trackDiv.css(that._sizeFn)) + 1,
                pixelStep = trackDivSize / that._distance,
                itemWidth,
                pixelWidths,
                i;

            if ((that._distance / options.smallStep) - math.floor(that._distance / options.smallStep) > 0) {
                trackDivSize -= ((that._distance % options.smallStep) * pixelStep);
            }

            itemWidth = trackDivSize / itemsCount;
            pixelWidths = [];

            for (i = 0; i < itemsCount - 1; i++) {
                pixelWidths[i] = itemWidth;
            }

            pixelWidths[itemsCount - 1] = pixelWidths[itemsCount] = itemWidth / 2;
            return that._roundWidths(pixelWidths);
        },

        _roundWidths: function(pixelWidthsArray) {
            var balance = 0,
                count = pixelWidthsArray.length,
                i;

            for (i = 0; i < count; i++) {
                balance += (pixelWidthsArray[i] - math.floor(pixelWidthsArray[i]));
                pixelWidthsArray[i] = math.floor(pixelWidthsArray[i]);
            }

            balance = math.round(balance);

            return this._addAdditionalSize(balance, pixelWidthsArray);
        },

        _addAdditionalSize: function(additionalSize, pixelWidthsArray) {
            if (additionalSize === 0) {
                return pixelWidthsArray;
            }

            //set step size
            var step = parseFloat(pixelWidthsArray.length - 1) / parseFloat(additionalSize == 1 ? additionalSize : additionalSize - 1),
                i;

            for (i = 0; i < additionalSize; i++) {
                pixelWidthsArray[parseInt(math.round(step * i), 10)] += 1;
            }

            return pixelWidthsArray;
        },

        _calculateSteps: function(pixelWidths) {
            var that = this,
                options = that.options,
                val = options.min,
                selection = 0,
                itemsCount = math.ceil(that._distance / options.smallStep),
                i = 1,
                lastItem;

            itemsCount += (that._distance / options.smallStep) % 1 === 0 ? 1 : 0;
            pixelWidths.splice(0, 0, pixelWidths[itemsCount - 2] * 2);
            pixelWidths.splice(itemsCount -1, 1, pixelWidths.pop() * 2);

            that._pixelSteps = [selection];
            that._values = [val];

            if (itemsCount === 0) {
                return;
            }

            while (i < itemsCount) {
                selection += (pixelWidths[i - 1] + pixelWidths[i]) / 2;
                that._pixelSteps[i] = selection;
                that._values[i] = val += options.smallStep;

                i++;
            }

            lastItem = that._distance % options.smallStep === 0 ? itemsCount - 1 : itemsCount;

            that._pixelSteps[lastItem] = that._maxSelection;
            that._values[lastItem] = options.max;

            if (that._isRtl) {
                that._pixelSteps.reverse();
                that._values.reverse();
            }
        },

        _getValueFromPosition: function(mousePosition, dragableArea) {
            var that = this,
                options = that.options,
                step = math.max(options.smallStep * (that._maxSelection / that._distance), 0),
                position = 0,
                halfStep = (step / 2),
                i;

            if (that._isHorizontal) {
                position = mousePosition - dragableArea.startPoint;
                if (that._isRtl) {
                    position = that._maxSelection - position;
                }
            } else {
                position = dragableArea.startPoint - mousePosition;
            }

            if (that._maxSelection - ((parseInt(that._maxSelection % step, 10) - 3) / 2) < position) {
                return options.max;
            }

            for (i = 0; i < that._pixelSteps.length; i++) {
                if (math.abs(that._pixelSteps[i] - position) - 1 <= halfStep) {
                    return round(that._values[i]);
                }
            }
        },

        _getFormattedValue: function(val, drag) {
            var that = this,
                html = "",
                tooltip = that.options.tooltip,
                tooltipTemplate,
                selectionStart,
                selectionEnd;

            if (isArray(val)) {
                selectionStart = val[0];
                selectionEnd = val[1];
            } else if (drag && drag.type) {
                selectionStart = drag.selectionStart;
                selectionEnd = drag.selectionEnd;
            }

            if (drag) {
                tooltipTemplate = drag.tooltipTemplate;
            }

            if (!tooltipTemplate && tooltip.template) {
                tooltipTemplate = kendo.template(tooltip.template);
            }

            if (isArray(val) || (drag && drag.type)) {

                if (tooltipTemplate) {
                    html = tooltipTemplate({
                        selectionStart: selectionStart,
                        selectionEnd: selectionEnd
                    });
                } else {
                    selectionStart = format(tooltip.format, selectionStart);
                    selectionEnd = format(tooltip.format, selectionEnd);
                    html = selectionStart + " - " + selectionEnd;
                }
            } else {
                if (drag) {
                    drag.val = val;
                }

                if (tooltipTemplate) {
                    html = tooltipTemplate({
                        value: val
                    });
                } else {
                    html = format(tooltip.format, val);
                }
            }
            return html;
        },

        _getDraggableArea: function() {
            var that = this,
                offset = kendo.getOffset(that._trackDiv);

            return {
                startPoint: that._isHorizontal ? offset.left : offset.top + that._maxSelection,
                endPoint: that._isHorizontal ? offset.left + that._maxSelection : offset.top
            };
        },

        _createHtml: function() {
            var that = this,
                element = that.element,
                options = that.options,
                inputs = element.find("input");

            if (inputs.length == 2) {
                inputs.eq(0).val(options.selectionStart);
                inputs.eq(1).val(options.selectionEnd);
            } else {
                element.val(options.value);
            }

            element.wrap(createWrapper(options, element, that._isHorizontal)).hide();

            if (options.showButtons) {
                element.before(createButton(options, "increase", that._isHorizontal))
                       .before(createButton(options, "decrease", that._isHorizontal));
            }

            element.before(createTrack(options, element));
        },

        _focus: function(e) {
            var that = this,
                target = e.target,
                val = that.value(),
                drag = that._drag;

            if (!drag) {
                if (target == that.wrapper.find(DRAG_HANDLE).eq(0)[0]) {
                    drag = that._firstHandleDrag;
                    that._activeHandle = 0;
                } else {
                    drag = that._lastHandleDrag;
                    that._activeHandle = 1;
                }
                val = val[that._activeHandle];
            }

            // $(target).addClass(STATE_FOCUSED + " " + STATE_SELECTED);

            if (drag) {
                that._activeHandleDrag = drag;

                drag.selectionStart = that.options.selectionStart;
                drag.selectionEnd = that.options.selectionEnd;

                drag._updateTooltip(val);
            }
        },

        _focusWithMouse: function(target) {
            target = $(target);

            var that = this,
                idx = target.is(DRAG_HANDLE) ? target.index() : 0;

            window.setTimeout(function(){
                that.wrapper.find(DRAG_HANDLE)[idx == 2 ? 1 : 0].focus();
            }, 1);

            that._setTooltipTimeout();
        },

        _blur: function(e) {
            var that = this,
                drag = that._activeHandleDrag;

            $(e.target).removeClass(STATE_FOCUSED + " " + STATE_SELECTED);

            if (drag) {
                drag._removeTooltip();
                delete that._activeHandleDrag;
                delete that._activeHandle;
            }
        },

        _setTooltipTimeout: function() {
            var that = this;
            that._tooltipTimeout = window.setTimeout(function(){
                var drag = that._drag || that._activeHandleDrag;
                if (drag) {
                    drag._removeTooltip();
                }
            }, 300);
        },

        _clearTooltipTimeout: function() {
            var that = this;
            window.clearTimeout(this._tooltipTimeout);
            var drag = that._drag || that._activeHandleDrag;
            if (drag && drag.tooltipDiv) {
                drag.tooltipDiv.stop(true, false).css("opacity", 1);
            }
        }
    });

    function createWrapper (options, element, isHorizontal) {
        var orientationCssClass = isHorizontal ? " k-slider-horizontal" : " k-slider-vertical",
            style = options.style ? options.style : element.attr("style"),
            cssClasses = element.attr("class") ? (" " + element.attr("class")) : "",
            tickPlacementCssClass = "";

        if (options.tickPlacement == "bottomRight") {
            tickPlacementCssClass = " k-slider-bottomright";
        } else if (options.tickPlacement == "topLeft") {
            tickPlacementCssClass = " k-slider-topleft";
        }

        style = style ? " style='" + style + "'" : "";

        return "<div class='k-widget k-slider" + orientationCssClass + cssClasses + "'" + style + ">" +
               "<div class='k-slider-wrap" + (options.showButtons ? " k-slider-buttons" : "") + tickPlacementCssClass +
               "'></div></div>";
    }

    function createButton (options, type, isHorizontal) {
        var buttonCssClass = "";

        if (type == "increase") {
            buttonCssClass = isHorizontal ? "k-i-arrow-e" : "k-i-arrow-n";
        } else {
            buttonCssClass = isHorizontal ? "k-i-arrow-w" : "k-i-arrow-s";
        }

        return "<a class='k-button k-button-" + type + "'><span class='k-icon " + buttonCssClass +
               "' title='" + options[type + "ButtonTitle"] + "'>" + options[type + "ButtonTitle"] + "</span></a>";
    }

    function createSliderItems (options, distance) {
        var result = "<ul class='k-reset k-slider-items'>",
            count = math.floor(round(distance / options.smallStep)) + 1,
            i;

        for(i = 0; i < count; i++) {
            result += "<li class='k-tick' role='presentation'>&nbsp;</li>";
        }

        result += "</ul>";

        return result;
    }

    function createTrack (options, element) {
        var dragHandleCount = element.is("input") ? 1 : 2,
            firstDragHandleTitle = dragHandleCount == 2 ? options.leftDragHandleTitle : options.dragHandleTitle;


        return "<div class='sliderBarAdjust'></div><div class='k-slider-track'><div class='k-slider-selection'><!-- --></div>" +
               "<a href='#' class='k-draghandle' title='" + firstDragHandleTitle + "' role='slider' aria-valuemin='" + options.min + "' aria-valuemax='" + options.max + "' aria-valuenow='" + (dragHandleCount > 1 ? (options.selectionStart || options.min) : options.value || options.min) + "'>Drag</a>" +
               (dragHandleCount > 1 ? "<a href='#' class='k-draghandle' title='" + options.rightDragHandleTitle + "'role='slider' aria-valuemin='" + options.min + "' aria-valuemax='" + options.max + "' aria-valuenow='" + (options.selectionEnd || options.max) + "'>Drag</a>" : "") +
               "</div>";
    }

    function step(stepValue) {
        return function (value) {
            return value + stepValue;
        };
    }

    function setValue(value) {
        return function () {
            return value;
        };
    }

    function formatValue(value) {
        return (value + "").replace(".", kendo.cultures.current.numberFormat["."]);
    }

    function round(value) {
        value = parseFloat(value, 10);
        var power = math.pow(10, PRECISION || 0);
        return math.round(value * power) / power;
    }

    function parseAttr(element, name) {
        var value = parse(element.getAttribute(name));
        if (value === null) {
            value = undefined;
        }
        return value;
    }

    function defined(value) {
        return typeof value !== UNDEFINED;
    }

    var Slider = SliderBase.extend({
        init: function(element, options) {
            var that = this,
                dragHandle;

            element.type = "text";
            options = extend({}, {
                value: parseAttr(element, "value"),
                min: parseAttr(element, "min"),
                max: parseAttr(element, "max"),
                smallStep: parseAttr(element, "step")
            }, options);

            element = $(element);

            if (options && options.enabled === undefined) {
                options.enabled = !element.is("[disabled]");
            }

            SliderBase.fn.init.call(that, element, options);
            options = that.options;
            if (!defined(options.value) || options.value === null) {
                options.value = options.min;
                element.val(options.min);
            }
            options.value = math.max(math.min(options.value, options.max), options.min);

            dragHandle = that.wrapper.find(DRAG_HANDLE);

            new Slider.Selection(dragHandle, that, options);
            that._drag = new Slider.Drag(dragHandle, "", that, options);
        },

        options: {
            name: "Slider",
            showButtons: true,
            increaseButtonTitle: "Increase",
            decreaseButtonTitle: "Decrease",
            dragHandleTitle: "drag",
            tooltip: { format: "{0:#,#.##}" },
            value: null
        },

        enable: function (enable) {
            var that = this,
                options = that.options,
                clickHandler,
                move;

            that.disable();
            if (enable === false) {
                return;
            }

            that.wrapper
                .removeClass(STATE_DISABLED)
                .addClass(STATE_DEFAULT);

            that.wrapper.find("input").removeAttr(DISABLED);

            clickHandler = function (e) {
                var touch = getTouches(e)[0];

                if (!touch) {
                    return;
                }

                var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY,
                    dragableArea = that._getDraggableArea(),
                    target = $(e.target);

                if (target.hasClass("k-draghandle")) {
                    // target.addClass(STATE_FOCUSED + " " + STATE_SELECTED);
                    return;
                }

                that._update(that._getValueFromPosition(mousePosition, dragableArea));

                that._focusWithMouse(e.target);

                that._drag.dragstart(e);
                e.preventDefault();
            };

            that.wrapper
                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR)
                    .on(TRACK_MOUSE_DOWN, clickHandler)
                    .end()
                    .on(TRACK_MOUSE_DOWN, function() {
                        $(document.documentElement).one("selectstart", kendo.preventDefault);
                    })
                    .on(TRACK_MOUSE_UP, function() {
                        that._drag._end();
                    });

            that.wrapper
                .find(DRAG_HANDLE)
                .attr(TABINDEX, 0)
                .on(MOUSE_UP, function () {
                    that._setTooltipTimeout();
                })
                .on(CLICK, function (e) {
                    that._focusWithMouse(e.target);
                    e.preventDefault();
                })
                .on(FOCUS, proxy(that._focus, that))
                .on(BLUR, proxy(that._blur, that));

            move = proxy(function (sign) {
                var newVal = that._nextValueByIndex(that._valueIndex + (sign * 1));
                that._setValueInRange(newVal);
                that._drag._updateTooltip(newVal);
            }, that);

            if (options.showButtons) {
                var mouseDownHandler = proxy(function(e, sign) {
                    this._clearTooltipTimeout();
                    if (e.which === 1 || (support.touch && e.which === 0)) {
                        move(sign);

                        this.timeout = setTimeout(proxy(function () {
                            this.timer = setInterval(function () {
                                move(sign);
                            }, 60);
                        }, this), 200);
                    }
                }, that);

                that.wrapper.find(".k-button")
                    .on(MOUSE_UP, proxy(function (e) {
                        this._clearTimer();
                        that._focusWithMouse(e.target);
                    }, that))
                    .on(MOUSE_OVER, function (e) {
                        $(e.currentTarget). addClass("k-state-hover");
                    })
                    .on("mouseout" + NS, proxy(function (e) {
                        $(e.currentTarget).removeClass("k-state-hover");
                        this._clearTimer();
                    }, that))
                    .eq(0)
                    .on(MOUSE_DOWN, proxy(function (e) {
                        mouseDownHandler(e, 1);
                    }, that))
                    .click(false)
                    .end()
                    .eq(1)
                    .on(MOUSE_DOWN, proxy(function (e) {
                        mouseDownHandler(e, -1);
                    }, that))
                    .click(kendo.preventDefault);
            }

            that.wrapper
                .find(DRAG_HANDLE)
                .off(KEY_DOWN, false)
                .on(KEY_DOWN, proxy(this._keydown, that));

            options.enabled = true;
        },

        disable: function () {
            var that = this;

            that.wrapper
                .removeClass(STATE_DEFAULT)
                .addClass(STATE_DISABLED);

            $(that.element).prop(DISABLED, DISABLED);

            that.wrapper
                .find(".k-button")
                .off(MOUSE_DOWN)
                .on(MOUSE_DOWN, kendo.preventDefault)
                .off(MOUSE_UP)
                .on(MOUSE_UP, kendo.preventDefault)
                .off("mouseleave" + NS)
                .on("mouseleave" + NS, kendo.preventDefault)
                .off(MOUSE_OVER)
                .on(MOUSE_OVER, kendo.preventDefault);

            that.wrapper
                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);

            that.wrapper
                .find(DRAG_HANDLE)
                .attr(TABINDEX, -1)
                .off(MOUSE_UP)
                .off(KEY_DOWN)
                .off(CLICK)
                .off(FOCUS)
                .off(BLUR);

            that.options.enabled = false;
        },

        _update: function (val) {
            var that = this,
                change = that.value() != val;

            that.value(val);

            if (change) {
                that.trigger(CHANGE, { value: that.options.value });
            }
        },

        value: function (value) {
            var that = this,
                options = that.options;

            value = round(value);
            if (isNaN(value)) {
                return options.value;
            }

            if (value >= options.min && value <= options.max) {
                if (options.value != value) {
                    that.element.prop("value", formatValue(value));
                    options.value = value;
                    that._refreshAriaAttr(value);
                    that._refresh();
                }
            }
        },

        _refresh: function () {
            this.trigger(MOVE_SELECTION, { value: this.options.value });
        },

        _refreshAriaAttr: function(value) {
            var that = this,
                drag = that._drag,
                formattedValue;

            if (drag && drag._tooltipDiv) {
                formattedValue = drag._tooltipDiv.text();
            } else {
                formattedValue = that._getFormattedValue(value, null);
            }
            this.wrapper.find(DRAG_HANDLE).attr("aria-valuenow", value).attr("aria-valuetext", formattedValue);
        },

        _clearTimer: function () {
            clearTimeout(this.timeout);
            clearInterval(this.timer);
        },

        _keydown: function (e) {
            var that = this;

            if (e.keyCode in that._keyMap) {
                that._clearTooltipTimeout();
                that._setValueInRange(that._keyMap[e.keyCode](that.options.value));
                that._drag._updateTooltip(that.value());
                e.preventDefault();
            }
        },

        _setValueInRange: function (val) {
            var that = this,
                options = that.options;

            val = round(val);
            if (isNaN(val)) {
                that._update(options.min);
                return;
            }

            val = math.max(math.min(val, options.max), options.min);
            that._update(val);
        },

        _nextValueByIndex: function (index) {
            var count = this._values.length;
            if (this._isRtl) {
                index = count - 1 - index;
            }
            return this._values[math.max(0, math.min(index, count - 1))];
        },

        destroy: function() {
            var that = this;

            Widget.fn.destroy.call(that);

            that.wrapper.off(NS)
                .find(".k-button").off(NS)
                .end()
                .find(DRAG_HANDLE).off(NS)
                .end()
                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(NS)
                .end();

            that._drag.draggable.destroy();
            that._drag._removeTooltip(true);
        }
    });

    Slider.Selection = function (dragHandle, that, options) {
        function moveSelection (val) {
            var selectionValue = val - options.min,
                index = that._valueIndex = math.ceil(round(selectionValue / options.smallStep)),
                selection = parseInt(that._pixelSteps[index], 10),
                selectionDiv = that._trackDiv.find(".k-slider-selection"),
                halfDragHanndle = parseInt(dragHandle[that._outerSize]() / 2, 10),
                rtlCorrection = that._isRtl ? 2 : 0;

            selectionDiv[that._sizeFn](that._isRtl ? that._maxSelection - selection : selection);
            dragHandle.css(that._position, selection - halfDragHanndle - rtlCorrection);
        }

        moveSelection(options.value);

        that.bind([CHANGE, SLIDE, MOVE_SELECTION], function (e) {
            moveSelection(parseFloat(e.value, 10));
        });
    };

    Slider.Drag = function (element, type, owner, options) {
        var that = this;
        that.owner = owner;
        that.options = options;
        that.element = element;
        that.type = type;

        that.draggable = new Draggable(element, {
            distance: 0,
            dragstart: proxy(that._dragstart, that),
            drag: proxy(that.drag, that),
            dragend: proxy(that.dragend, that),
            dragcancel: proxy(that.dragcancel, that)
        });

        element.click(false);
    };

    Slider.Drag.prototype = {
        dragstart: function(e) {
            // add reference to the last active drag handle.
            this.owner._activeDragHandle = this;
            // HACK to initiate click on the line
            this.draggable.userEvents.cancel();
            this.draggable.userEvents._start(e);
        },

        _dragstart: function(e) {
            var that = this,
                owner = that.owner,
                options = that.options;

            if (!options.enabled) {
                e.preventDefault();
                return;
            }

            // add reference to the last active drag handle.
            this.owner._activeDragHandle = this;

            owner.element.off(MOUSE_OVER);
            that.element.addClass(STATE_FOCUSED + " " + STATE_SELECTED);
            $(document.documentElement).css("cursor", "pointer");

            that.dragableArea = owner._getDraggableArea();
            that.step = math.max(options.smallStep * (owner._maxSelection / owner._distance), 0);

            if (that.type) {
                that.selectionStart = options.selectionStart;
                that.selectionEnd = options.selectionEnd;
                owner._setZIndex(that.type);
            } else {
                that.oldVal = that.val = options.value;
            }

            that._removeTooltip(true);
            that._createTooltip(options.tooltip.tooltipID);
        },

        _createTooltip: function(divElement) {
            var that = this,
                owner = that.owner,
                tooltip = that.options.tooltip,
                html = '',
                wnd = $(window),
                tooltipTemplate, colloutCssClass;

            if (!tooltip.enabled) {
                return;
            }

            if (tooltip.template) {
                tooltipTemplate = that.tooltipTemplate = kendo.template(tooltip.template);
            }

            $(".k-slider-tooltip").remove(); // if user changes window while tooltip is visible, a second one will be created
            that.tooltipDiv = $(divElement).html("<div class='k-slider-tooltip'><!-- --></div>");

            html = owner._getFormattedValue(that.val || owner.value(), that);

            if (!that.type) {
                colloutCssClass = "k-callout-" + (owner._isHorizontal ? 's' : 'e');
                that.tooltipInnerDiv = "<div class='k-callout " + colloutCssClass + "'><!-- --></div>";
                html += that.tooltipInnerDiv;
            }

            that.tooltipDiv.html(html);

            that._scrollOffset = {
                top: wnd.scrollTop(),
                left: wnd.scrollLeft()
            };

            that.moveTooltip();
        },

        drag: function (e) {
            var that = this,
                owner = that.owner,
                x = e.x.location,
                y = e.y.location,
                startPoint = that.dragableArea.startPoint,
                endPoint = that.dragableArea.endPoint,
                slideParams;

            e.preventDefault();

            if (owner._isHorizontal) {
                if (owner._isRtl) {
                    that.val = that.constrainValue(x, startPoint, endPoint, x < endPoint);
                } else {
                    that.val = that.constrainValue(x, startPoint, endPoint, x >= endPoint);
                }
            } else {
                that.val = that.constrainValue(y, endPoint, startPoint, y <= endPoint);
            }

            if (that.oldVal != that.val) {
                that.oldVal = that.val;

                if (that.type) {
                    if (that.type == "firstHandle") {
                        if (that.val < that.selectionEnd) {
                            that.selectionStart = that.val;
                        } else {
                            that.selectionStart = that.selectionEnd = that.val;
                        }
                    } else {
                        if (that.val > that.selectionStart) {
                            that.selectionEnd = that.val;
                        } else {
                            that.selectionStart = that.selectionEnd = that.val;
                        }
                    }
                    slideParams = {
                        values: [that.selectionStart, that.selectionEnd],
                        value: [that.selectionStart, that.selectionEnd]
                    };
                } else {
                    slideParams = { value: that.val };
                }

                owner.trigger(SLIDE, slideParams);
            }

            that._updateTooltip(that.val);
        },

        _updateTooltip: function(val) {
            var that = this,
                options = that.options,
                tooltip = options.tooltip,
                html = "";

            if (!tooltip.enabled) {
                return;
            }

            if (!that.tooltipDiv) {
                // that._createTooltip("rfNumericRangeText-units");
            }

            html = that.owner._getFormattedValue(round(val), that);

            if (!that.type) {
                html += that.tooltipInnerDiv;
            }

            if(that.tooltipDiv) {
                that.tooltipDiv.html(html);
                that.moveTooltip();
            }
        },

        dragcancel: function() {
            this.owner._refresh();
            $(document.documentElement).css("cursor", "");
            return this._end();
        },

        dragend: function() {
            var that = this,
                owner = that.owner;

            $(document.documentElement).css("cursor", "");

            if (that.type) {
                owner._update(that.selectionStart, that.selectionEnd);
            } else {
                owner._update(that.val);
                that.draggable.userEvents._disposeAll();
            }

            that.element.removeClass(STATE_SELECTED + " " + STATE_FOCUSED);

            return that._end();
        },

        _end: function() {
            var that = this,
                owner = that.owner;

            owner._focusWithMouse(that.element);

            owner.element.on(MOUSE_OVER);

            return false;
        },

        _removeTooltip: function(noAnimation) {
            // var that = this,
            //     owner = that.owner;
            //
            // if (that.tooltipDiv && owner.options.tooltip.enabled && owner.options.enabled) {
            //     if (noAnimation) {
            //         // that.tooltipDiv.remove();
            //         that.tooltipDiv = null;
            //     } else {
            //         that.tooltipDiv.fadeOut("slow", function(){
            //             // $(this).remove();
            //             that.tooltipDiv = null;
            //         });
            //     }
            // }
        },

        moveTooltip: function () {
            var that = this,
                owner = that.owner,
                top = 0,
                left = 0,
                element = that.element,
                offset = kendo.getOffset(element),
                margin = 8,
                viewport = $(window),
                callout = that.tooltipDiv.find(".k-callout"),
                width = that.tooltipDiv.outerWidth(),
                height = that.tooltipDiv.outerHeight(),
                dragHandles, sdhOffset, diff, anchorSize;

            if (that.type) {
                dragHandles = owner.wrapper.find(DRAG_HANDLE);
                offset = kendo.getOffset(dragHandles.eq(0));
                sdhOffset = kendo.getOffset(dragHandles.eq(1));

                if (owner._isHorizontal) {
                    top = sdhOffset.top;
                    left = offset.left + ((sdhOffset.left - offset.left) / 2) + 10;
                } else {
                    top = offset.top + ((sdhOffset.top - offset.top) / 2);
                    left = sdhOffset.left;
                }

                anchorSize = dragHandles.eq(0).outerWidth() + 2 * margin;
            } else {
                top = offset.top;
                left = offset.left;
                anchorSize = element.outerWidth() + 2 * margin;
            }

            if (owner._isHorizontal) {
                left -= parseInt((width - element[owner._outerSize]()) / 2, 10);
                top -= height + callout.height() + margin;
            } else {
                top -= parseInt((height - element[owner._outerSize]()) / 2, 10);
                left -= width + callout.width() + margin;
            }

            if (owner._isHorizontal) {
                diff = that._flip(top, height, anchorSize, viewport.outerHeight() + that._scrollOffset.top);
                top += diff;
                left += that._fit(left, width, viewport.outerWidth() + that._scrollOffset.left);
            } else {
                diff = that._flip(left, width, anchorSize, viewport.outerWidth() + that._scrollOffset.left);
                top += that._fit(top, height, viewport.outerHeight() + that._scrollOffset.top);
                left += diff;
            }

            if (diff > 0 && callout) {
                callout.removeClass();
                callout.addClass("k-callout k-callout-" + (owner._isHorizontal ? "n" : "w"));
            }

            that.tooltipDiv.css({ top: top, left: left });
        },

        _fit: function(position, size, viewPortEnd) {
            var output = 0;

            if (position + size > viewPortEnd) {
                output = viewPortEnd - (position + size);
            }

            if (position < 0) {
                output = -position;
            }

            return output;
        },

        _flip: function(offset, size, anchorSize, viewPortEnd) {
            var output = 0;

            if (offset + size > viewPortEnd) {
                output += -(anchorSize + size);
            }

            if (offset + output < 0) {
                output += anchorSize + size;
            }

            return output;
        },

        constrainValue: function (position, min, max, maxOverflow) {
            var that = this,
                val = 0;

            if (min < position && position < max) {
                val = that.owner._getValueFromPosition(position, that.dragableArea);
            } else {
                if (maxOverflow ) {
                    val = that.options.max;
                } else {
                    val = that.options.min;
                }
            }

            return val;
        }

    };

    kendo.ui.plugin(Slider);

    var RangeSlider = SliderBase.extend({
        init: function(element, options) {
            var that = this,
                inputs = $(element).find("input"),
                firstInput = inputs.eq(0)[0],
                secondInput = inputs.eq(1)[0];

            firstInput.type = "text";
            secondInput.type = "text";

            options = extend({}, {
                selectionStart: parseAttr(firstInput, "value"),
                min: parseAttr(firstInput, "min"),
                max: parseAttr(firstInput, "max"),
                smallStep: parseAttr(firstInput, "step")
            }, {
                selectionEnd: parseAttr(secondInput, "value"),
                min: parseAttr(secondInput, "min"),
                max: parseAttr(secondInput, "max"),
                smallStep: parseAttr(secondInput, "step")
            }, options);

            if (options && options.enabled === undefined) {
                options.enabled = !inputs.is("[disabled]");
            }

            SliderBase.fn.init.call(that, element, options);
            options = that.options;
            if (!defined(options.selectionStart) || options.selectionStart === null) {
                options.selectionStart = options.min;
                inputs.eq(0).val(options.min);
            }

            if (!defined(options.selectionEnd) || options.selectionEnd === null) {
                options.selectionEnd = options.max;
                inputs.eq(1).val(options.max);
            }

            var dragHandles = that.wrapper.find(DRAG_HANDLE);

            new RangeSlider.Selection(dragHandles, that, options);
            that._firstHandleDrag = new Slider.Drag(dragHandles.eq(0), "firstHandle", that, options);
            that._lastHandleDrag = new Slider.Drag(dragHandles.eq(1), "lastHandle" , that, options);
            // that._firstHandleDrag._createTooltip();
            // that._lastHandleDrag._createTooltip();
        },

        options: {
            name: "RangeSlider",
            leftDragHandleTitle: "drag",
            rightDragHandleTitle: "drag",
            tooltip: { format: "{0:#,#.##}" },
            selectionStart: null,
            selectionEnd: null
        },

        enable: function (enable) {
            var that = this,
                options = that.options,
                clickHandler;

            that.disable();
            if (enable === false) {
                return;
            }

            that.wrapper
                .removeClass(STATE_DISABLED)
                .addClass(STATE_DEFAULT);

            that.wrapper.find("input").removeAttr(DISABLED);

            clickHandler = function (e) {
                var touch = getTouches(e)[0];

                if (!touch) {
                    return;
                }

                var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY,
                    dragableArea = that._getDraggableArea(),
                    val = that._getValueFromPosition(mousePosition, dragableArea),
                    target = $(e.target),
                    from, to, drag;

                if (target.hasClass("k-draghandle")) {
                    target.addClass(STATE_FOCUSED + " " + STATE_SELECTED);
                    return;
                }

                if (val < options.selectionStart) {
                    from = val;
                    to = options.selectionEnd;
                    drag = that._firstHandleDrag;
                } else if (val > that.selectionEnd) {
                    from = options.selectionStart;
                    to = val;
                    drag = that._lastHandleDrag;
                } else {
                    if (val - options.selectionStart <= options.selectionEnd - val) {
                        from = val;
                        to = options.selectionEnd;
                        drag = that._firstHandleDrag;
                    } else {
                        from = options.selectionStart;
                        to = val;
                        drag = that._lastHandleDrag;
                    }
                }

                drag.dragstart(e);
                that._setValueInRange(from, to);
                that._focusWithMouse(drag.element);
            };

            that.wrapper
                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR)
                    .on(TRACK_MOUSE_DOWN, clickHandler)
                    .end()
                    .on(TRACK_MOUSE_DOWN, function() {
                        $(document.documentElement).one("selectstart", kendo.preventDefault);
                    })
                    .on(TRACK_MOUSE_UP, function() {
                    });

            that.wrapper
                .find(DRAG_HANDLE)
                .attr(TABINDEX, 0)
                .on(MOUSE_UP, function () {
                    that._setTooltipTimeout();
                })
                .on(CLICK, function (e) {
                    that._focusWithMouse(e.target);
                    e.preventDefault();
                })
                .on(TRACK_MOUSE_UP, function() {
                    that._activeDragHandle.element
                    .removeClass(STATE_SELECTED + " " + STATE_FOCUSED)
                })
                .on(FOCUS, proxy(that._focus, that))
                .on(BLUR, proxy(that._blur, that))

            that.wrapper.find(DRAG_HANDLE)
                .off(KEY_DOWN, kendo.preventDefault)
                .eq(0).on(KEY_DOWN,
                    proxy(function(e) {
                        this._keydown(e, "firstHandle");
                    }, that)
                )
                .end()
                .eq(1).on(KEY_DOWN,
                    proxy(function(e) {
                        this._keydown(e, "lastHandle");
                    }, that)
                );

            that.options.enabled = true;
        },

        disable: function () {
            var that = this;

            that.wrapper
                .removeClass(STATE_DEFAULT)
                .addClass(STATE_DISABLED);

            that.wrapper.find("input").prop(DISABLED, DISABLED);

            that.wrapper
                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);

            that.wrapper
                .find(DRAG_HANDLE)
                .attr(TABINDEX, -1)
                .off(MOUSE_UP)
                .off(KEY_DOWN)
                .off(CLICK)
                .off(FOCUS)
                .off(BLUR);

            that.options.enabled = false;
        },

        _keydown: function (e, handle) {
            var that = this,
                selectionStartValue = that.options.selectionStart,
                selectionEndValue = that.options.selectionEnd,
                dragSelectionStart,
                dragSelectionEnd,
                activeHandleDrag;

            if (e.keyCode in that._keyMap) {

                that._clearTooltipTimeout();

                if (handle == "firstHandle") {
                    activeHandleDrag = that._activeHandleDrag = that._firstHandleDrag;
                    selectionStartValue = that._keyMap[e.keyCode](selectionStartValue);

                    if (selectionStartValue > selectionEndValue) {
                        selectionEndValue = selectionStartValue;
                    }
                } else {
                    activeHandleDrag = that._activeHandleDrag = that._lastHandleDrag;
                    selectionEndValue = that._keyMap[e.keyCode](selectionEndValue);

                    if (selectionStartValue > selectionEndValue) {
                        selectionStartValue = selectionEndValue;
                    }
                }

                that._setValueInRange(selectionStartValue, selectionEndValue);

                dragSelectionStart = Math.max(selectionStartValue, that.options.selectionStart);
                dragSelectionEnd = Math.min(selectionEndValue, that.options.selectionEnd);

                activeHandleDrag.selectionEnd = Math.max(dragSelectionEnd, that.options.selectionStart);
                activeHandleDrag.selectionStart = Math.min(dragSelectionStart, that.options.selectionEnd);

                activeHandleDrag._updateTooltip(that.value()[that._activeHandle]);

                e.preventDefault();
            }
        },

        _update: function (selectionStart, selectionEnd) {
            var that = this,
                values = that.value();

            var change = values[0] != selectionStart || values[1] != selectionEnd;

            that.value([selectionStart, selectionEnd]);

            if (change) {
                that.trigger(CHANGE, {
                    values: [selectionStart, selectionEnd],
                    value: [selectionStart, selectionEnd]
                });
            }
        },

        value: function(value) {
            if (value && value.length) {
                return this._value(value[0], value[1]);
            } else {
                return this._value();
            }
        },

        _value: function(start, end) {
            var that = this,
                options = that.options,
                selectionStart = options.selectionStart,
                selectionEnd = options.selectionEnd;

            if (isNaN(start) && isNaN(end)) {
                return [selectionStart, selectionEnd];
            } else {
                start = round(start);
                end = round(end);
            }

            if (start >= options.min && start <= options.max &&
                end >= options.min && end <= options.max && start <= end) {
                if (selectionStart != start || selectionEnd != end) {
                    that.element.find("input")
                        .eq(0).prop("value", formatValue(start))
                        .end()
                        .eq(1).prop("value", formatValue(end));

                    options.selectionStart = start;
                    options.selectionEnd = end;
                    that._refresh();
                    that._refreshAriaAttr(start, end);
                }
            }
        },

        values: function (start, end) {
            if (isArray(start)) {
                return this._value(start[0], start[1]);
            } else {
                return this._value(start, end);
            }
        },

        _refresh: function() {
            var that = this,
                options = that.options;

            that.trigger(MOVE_SELECTION, {
                values: [options.selectionStart, options.selectionEnd],
                value: [options.selectionStart, options.selectionEnd]
            });

            if (options.selectionStart == options.max && options.selectionEnd == options.max) {
                that._setZIndex("firstHandle");
            }
        },

        _refreshAriaAttr: function(start, end) {
            var that = this,
                dragHandles = that.wrapper.find(DRAG_HANDLE),
                drag = that._activeHandleDrag,
                formattedValue;

            formattedValue = that._getFormattedValue([start, end], drag);

            dragHandles.eq(0).attr("aria-valuenow", start);
            dragHandles.eq(1).attr("aria-valuenow", end);
            dragHandles.attr("aria-valuetext", formattedValue);
        },

        _setValueInRange: function (selectionStart, selectionEnd) {
            var options = this.options;

            selectionStart = math.max(math.min(selectionStart, options.max), options.min);

            selectionEnd = math.max(math.min(selectionEnd, options.max), options.min);

            if (selectionStart == options.max && selectionEnd == options.max) {
                this._setZIndex("firstHandle");
            }

            this._update(math.min(selectionStart, selectionEnd), math.max(selectionStart, selectionEnd));
        },

        _setZIndex: function (type) {
            this.wrapper.find(DRAG_HANDLE).each(function (index) {
                $(this).css("z-index", type == "firstHandle" ? 1 - index : index);
            });
        },

        destroy: function() {
            var that = this;

            Widget.fn.destroy.call(that);

            that.wrapper.off(NS)
                .find(TICK_SELECTOR + ", " + TRACK_SELECTOR).off(NS)
                .end()
                .find(DRAG_HANDLE).off(NS);

            that._firstHandleDrag.draggable.destroy();
            that._lastHandleDrag.draggable.destroy();
        }
    });

    RangeSlider.Selection = function (dragHandles, that, options) {
        function moveSelection(value) {
            value = value || [];
            var selectionStartValue = value[0] - options.min,
                selectionEndValue = value[1] - options.min,
                selectionStartIndex = math.ceil(round(selectionStartValue / options.smallStep)),
                selectionEndIndex = math.ceil(round(selectionEndValue / options.smallStep)),
                selectionStart = that._pixelSteps[selectionStartIndex],
                selectionEnd = that._pixelSteps[selectionEndIndex],
                halfHandle = parseInt(dragHandles.eq(0)[that._outerSize]() / 2, 10),
                rtlCorrection = that._isRtl ? 2 : 0;

            dragHandles.eq(0).css(that._position, selectionStart - halfHandle - rtlCorrection)
                       .end()
                       .eq(1).css(that._position, selectionEnd - halfHandle - rtlCorrection);

            makeSelection(selectionStart, selectionEnd);
        }

        function makeSelection(selectionStart, selectionEnd) {
            var selection,
                selectionPosition,
                selectionDiv = that._trackDiv.find(".k-slider-selection");

            selection = math.abs(selectionStart - selectionEnd);

            selectionDiv[that._sizeFn](selection);
            if (that._isRtl) {
                selectionPosition = math.max(selectionStart, selectionEnd);
                selectionDiv.css("right", that._maxSelection - selectionPosition - 1);
            } else {
                selectionPosition = math.min(selectionStart, selectionEnd);
                selectionDiv.css(that._position, selectionPosition - 1);
            }
        }

        moveSelection(that.value());

        that.bind([ CHANGE, SLIDE, MOVE_SELECTION ], function (e) {
            moveSelection(e.values);
        });
    };

    kendo.ui.plugin(RangeSlider);

})(window.kendo.jQuery);

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(_, f){ f(); });

define('utils/numberslider',[
  "generated/templates",
  "utils/browserutils", 
  "kendo/kendo.slider"
], function (JST, BrowserUtils, kSlider) {

  var NumberSlider = function(_options) {

    var self = this,
        options = _options,
        $slider = options.slider,
        range = options.range ? true : false,
        minValue = null,
        maxValue = null,
        value = null,
        largeStep = options.largeStep ? options.largeStep : 15,
        smallStep = options.smallStep ? options.smallStep : 1,
        tooltipID = options.tooltipID ? options.tooltipID : null,
        changeCallback;

    self.render = function() {
      if(options.range) {
        renderRangeSlider();
      }
      else {
        renderNormalSlider();
      }
    };

    self.setRangeValues = function(values) {
      minValue = values[0];
      maxValue = values[1];
    };

    self.getRangeValues = function() {
      return $slider.data('kendoRangeSlider').values();
    };

    self.setValue = function(val) {
      value = val;
    };

    self.change = function(callback) {
      changeCallback = callback;
    };

    var renderRangeSlider = function() {
      $slider.kendoRangeSlider({
        min: minValue,
        max: maxValue,
        largeStep: largeStep,
        smallStep: smallStep,
        tickPlacement: "none",
        tooltip: {
          persistDisplay: true,
          tooltipID: tooltipID
        },
        change: function() {
          changeCallback();
        }
      }).data('kendoRangeSlider');
      $slider.data('kendoRangeSlider').value(value);
    };

    var renderNormalSlider = function() {

    };
    
  };

  return NumberSlider;

});

define('renderers/formrenderer',[
  "renderers/componentrenderer",
  "generated/templates",
  "graphics/rfkpi",
  "utils/datepicker",
  "utils/numberslider",
  "vendor/Modernizr"
  // "kendo/kendo.dropdownlist",
  // "kendo/kendo.multiselect"
], function (ComponentRenderer, JST, RFKPI, DatePicker, NumberSlider, Modernizr) {
  function FormRenderer() {
    ComponentRenderer.call(this);

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    var kpi,
        mode,
        spark,
        sparkContainer,
        sparkLabels,
        sparkValues,
        currentVals = {},
        $itemContainer = null,
        $formContainer = null,
        $slider = null;

    Public = {
      setConfig: function (cfg) {
        currentVals = cfg.defaultValues || {};
      },

      dispose: function () {
        base.dispose();
        $itemContainer = null;
        $formContainer = null;
      },
      renderCore: function () {
        self.$core.html(JST.form_base({

        }));
        $formContainer = self.$core.find('.formContainer');
        $itemContainer = self.$core.find('.formItems');

        var items = self.props.form.items;
        for (var key in items) {
          if(items.hasOwnProperty(key)){
            var item = items[key];
            item.id = key;
            addExtraParams(item);

            var $node = $(JST.form_item(item));
            $itemContainer.append($node);
            attachEventHandlers(item, $node);
          }
        }

        var submit = self.$core.find('#submit');

        submit.on('click', function () {
          obj = self.getAllInputValues(true);
          pro.trigger('submit', obj);
        });

      },
      resizeCore: function (width, height) {

      },
      isFieldSet: function (id) {
        var item = self.props.form.items[id];
        var $itemContainer = self.$core.find('.formItems');
        if (!item) {
          return false;
        }

        if (item.type === 'text') {
          return $itemContainer.find('[data-key=' + item.id + ']').val() !== "";
        } else if (item.type === 'select') {
          var index = $itemContainer.find('[data-key=' + item.id + ']')[0].selectedIndex;
          return {
            text: item.list[index],
            index: index
          };
        } else if (item.type === 'multiSelect') {
          var options = $itemContainer.find('[data-key=' + item.id + '] option');
          var indices = [], texts = [];
          for (var i = 0; i < options.length; i++) {
            if (options[i].selected) {
              indices.push(i);
              texts.push(item.list[i]);
            }
          }
          return texts.length > 0;
        } else if (item.type === 'date') {
          // Always process since a value will be set by default
          return true;
        } else if (item.type === 'dateRange') {
          // Always process since a value will be set by default
          return true;
        } else if (item.type === 'numericRange') {
          // if(!Modernizr.touch){
          //   return item.numberSlider.getRangeValues();
          // }

          // return [+$itemContainer.find('[data-key=' + item.id + '].rangeStart').val(),
          //   +$itemContainer.find('[data-key=' + item.id + '].rangeEnd').val()];
          // Always process since a value will be set by default
          return true;
        } else if (item.type === 'checkbox') {
          // return $itemContainer.find('[data-key=' + item.id + ']').is(':checked');
          // Always process since a value will be set by default
          return true;
        }

        return false;
      },
      getInputValue: function (id) {
        var item = self.props.form.items[id];
        var $itemContainer = self.$core.find('.formItems');
        if (!item) {
          console.error('Form field with id ' + id + ' was not found!');
          return;
        }

        if (item.type === 'text') {
          return $itemContainer.find('[data-key=' + item.id + ']').val();
        } else if (item.type === 'select') {
          var index = $itemContainer.find('[data-key=' + item.id + ']')[0].selectedIndex;
          return {
            text: item.list[index],
            index: index
          };
        } else if (item.type === 'multiSelect') {
          var options = $itemContainer.find('[data-key=' + item.id + '] option');
          var indices = [], texts = [];
          for (var i = 0; i < options.length; i++) {
            if (options[i].selected) {
              indices.push(i);
              texts.push(item.list[i]);
            }
          }
          return {
            text: texts,
            index: indices
          };
        } else if (item.type === 'date') {
          return new Date($itemContainer.find('[data-key=' + item.id + ']').val());
        } else if (item.type === 'dateRange') {
            var nonConvertedStartDate = $itemContainer.find('[data-key=' + item.id + '].rangeStart').val();
            var nonConvertedEndDate = $itemContainer.find('[data-key=' + item.id + '].rangeEnd').val();
            //added by LS
            var convertedStartDate = nonConvertedStartDate.replace(/oktober/, "October");
            convertedStartDate = convertedStartDate.replace(/maj/, "May");
            var convertedEndDate = nonConvertedEndDate.replace(/oktober/, "October");
            convertedEndDate = convertedEndDate.replace(/maj/, "May");
            return [new Date(convertedStartDate),
                new Date(convertedEndDate)];
                //new Date($itemContainer.find('[data-key=' + item.id + '].rangeEnd').val())];
        } else if (item.type === 'numericRange') {
          if(!Modernizr.touch){
            return item.numberSlider.getRangeValues();
          }

          return [+$itemContainer.find('[data-key=' + item.id + '].rangeStart').val(),
            +$itemContainer.find('[data-key=' + item.id + '].rangeEnd').val()];
        } else if (item.type === 'checkbox') {
          return $itemContainer.find('[data-key=' + item.id + ']').is(':checked');
        }
      },

      getAllInputValues: function (onlySet) {
        onlySet = onlySet || false;
        var items = self.props.form.items;
        var obj = {};
        for (var key in items) {
          if(items.hasOwnProperty(key)) {
            if(!onlySet || self.isFieldSet(key)) {
              obj[key] = self.getInputValue(key);
            }
          }
        }
        return obj;
      }
    };

    Protected = {

    };

    var addExtraParams = function (item) {
      var isOptionSelected = [];
      var currentVal = currentVals[item.id];
      item.options = item.options || {};
      if (item.type === 'text') {
        item.value = currentVal || item.options.defaultText || "";
      } else if (item.type === 'select') {
        item.multiple = false;
        item.options = currentVal ? {defaultSelectedIndex: currentVal} : (item.options || {defaultSelectedIndex: 0});
      } else if (item.type === 'multiSelect') {
        item.multiple = true;

        item.options.defaultSelectedOptions = currentVal || (item.options.defaultSelectedOptions || []);

        if (item.options && item.options.defaultSelectedOptions.length > 1) {
          for (i = 0; i < item.list.length; i++) {
            isOptionSelected[i] = false;
          }

          for (i = 0; i < item.options.defaultSelectedOptions.length; i++) {
            isOptionSelected[item.options.defaultSelectedOptions[i]] = true;
          }
        }
        item.isOptionSelected = isOptionSelected;
      } else if (item.type === 'date') {
        item.touch = Modernizr.touch;
        item.options.defaultDate = currentVal || (item.options.defaultDate || getCurrentDateString());
      } else if (item.type === 'dateRange') {
        item.touch = Modernizr.touch;
        item.options.defaultStartDate = currentVal ? currentVal.defaultStartDate : (item.options.defaultStartDate || getLastMonthsDateString());
        item.options.defaultEndDate = currentVal ? currentVal.defaultEndDate : (item.options.defaultEndDate || getCurrentDateString());
      } else if (item.type === 'numericRange') {
        item.touch = Modernizr.touch;
        item.options.rangeValues = item.options.values ? item.options.values : [ 0, 100 ];
        item.options.values = currentVal ? [currentVal.start, currentVal.end] : (item.options.values || [0, 100]);
      } else if (item.type === 'checkbox') {
        item.options.value = currentVal;
      }

    };

    var attachEventHandlers = function (item, $node) {
      var datePicker;
      if (item.type === 'text') {
        $node.on('keyup', function () {
          currentVals[item.id] = $node.find('input').val();
          pro.trigger('change', currentVals);
        });
      } else if (item.type === 'select') {
        // $node.find('#' + item.id).kendoDropDownList().data('kendoDropDownList');
        $node.on('change', function () {
          currentVals[item.id] = $node.find('select')[0].selectedIndex;
          pro.trigger('change', currentVals);
        });
      } else if (item.type === 'multiSelect') {
        $node.on('change', function () {
          var options = $(this).find('option');
          var indices = [];
          for (var i = 0; i < options.length; i++) {
            if (options[i].selected) {
              indices.push(i);
            }
          }
          currentVals[item.id] = indices;
          pro.trigger('change', currentVals);
        });
        // $node.find('#' + item.id).kendoMultiSelect().data('kendoMultiSelect');
      } else if (item.type === 'date') {
        var el = $node.find('input[data-key=' + item.id + ']');
        item.options.core = el;
        if(!Modernizr.touch) {
          datePicker = new DatePicker(item.options);
          datePicker.render();
        }

        $node.on('change', function () {
          var date  = $node.find('input').data('kendoDatePicker');
          currentVals[item.id] = createDateString(date.value());
          pro.trigger('change', currentVals);
        });
      } else if (item.type === 'dateRange') {
        var el1 = $node.find('input[data-key=' + item.id + '].rangeStart');
        var el2 = $node.find('input[data-key=' + item.id + '].rangeEnd');
        item.options.core = [ el1, el2 ];
        item.options.range = true;

        if(!Modernizr.touch) {
          datePicker = new DatePicker(item.options);
          datePicker.render();
        }

        el1.on('change', function () {
          var date1  = $($node.find("input")[0]).data('kendoDatePicker');
          var date2  = $($node.find("input")[1]).data('kendoDatePicker');
          currentVals[item.id] = { 
            defaultStartDate: createDateString(date1.value()),
            defaultEndDate: createDateString(date2.value())
          };
          pro.trigger('change', currentVals);
        });

        el2.on('change', function () {
          var date1  = $($node.find("input")[0]).data('kendoDatePicker');
          var date2  = $($node.find("input")[1]).data('kendoDatePicker');
          currentVals[item.id] = { 
            defaultStartDate: createDateString(date1.value()),
            defaultEndDate: createDateString(date2.value())
          };
          pro.trigger('change', currentVals);
        });
      } else if (item.type === 'numericRange') {
        $slider = $node.find('#rfRangeSlider-' + item.id);
        item.options.slider = $slider;
        item.options.tooltipID = '.rfNumericRangeText-' + item.id;
        item.options.range = true;
        var numberSlider = new NumberSlider(item.options);
        $node.find(".rfNumericRangeText-" + item.id).text(item.options.values[0] + " - " + item.options.values[1]);
        var changeFunction = function() {
          var values = $slider.data('kendoRangeSlider').value();
          currentVals[item.id] = {
            start: values[0],
            end: values[1]
          };
          $(".rfNumericRangeText-" + item.id).text(values[0] + " - " + values[1]);
        };

        item.numberSlider = numberSlider;

        // if(!Modernizr.touch) {
          numberSlider.setRangeValues(item.options.rangeValues);
          numberSlider.setValue( item.options.values );
          numberSlider.change(changeFunction);
          numberSlider.render();
        // }

      } else if (item.type === 'checkbox') {
        $node.on('change', function () {
          currentVals[item.id] = $node.find('input').is(':checked');
          pro.trigger('change', currentVals);
        });
      }
    };

    var createDateString = function(dateString) {
      var d = new Date(dateString);
      var month = d.getMonth() + 1;

      month = ( month >= 10 ) ? month : ( '0' + month );

      return d.getFullYear() + '-' + month + '-' + ((d.getDate() < 10) ? '0' : '') + d.getDate();
    };

    var getCurrentDateString = function () {
      var d = new Date();
      var month = d.getMonth() + 1;

      month = ( month >= 10 ) ? month : ( '0' + month );

      return d.getFullYear() + '-' + month + '-' + ((d.getDate() < 10) ? '0' : '') + d.getDate();
    };

    var getLastMonthsDateString = function () {
      var d = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      var month = d.getMonth() + 1;

      month = ( month >= 10 ) ? month : ( '0' + month );

      return d.getFullYear() + '-' + month + '-' + ((d.getDate() < 10) ? '0' : '') + d.getDate();
    };

    raw._registerClassName("FormRenderer");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);
  }

  return FormRenderer;
});

define('components/formcomponent',[
  "components/component",
  "renderers/formrenderer",
  "prop/properties",
  'vendor/lodash'
], function (Component, FormRenderer, Properties, _) {
  /**
   * Creates a form component
   * @class  FormComponent
   * @augments {Component}
   */
  function FormComponent() {
    Component.apply(this, Array.prototype.slice.call(arguments));

    var self = this,
        base = {},
        Public,
        raw = self._raw,
        Protected,
        pro = self.pro,
        _bp = {};

    var submitHandler;

    Public = {
      /**
       * Add a text field represented by a HTML Text input on the form.
       * @method addTextField
       * @param {String} id id for this field, used to retrieve the value
       * @param {String} label The label that is displayed in the form element for the user
       * @param {Object} options The options object
       */
      addTextField: function (id, label, options) {
        var opts = {
          type: 'text',
          label: label,
          options: options
        };
        pro.pb.addItemToList('form.items', id, opts);
      },

      /**
       * Add a select/dropdown field which allows the user to select one
       * option from a list of pre-defined options.
       * This is displayed as a HTML Select input on the form.
       * @method addSelectField
       * @param {String} id id for this field, used to retrieve the value
       * @param {string} label The label that is displayed in the form element for the user
       * @param {Array} list An array of strings which are the options in the select items.
       * @param {Object} options The options object
       */
      addSelectField: function (id, label, list, options) {
        var opts = {
          type: 'select',
          label: label,
          list: list,
          options: options
        };

        pro.pb.addItemToList('form.items', id, opts);
      },

      /**
       * Add a multi-select field which allows the user to select one
       * option from a list of pre-defined options. This is displayed as a HTML multi select input on the form.
       * @method addMultiSelectField
       * @param {String} id id for this field, used to retrieve the value
       * @param {string} label The label that is displayed in the form element for the user
       * @param {Array} list An array of strings which are the options in the select items.
       * @param {Object} options The options object
       */
      addMultiSelectField: function (id, label, list, options) {
        options = options || {};
        var _options = _.extend(options, {
              defaultSelectedOptions: options.defaultSelectedOptions || []
            }),
            opts = {
              type: 'multiSelect',
              label: label,
              list: list,
              options: _options
            };

        pro.pb.addItemToList('form.items', id, opts);

      },

      /**
       * Add a select/dropdown field which allows the user to select a single date. This is displayed with a date picker.
       * @method addDateField
       * @param {String} id id for this field, used to retrieve the value
       * @param {string} label The label that is displayed in the form element for the user
       * @param {Object} options The options object
       */
      addDateField: function (id, label, options) {
        var opts = {
          type: 'date',
          label: label,
          options: options
        };

        pro.pb.addItemToList('form.items', id, opts);
      },
      /**
       * Adds a Date Range field to the component. This field can be used to select a date range, a start date and an end date.
       * range, a start date and an end date.
       * @method addDateRangeField
       * @param {String} id id for this field, used to retrieve the value
       * @param {string} label The label that is displayed in the form element for the user
       * @param {Object} options The options object
       */
      addDateRangeField: function (id, label, options) {
        _.extend(options, { range: true });
        var opts = {
          type: 'dateRange',
          label: label,
          options: options
        };

        pro.pb.addItemToList('form.items', id, opts);
      },
      /**
       * Adds a Numeric Range field to the component. This field can be used to select a numeric range, a start number and an end number.
       * @method addNumericRangeField
       * @param {String} id Unique id for this field
       * @param {String} label The name displayed on the control
       * @param {Array} values The default values for the start and end numbers
       * @param {Object} options The options object
       */
      addNumericRangeField: function (id, label, values, options) {
        options = options ? options : {};
        _.extend(options, { values: values });
        var opts = {
          type: 'numericRange',
          label: label,
          options: options
        };
        pro.pb.addItemToList('form.items', id, opts);
      },

      /**
       * Add a checkbox field displayed as a HTML checkbox in the form.
       * @method addCheckboxField
       * @param {String} id id for this field, used to retrieve the value
       * @param {String} label The label that is displayed in the form element for the user
       * @param {Boolean} value If the checkbox is supposed to be checked by default
       */
      addCheckboxField: function (id, label, value) {
        var opts = {
          type: 'checkbox',
          label: label,
          options: {value: value}
        };

        pro.pb.addItemToList('form.items', id, opts);
      },
      /**
       * Sets a callback for the apply click event
       * @method onApplyClick
       * @param  {Function} cb The callback which is called when submit is clicked
       */
      onApplyClick: function (cb) {
        if(pro.renderer) {
          pro.renderer.pro.bind('submit', cb);  
        } else {
          submitHandler = cb;
        }
      },
      /**
       * Returns all the input values provided in this component
       * @method getAllInputValues
       */
      getAllInputValues: function() {
        return pro.renderer.getAllInputValues();
      },

      /**
       * Check if the field of the form component has been set.
       * 
       * @param {String} id The id of a specific field
       * @method isFieldSet
       */
      isFieldSet: function(id) {
        return pro.renderer.isFieldSet(id);
      },

      /**
       * Returns an input value by id provided in this component
       * @method getInputValue
       * @param {String} id The id of a specific field
       */
      getInputValue: function(id) {
        return pro.renderer.getInputValue(id);
      }
    };

    Protected = {
      init: function () {
        _bp.init();
      },
      createRenderer: function () {
        pro.renderer = new FormRenderer();
        pro.renderer.setConfig({defaultValues: pro.defaultValues});
        pro.renderer.pro.bind('change', changeListener);
        if(submitHandler) {
          pro.renderer.pro.bind('submit', submitHandler);
          submitHandler = undefined;
        }

        pro.renderer.pro.bind("submit", function (params) {
          pro.handleComponentEvent ("submit", params);
        });
        pro.onRendererCreate();
      },
      renderCore: function () {
        pro.renderer.renderCore();
      },
      resizeCore: function (width, height) {
        pro.renderer.resizeCore(width, height);
      },
      addListeners: function () {
        _bp.addListeners();
        pro.pushListeners([

        ]);
      },
      addCurrentValuesToPropBase: function () {
        // TODO: Add all the items in defaultValues to propbase
      },
      defaultValues: {}
    };

    var changeListener = function (defaultValues) {
      pro.defaultValues = defaultValues;
      // debugger
    };

    /**
     * This is the actual constructor of the object
     */
    var construct = function () {
      pro.pb = new Properties.FormComponentProperties();
    };

    raw._registerClassName("FormComponent");
    raw._registerPublic(base, Public);
    raw._registerProtected(_bp, Protected);

    construct();
  }

  return FormComponent;
});

define('renderers/kpitablerenderer',["generated/templates", 'renderers/componentrenderer', "utils/numberformatter", 'utils/iconutils', "utils/evalexpression", 'vendor/lodash'],
    function(JST, ComponentRenderer, NumberFormatter, iconUtils, evalExpression, _) {
    function KPITableRenderer() {
        ComponentRenderer.call(this);
        var self = this,
            base = {},
            Public,
            raw = self._raw,
            Protected,
            pro = self.pro,
            _bp = {};

        var kpiobjs = {},
            kpiContainers = {},
            numKPIs = null,
            conditionalParam = [];

        Public = {
            dispose: function() {

            },
            setConfig: function(config) {
                
            },
            renderCore: function() {
                var kpis = self.props.kpis,
                    keys = _.keys(kpis),
                    tmp = [],
                    i,
                    key,
                    kpi,
                    numKPIs = keys.length;
                for(i=-1; ++i<numKPIs;) {
                    key = keys[i];
                    kpi = kpis[key];

                    var numberFormatter = new NumberFormatter();
                    kpi.dataType = 'number';
                    numberFormatter.setConfig(kpi);
                    tmp[i] = {
                        caption: kpi.caption,
                        value: numberFormatter.formatValue(kpi.value)
                    };
                }

                self.$core.empty();
                self.$core.append(JST.kpitable({
                    numKPIs: numKPIs,
                    keys: keys,
                    kpis: tmp
                }));

                for(i=-1; ++i<numKPIs;) {
                    key = keys[i];
                    kpi = kpis[key];

                    var $caption = self.$core.find('#' + key + ' > .rfKPICaption'),
                        $value = self.$core.find('#' + key + ' > .rfKPIValue'),
                        valueColor = kpi.valuecolor ? kpi.valuecolor : "auto",
                        conditionalParam = kpi.valueConditionalFormatters;

                    if(kpi.captioncolor) {
                        $caption.css({
                            color: kpi.captioncolor
                        });
                    }
                    for(var j=0; j < conditionalParam.length; j++) {
                        if(evalExpression(conditionalParam[j].expression, kpi.value)) {
                            valueColor = conditionalParam[j].valueColor;
                        }
                    }
                    if(valueColor !== "auto") {
                        $value.css({
                            color: valueColor
                        });
                    }
                    if(kpi.icon) {
                        $value.prepend(iconUtils.getHTMLForIcon(kpi.icon, JSON.parse(kpi.iconprops)));
                    }
                }
            },
            resizeCore: function(w, h) {
                self.$core.find('table').width(w);
                // var kpiW = w,
                //     kpiH = h / numKPIs,
                //     unitWidth = kpiW / 2,
                //     xPadding = unitWidth * 0.1;
                //     fontSize = ((unitWidth/2 - xPadding) / 2);

                // // TODO: cache the dom nodes for performance
                // self.$core.find('td').each(function() {
                //     $(this).height(kpiH);
                // });

                // self.$core.find('.rfKPICaption').css({
                //     fontSize: fontSize * 0.4
                // });
                // self.$core.find('.rfKPIValue').css({
                //     fontSize: fontSize * 0.72
                // });
                // var kpiW = Math.floor(w / numKPIs) - 4,
                //     kpiH = h;
                // for(var key in kpis) {
                //     kpiobjs[key].resize(kpiW, kpiH);
                //     kpiContainers[key].css({
                //         width: kpiW,
                //         height: kpiH
                //     });
                // }
            },

            updateValue: function(id, value) {
                var $value = self.$core.find('#' + id + ' > .rfKPIValue'),
                    kpi = self.props.kpis[id],
                    numberFormatter = new NumberFormatter();
                kpi.dataType = 'number';
                numberFormatter.setConfig(kpi);
                $value.text(numberFormatter.formatValue(value));
                if(kpi.icon) {
                    $value.prepend(iconUtils.getHTMLForIcon(kpi.icon, JSON.parse(kpi.iconprops)));
                }
            }
        };

        raw._registerClassName("KPITableRenderer");
        raw._registerPublic(base, Public);
        raw._registerProtected(_bp, Protected);
    }
    
    return KPITableRenderer;
});
define('components/multikpicomponent',['components/component', 'prop/properties', 'renderers/kpitablerenderer'], function(Component, Properties, KPITableRenderer) {
  /**
   * MultiKPI Class containing functions shared across KPI Table and KPI Group.
   *
   * **This is an abstract class. You cannot create instances of this.**
   * @class  MultiKPIComponent
   */
    function MultiKPIComponent() {
        Component.apply(this, Array.prototype.slice.call(arguments));
        var self = this,
            base = {},
            Public,
            raw = self._raw,
            Protected,
            pro = self.pro,
            _bp = {},
            captionColors = {},
            valueColors = {};

        Public = {
            /**
             * Adds an individual KPI
             * @method addKPI
             * @param {String} id                           A unique id for the KPI
             * @param {ComponentKPIProperties} options      Set of options for configuring this KPI
             */
            addKPI: function(id, options) {
                pro.pb.addItemToList('kpis', id, options);
            },

           /**
             * Updates an existing KPI
             * @method updateKPI
             * @param {String} id                          The unique id for the individual KPI
             * @param {ComponentKPIProperties} opts         Set of options for configuring this KPI
             */
            updateKPI: function(id, options) {
                pro.pb.setObjectAtPath('kpis['+id+']', options);   
            },

           /**
             * Deletes an existing KPI
             * @method deleteKPI
             * @param {String} id           The unique id for the individual KPI
             */
            deleteKPI: function(id) {
                var list = pro.pb.getObjectAtPath('kpis');
                list[id] = undefined;
                delete list[id];
                pro.pb.emptyList('kpis');
                pro.pb.setObjectAtPath('kpis', list);
            },

           /**
             * Sets a caption color for a KPI
             * @method setKPICaptionColor
             * @param {String} id            The unique id for the individual KPI
             * @param {String} color         Color for the caption
             */
            setKPICaptionColor: function(id, color) {
                pro.pb.setValue('kpis[' + id + '].captioncolor', color);
            },

           /**
             * Sets a value color for a KPI
             * @method setKPIValueColor
             * @param {String} id           The unique id for the individual KPI
             * @param {String} opts         Color for the value text
             */
            setKPIValueColor: function(id, color) {
                pro.pb.setValue('kpis[' + id + '].valuecolor', color);   
            },

            valueConditionalFormat: function (formatRule, appliedStyle) {
                var opts = {
                  "expression": formatRule,
                  "valueColor": appliedStyle
                };
                for (var kpi in pro.pb.getObjectAtPath("kpis")) {
                    pro.pb.pushItemToList("kpis[" + kpi + "].valueConditionalFormatters", opts);
                }
            },

            setValueIcon: function(id, iconID, props) {
                pro.pb.setValue('kpis[' + id + '].icon', iconID);
                pro.pb.setValue('kpis[' + id + '].iconprops', JSON.stringify(props || {}));
            }
        };

        Protected = {
             init: function () {
                _bp.init();
            },
            createRenderer: function () {
                pro.renderer = new KPITableRenderer();
                pro.renderer.setConfig({    
                });
                pro.onRendererCreate();
            },

            renderCore: function () {
                pro.renderer.renderCore();
            },
            resizeCore: function (width, height) {
                pro.renderer.resizeCore(width, height);
            },
            addListeners: function () {
                _bp.addListeners();
                pro.pushListeners([
                    {
                        regexp: true,
                        path: 'kpis\\[([a-z]+)\\]',
                        callback: function(newValue, oldValue, result) {
                            if(newValue && newValue.value) {
                                pro.renderer.updateValue(result[1], newValue.value);
                            } else {
                                pro.redraw();
                            }
                        }
                    }
                ]);
            }
        };

        var construct = function() {
            pro.pb = new Properties.ComponentProperties();
        };

        raw._registerClassName("MultiKPIComponent");
        raw._registerPublic(base, Public);
        raw._registerProtected(_bp, Protected);

        construct();
    }

    return MultiKPIComponent;
});
define('renderers/kpigrouprenderer',["generated/templates", 'renderers/componentrenderer', 'graphics/minikpi', 'utils/numberformatter', "utils/evalexpression", 'vendor/lodash'],
function(JST, ComponentRenderer, MiniKPI, NumberFormatter, evalExpression, _) {
    function KPIGroupRenderer() {
        ComponentRenderer.call(this);
        var self = this,
            base = {},
            Public,
            raw = self._raw,
            Protected,
            pro = self.pro,
            _bp = {};

        var kpiobjs = {},
            kpiContainers = {},
            numKPIs = null,
            conditionalParam = [];

        Public = {
            dispose: function() {

            },
            setConfig: function(config) {
                
            },
            updateValue: function(id, value) {
                var numberFormatter = new NumberFormatter(),
                    kpi = self.props.kpis[id];
                    
                numberFormatter.setConfig(_.extend(kpi, {
                    dataType: 'number'
                }));
                kpiobjs[id].updateValue(numberFormatter.formatValue(value));
            },
            renderCore: function() {
                var componentWidth = self.props.core.location.w,
                    numPossibleKPIs = componentWidth / 2,
                    kpis = self.props.kpis,
                    numKPIsNeeded = _.keys(kpis).length;
                    numKPIs = numPossibleKPIs > numKPIsNeeded ? numKPIsNeeded : numPossibleKPIs;
                
                self.$core.empty();
                self.$core.append(JST.kpigroup({
                    numKPIs: numKPIs,
                    keys: _.keys(kpis)
                }));

                for(var key in kpis) {
                    if(kpis.hasOwnProperty(key)) {
                        var kpi = kpis[key],
                            valueColor = kpi.valuecolor,
                            conditionalParam = kpi.valueConditionalFormatters;
                            numberFormatter = new NumberFormatter();

                        numberFormatter.setConfig(_.extend(kpi, {
                            dataType: 'number'
                        }));
                        for(var i=0; i < conditionalParam.length; i++) {
                            if(evalExpression(conditionalParam[i].expression, kpi.value)) {
                                valueColor = conditionalParam[i].valueColor;
                            }
                        }
                        kpiContainers[key] = self.$core.find('.rfMiniKPIContainer#' + key);
                        kpiobjs[key] = new MiniKPI();
                        kpiobjs[key].config({
                            caption: kpi.caption,
                            value: numberFormatter.formatValue(kpi.value),
                            captionColor: kpi.captioncolor,
                            valueColor: valueColor,
                            icon: kpi.icon,
                            iconProps: JSON.parse(kpi.iconprops),
                            captionFontScale: 0.4,
                            valueFontScale: 0.72
                        });
                        kpiobjs[key].render(kpiContainers[key]);
                    }
                }
            },
            resizeCore: function(w, h) {
                var kpis = self.props.kpis,
                    componentWidth = self.props.core.location.w,
                    numKPIsNeeded = _.keys(self.props.kpis).length,
                    numPossibleKPIs = componentWidth / 2,
                    numKPIs = numKPIsNeeded > numPossibleKPIs ? numPossibleKPIs : numKPIsNeeded;
                var kpiW = Math.floor(w / numPossibleKPIs) - 4,
                    cW = Math.floor(w / numKPIs),
                    kpiH = h;
                for(var key in kpis) {
                    if(kpis.hasOwnProperty(key)) {
                        kpiobjs[key].resize(kpiW, kpiH);
                        kpiContainers[key].css({
                            width: cW,
                            height: kpiH
                        });
                    }
                }
            }
        };

        raw._registerClassName("KPIGroupRenderer");
        raw._registerPublic(base, Public);
        raw._registerProtected(_bp, Protected);
    }
    
    return KPIGroupRenderer;
});
define('components/kpigroupcomponent',['components/multikpicomponent', 'prop/properties', 'renderers/kpigrouprenderer', 'renderers/kpitablerenderer'], function(MultiKPIComponent, Properties, KPIGroupRenderer, KPITableRenderer) {
  /**
   * Creates a KPI Group Component
   * @class KPIGroupComponent
   * @augments {MultiKPIComponent}
   */
    function KPIGroupComponent() {
        MultiKPIComponent.apply(this, Array.prototype.slice.call(arguments));
        var self = this,
            base = {},
            Public,
            raw = self._raw,
            Protected,
            pro = self.pro,
            _bp = {};

        Public = {

        };

        Protected = {
             init: function () {
                _bp.init();
            },
            createRenderer: function () {
                if(pro.getMediaHelper().mediaSelect({"sm+xs":true}, false) || pro.maximized) {
                    pro.renderer = new KPITableRenderer();
                } else {
                    pro.renderer = new KPIGroupRenderer();    
                }
                pro.renderer.setConfig({
                });
                pro.onRendererCreate();
            },
            addListeners: function () {
                _bp.addListeners();
            }
        };

        var construct = function() {

        };

        raw._registerClassName("KPIGroupComponent");
        raw._registerPublic(base, Public);
        raw._registerProtected(_bp, Protected);

        construct();
    }

    return KPIGroupComponent;
});
define('components/kpitablecomponent',['components/multikpicomponent', 'prop/properties', 'renderers/kpitablerenderer'], function(MultiKPIComponent, Properties, KPITableRenderer) {
  /**
   * Creates a KPI Table Component
   * @class KPITableComponent
   * @augments {MultiKPIComponent}
   */
    function KPITableComponent() {
        MultiKPIComponent.apply(this, Array.prototype.slice.call(arguments));
        var self = this,
            base = {},
            Public,
            raw = self._raw,
            Protected,
            pro = self.pro,
            _bp = {};

        Public = {

        };

        Protected = {
             init: function () {
                _bp.init();
            },
            createRenderer: function () {
                pro.renderer = new KPITableRenderer();
                pro.renderer.setConfig({
                });
                pro.onRendererCreate();
            },
            addListeners: function () {
                _bp.addListeners();
            }
        };

        var construct = function() {

        };

        raw._registerClassName("KPITableComponent");
        raw._registerPublic(base, Public);
        raw._registerProtected(_bp, Protected);

        construct();
    }

    return KPITableComponent;
});
define('utils/rfloggerstub',[], function() {
    var RFLogger = {
        
        debugMode: false,

        log: function(msg) {
            console.log(msg);
        },

        error: function(msg) {
            console.error(msg);
        },
        init: function() {

        },
        showLogs: function() {
            
        }
    };

    return RFLogger;
});
define('utils/rflogger',["kendo/kendo.window", "kendo/kendo.tabstrip", 'generated/templates', 'vendor/lodash'], function(kendoWindow, kendoTabStrip ,JST, _) {
    var logs = [];
    var $window = $(JST.logs({}));
    var filter = {
        log: true,
        warn: true,
        error: true,
        server: true,
        client: true
    };
    var exceptionFormatter = function(item) {
        return $("<li/>").text(item.data.exception.stack);
    };
    var RFLogger = {
        
        debugMode: true,

        log: function(msg, data) {
            data = data || {};
            var timestamp = new Date();
            var _data = {
                type: 'log',
                source: 'client',
                timestamp: timestamp
            };
            logs.push({
                msg: msg,
                data: _.extend(_data, data)
            });
            // console.log(msg);
            return logs.length - 1;
        },

        error: function(msg, exception, data) {
            data = data || {};
            return RFLogger.log(msg, _.extend({
                type: 'error',
                extraInfo: !!exception ? true : false,
                infoFormatter: exceptionFormatter,
                exception: exception
            }, data));
        },

        init: function() {
            _.defer(function() {
                // console.log('Initializing logger');
                $window.kendoWindow({
                  width: 600,
                  height: 500,
                  title: "Razorflow Dev Tools",
                  visible: false
                }).data('kendoWindow');
                $window.find('#tabstrip').kendoTabStrip();
                $window.find('.toolbar input').on('change', function() {
                    var id = $(this).attr('id'),
                        checked = $(this).is(':checked');
                    if(id === 'all') {
                        if(checked) {
                            $window.find('.toolbar input').prop('checked', true);    
                        }
                    } else {
                        if(checked) {
                            var allChecked = true;
                            $window.find('.toolbar input:not(#all)').each(function(){allChecked = allChecked && $(this).is(':checked');});
                            if(allChecked) {
                                $window.find('.toolbar input#all').prop('checked', true);
                            }
                        } else {
                            $window.find('.toolbar input#all').prop('checked', false);
                        }
                    }
                    $window.find('.toolbar input:not(#all)').each(function() {
                        filter[$(this).attr('id')] = $(this).is(':checked');
                    });
                    RFLogger.renderLogs();
                });
            });
        },

        renderLogs: function(num) {
            var $parent = $window.find('.rfLogs ul'),
                $item;
            $parent.empty();
            var filteredLogs = _.filter(logs, function(item) {
                return filter[item.data.type] && filter[item.data.source];
            });
            for(var i=-1; ++i<filteredLogs.length;) {
                $item = $('<li/>');
                $item.append($('<span/>').text('[' + filteredLogs[i].data.source + '] ' + filteredLogs[i].msg));
                $item.addClass('rfLogItem ' + filteredLogs[i].data.type);
                $item.attr('title', filteredLogs[i].data.timestamp);
                $item.attr('id', i);
                $parent.append($item);
                if(filteredLogs[i].data.extraInfo) {
                    var $infoItem = filteredLogs[i].data.infoFormatter(filteredLogs[i]);
                    $parent.append($infoItem);
                    $infoItem.data('height', $infoItem.height());
                    $infoItem.hide();
                    $infoItem.addClass('extraInfo');
                    $item.addClass('collapsable');
                    $item.append($('<span/>').addClass('arrow right-arrow'));
                    $item.attr('data-state', 'closed');
                    $infoItem.attr('id', i + '-info');
                }
            }
            $parent.find('.collapsable').on('click', function() {
                var id = $(this).attr('id'),
                    state = $(this).attr('data-state'),
                    logContainer = $window.find('.rfLogs'),
                    currentScrollTop = logContainer.scrollTop();
                if(state === 'closed') {
                    $parent.find('#' + id + '-info').slideDown();
                    $(this).attr('data-state', 'open');
                    $(this).find('.arrow').removeClass('right-arrow').addClass('down-arrow');
                    $window.find('.rfLogs').animate({scrollTop: currentScrollTop + $parent.find('#' + id + '-info').data('height')});
                } else {
                    $parent.find('#' + id + '-info').slideUp();
                    $(this).find('.arrow').removeClass('down-arrow').addClass('right-arrow');
                    $(this).attr('data-state', 'closed');
                }
                
            });
            if(num) {
                $item = $parent.find('#' + num)[0];
                $item.scrollIntoView();
                $($item).addClass('shine').on('click.shine', function() {
                    $(this).removeClass('shine').off('click.shine');
                });

            }
                
        },

        showLogs: function(num) {
            $window.data('kendoWindow').open();
            RFLogger.renderLogs(num);
        }
    };

    return RFLogger;
});
define ('utils/errorhandler',[
  'utils/rflogger',
  'utils/rfnotification'
  ], function (RFLogger, RFNotification) {

  var error = {

    init: function() {
      var errorListener = function() {};
      if(window.onerror) {
        errorListener = window.onerror;
      }

      window.onerror = function(msg, link, lineno, colno, exception) {
        var log = rf.logger.error(msg, exception);
        RFNotification.create(msg, exception, log);
        errorListener();
        return false;
      };
    }

  };

  return error;
});
define('core/dbregistry',[], function() {
    var dbRegistry =  {
        /**
         * The dashboard object in the current instance.
         */
        dashboards: {},
        currentDashboard: null,
        defaultDashboard: null,
        /**
         * Register a dashboard in the dbRegistry
         */
        registerDashboard: function(id, db) {
          if(id !== 'default') {
            dbRegistry.dashboards[id] = db;  
          } else {
            dbRegistry.defaultDashboard = db;
          }
        },
        setCurrentDashboard: function(id) {
            dbRegistry.currentDashboard = dbRegistry.dashboards[id];
        },
        getCurrentDashboard: function() {
            return dbRegistry.currentDashboard;
        },
        getDefaultDashboard: function() {
          return dbRegistry.defaultDashboard;
        }
    };

    return dbRegistry;
});

define ('core/hookmanager',["kendo/kendo.core"], function () {
	/**
	 * How to use the hookmanager?
	 *
	 * ## Bind to an event
	 * 
	 * rf.hooks.bind("eventName", function (e) {
	 *	// handle the function here
	 *		console.log(e.myParam)
	 * })
	 *
	 * ## Trigger an event
	 * rf.hooks.trigger("eventName", {myParam: 42})
	 * 
	 * @type {[type]}
	 */
	var HookManager = kendo.Observable.extend({

	});

	return HookManager;
});
/**!
 * RedRaphael 1.1.3 - JavaScript Vector Library
 * Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
 *
 * Raphael 2.1.0
 * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
 * Copyright ¬© 2008-2012 Sencha Labs <http://sencha.com>
 *
 * Licensed under the MIT license.
 */
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/
        eve = function (name, scope) {
            name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
        // Undocumented. Debug only.
        eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards ‚Äú`*`‚Äù for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don‚Äôt need to worry about z-index, but it‚Äôs nice to have this feature ‚Äújust in case‚Äù.
    \*/
    eve.on = function (name, f) {
        name = String(name);
        if (typeof f != "function") {
            return function () {};
        }
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs (‚Ä¶) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event‚Äôs name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function() { return eve; })) : (glob.eve = eve));
})(this);
/**!
 * RedRaphael 1.0.0 - JavaScript Vector Library
 * Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
 *
 * Raphael 2.1.0
 * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
 * Copyright ¬© 2008-2012 Sencha Labs <http://sencha.com>
 *
 * Licensed under the MIT license.
 */
(function (glob, factory) {
    // AMD support
    if (typeof define === "function" && define.amd) {
        // Define as an anonymous module
        define('Raphael',["eve"], function( eve ) {
            return factory(glob, eve);
        });
    } else {
        // Browser globals (glob is window)
        // Raphael adds itself to window
        factory(glob, glob.eve);
    }
}(this, function (window, eve) {
    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve‚Äôs ‚ÄúDOMLoad‚Äù event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport‚Äôs 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/
    function R(first) {
        var args,
            f;

        // Code commented as resources will now be referenced using relative urls.
        // @todo Remove once we have acertained that there are no issues in any environment.
        // if (R._url) { // reinitialize URL to be safe from popstate event
        //     R._url = (R._g && R._g.win || window).location.href.replace(/#.*?$/, "");
        // }
        R._url = '';

        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        }
        else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        }
        else {
            args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function() {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }

    R.upgrade = "1.0.0";
    R.version = "2.1.0";
    R.eve = eve;
    RedRaphael = R;

    var loaded,

        undef,
        E = "",
        S = " ",
        proto = "prototype",
        has = "hasOwnProperty",
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        nu = "number",
        string = "string",
        array = "array",
        object = "object",
        finite = "finite",
        toString = "toString",
        fillString = "fill",
        push = "push",
        setAttribute = "setAttribute",
        split = "split",
        none = "none",
        black = "#000",
        OBJECTSTRING = "object",
        arrayToStr = "[object Array]",
        objectToStr = "[object Object]",
        arraySlice = Array.prototype.slice,
        arraySplice = Array.prototype.splice,
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        doc = g.doc,
        win = g.win,

        supportsTouch = R.supportsTouch = "createTouch" in doc,

        CustomAttributes = function () {
            /*\
             * Raphael.ca
             [ property (object) ]
             **
             * Shortcut for @Raphael.customAttributes
            \*/
            /*\
             * Raphael.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number across all papers you can do it
             * easily with custom attributes:
             > Usage
             | Raphael.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute ‚Äúhue‚Äù will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | Raphael.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
        },
        caproto = R.ca = R.customAttributes = CustomAttributes.prototype,

        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute ‚Äúhue‚Äù will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
            this.ca = this.customAttributes = new CustomAttributes();
            this._CustomAttributes = function () {};
            this._CustomAttributes.prototype = this.ca;
            this._elementsById = {};
            this.id = R._oid++;
            eve('raphael.new', this);
        },

        /*\
         * Raphael.fn
         [ property (object) ]
         **
         * You can add your own method to the canvas. For example if you want to draw a pie chart,
         * you can create your own pie chart function and ship it as a Rapha√´l plugin. To do this
         * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
         * Rapha√´l instance is created, otherwise it will take no effect. Please note that the
         * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
         * ensure any namespacing ensures proper context.
         > Usage
         | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
         |     return this.path( ... );
         | };
         | // or create namespace
         | Raphael.fn.mystuff = {
         |     arrow: function () {‚Ä¶},
         |     star: function () {‚Ä¶},
         |     // etc‚Ä¶
         | };
         | var paper = Raphael(10, 10, 630, 480);
         | // then use it
         | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
         | paper.mystuff.arrow();
         | paper.mystuff.star();
        \*/
        paperproto = R.fn = Paper.prototype = R.prototype,

        elements = {
            circle: 1,
            rect: 1,
            path: 1,
            ellipse: 1,
            text: 1,
            image: 1,
            group: 1
        },
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = R._touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },

        Str = win.String,
        toFloat = win.parseFloat,
        toInt = win.parseInt,
        math = win.Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        mathCos = math.cos,
        mathSin = math.sin,
        mathSqrt = math.sqrt,
        round = math.round,
        PI = math.PI,
        deg2rad = PI / 180,
        rad2deg = 180 / PI,

        lowerCase = Str.prototype.toLowerCase,
        upperCase = Str.prototype.toUpperCase,
        objectToString = win.Object.prototype.toString,
        paper = {},

        separator = /[, ]+/,
        formatrg = /\{(\d+)\}/g,
        ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^x?r(?:\(([^\)]*?)\))?/,

        isnan = {
            "NaN": 1,
            "Infinity": 1,
            "-Infinity": 1
        },
        hsrg = {
            hs: 1,
            rg: 1
        },
        availableAttrs = R._availableAttrs = {
            "arrow-end": none,
            "arrow-start": none,
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            "clip-path": E,
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "about:blank",
            "letter-spacing": 0,
            "line-height": 12,
            "vertical-align": "middle",
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: E,
            stroke: "#000",
            "stroke-dasharray": E,
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            "visibility": E,
            title: E,
            transform: E,
            rotation: 0,
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            "clip-path": "path",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        eldata = window.eeldata = {},

        sortByKey = function(a, b) {
            return a.key - b.key;
        },
        sortByNumber = function(a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function() {
        },
        pipe = function(x) {
            return x;
        },

        rectPath = R._rectPath = function(x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },

        ellipsePath = function(x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },

        getPath = R._getPath = {
            group: function() {
                return false;
            },
            path: function(el) {
                return el.attr("path");
            },
            circle: function(el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function(el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function(el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function(el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },

        /*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         > Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        mapPath = R.mapPath = function(path, matrix) {
            if (!matrix) {
                return path;
            }
            var x,
                y,
                i,
                j,
                ii,
                jj,
                pathi;

            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        },

        /*\
         * Raphael.pick
         [ method ]
         **
         * Returns the first truthy argument.
        \*/
        pick = R.pick = function() {
            for (var arg, i = 0, ii = arguments.length; i < ii; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                return arg;
            }
            return undef;
        },

        lastArgIfGroup = R._lastArgIfGroup = function (args, clear) {
            var last = args.length - 1,
                arg = args[last];

            if (arg && (arg.constructor === R.el.constructor) && arg.type === 'group') {
                if (clear) {
                    arraySplice.call(args, last, 1);
                }
                return arg;
            }
        },

        serializeArgs = R._serializeArgs = function (args) {
            var arg0 = args[0],
                attrs,
                i,
                ii;

            if (R.is(arg0, 'object') && !R.is(arg0, 'array') && arg0.type !== 'group') {

                attrs = arg0;

                if (arg0.path) {
                    pathString = arg0.path;
                    pathString && !R.is(pathString, string) &&
                        !R.is(pathString[0], array) && (pathString += E);
                }

                for (i = 1, ii = arguments.length; i < ii; i += 2) {
                    if (!attrs[arguments[i]]) {
                        attrs[arguments[i]] = arguments[i + 1];
                    }
                }
            }
            else {
                attrs = {};
                for (i = 1, ii = arguments.length; i < ii; i += 2) {
                    attrs[arguments[i]] = args[(i-1) / 2] || arguments[i+1];
                }
            }
            return attrs;
        },

        merge = R.merge = function (obj1, obj2, skipUndef, tgtArr, srcArr) {
            var item,
                srcVal,
                tgtVal,
                str,
                cRef;
            //check whether obj2 is an array
            //if array then iterate through it's index
            //**** MOOTOOLS precution

            if (!srcArr) {
                tgtArr = [obj1];
                srcArr = [obj2];
            }
            else {
                tgtArr.push(obj1);
                srcArr.push(obj2);
            }

            if (obj2 instanceof Array) {
                for (item = 0; item < obj2.length; item += 1) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (typeof tgtVal !== OBJECTSTRING) {
                        if (!(skipUndef && tgtVal === undefined)) {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                            srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
                        }
                        cRef = checkCyclicRef(tgtVal, srcArr);
                        if (cRef !== -1) {
                            srcVal = obj1[item] = tgtArr[cRef];
                        }
                        else {
                            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                        }
                    }
                }
            }
            else {
                for (item in obj2) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {
                        // Fix for issue BUG: FWXT-602
                        // IE < 9 Object.prototype.toString.call(null) gives
                        // "[object Object]" instead of "[object Null]"
                        // that's why null value becomes Object in IE < 9
                        str = objectToString.call(tgtVal);
                        if (str === objectToStr) {
                            if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                                srcVal = obj1[item] = {};
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else if (str === arrayToStr) {
                            if (srcVal === null || !(srcVal instanceof Array)) {
                                srcVal = obj1[item] = [];
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        obj1[item] = tgtVal;
                    }
                }
            }
            return obj1;
        },

        extend = R.extend = function (obj1, obj2, skipUndef) {
            if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {//if none of the arguments are object then return back
                return null;
            }

            if (typeof obj2 !== OBJECTSTRING || obj2 === null) {
                return obj1;
            }

            if (typeof obj1 !== OBJECTSTRING) {
                obj1 = obj2 instanceof Array ? [] : {};
            }
            merge(obj1, obj2, skipUndef);
            return obj1;

        },

        /*\
         * Raphael.is
         [ method ]
         **
         * Handfull replacement for `typeof` operator.
         > Parameters
         - o (‚Ä¶) any object or primitive
         - type (string) name of the type, i.e. ‚Äústring‚Äù, ‚Äúfunction‚Äù, ‚Äúnumber‚Äù, etc.
         = (boolean) is given value is of given type
        \*/
        is = R.is = function(o, type) {
            type = lowerCase.call(type);

            if (type == finite) {
                return !isnan[has](+o);
            }
            if (type == array) {
                return o instanceof Array;
            }
            if (type === 'object' && (o === undef || o === null)) {
                return false;
            }
            return  (type == "null" && o === null) ||
                (type == typeof o && o !== null) ||
                (type == object && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
        },

        /*\
          * Raphael.clone
          [ method ]
          **
          * Returns a recursively cloned version of an object.
         \*/
        clone = R.clone = function (obj) {
            if (Object(obj) !== obj) {
                return obj;
            }
            var res = new obj.constructor;
            for (var key in obj)
                if (obj[has](key)) {
                    res[key] = clone(obj[key]);
                }
            return res;
        },

         /*\
          * Raphael.createUUID
          [ method ]
          **
          * Returns RFC4122, version 4 ID
         \*/
        createUUID = R.createUUID = (function(uuidRegEx, uuidReplacer) {
            return function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
            };
        })(/[xy]/g, function(c) {
            var r = math.random() * 16 | 0,
                v = c == "x" ? r : (r & 3 | 8);
            return v.toString(16);
        });

    R._g = g;

    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be ‚ÄúSVG‚Äù, ‚ÄúVML‚Äù or empty, depending on browser support.
    \*/
    R.type = (win.ENABLE_RED_CANVAS && (win.CanvasRenderingContext2D || doc.createElement('canvas').getContext)) ? "CANVAS" :
            (win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");

    if (R.type == "VML") {
        var d = doc.createElement("div"),
            b;

        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == object)) {
            return (R.type = E);
        }
        d = null;
    }

    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/
    R.svg = !((R.vml = R.type == "VML") || (R.canvas = R.type == "CANVAS"));

    R._Paper = Paper;
    R._id = 0;
    R._oid = 0;

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
            y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * rad2deg + 360) % 360;
        }
        else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };

    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/
    R.rad = function (deg) {
        return deg % 360 * deg2rad;
    };

    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - deg (number) angle in radians
     = (number) angle in degrees.
    \*/
    R.deg = function (rad) {
        return rad * rad2deg % 360;
    };

    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/
    R.snapTo = function (values, value, tolerance) {
        var rem,
            i;

        if (!is(tolerance, finite)) {
            tolerance = 10;
        }

        if (is(values, array)) {
            i = values.length;
            while (i--) {
                if (abs(values[i] - value) <= tolerance) {
                    return values[i];
                }
            }
        }
        else {
            values = +values;
            rem = value % values;

            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
    \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        win = g.win = newwin;
        doc = g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };

    var toHex = function (color) {
            if (R.vml) {
                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                var trim = /^\s+|\s+$/g;
                var bod;
                try {
                    var docum = new ActiveXObject("htmlfile");
                    docum.write("<body>");
                    docum.close();
                    bod = docum.body;
                } catch (e) {
                    bod = createPopup().document.body;
                }
                var range = bod.createTextRange();
                toHex = cacher(function(color) {
                    try {
                        bod.style.color = Str(color).replace(trim, E);
                        var value = range.queryCommandValue("ForeColor");
                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                        return "#" + ("000000" + value.toString(16)).slice(-6);
                    } catch (e) {
                        return none;
                    }
                });
            } else {
                var i = g.doc.createElement("i");
                i.title = "Rapha\xebl Colour Picker";
                i.style.display = none;
                g.doc.body.appendChild(i);
                toHex = cacher(function(color) {
                    i.style.color = color;
                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                });
            }
            return toHex(color);
        },
        hsbtoString = function() {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
        hsltoString = function() {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
        rgbtoString = function() {
            return this.hex;
        },
        prepareRGB = function(r, g, b) {
            if (g == null && is(r, object) && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && is(r, string)) {
                var clr = R.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
        packageRGB = function(r, g, b, o) {
            var rgb = {
                r: (r *= 255),
                g: (g *= 255),
                b: (b *= 255),
                hex: R.rgb(r, g, b),
                toString: rgbtoString
            };
            is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢,
     o     error (boolean) `true` if string can‚Äôt be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    R.color = function(clr) {
        var rgb;
        if (R.is(clr, object) && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, object) && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, object) && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {
                    hex: none
                };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };

    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
     o }
    \*/
    R.hsb2rgb = function(h, s, v, o) {
        if (this.is(h, object) && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };

    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
     o }
    \*/
    R.hsl2rgb = function(h, s, l, o) {
        if (this.is(h, object) && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };

    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
    R.rgb2hsb = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
            V == r ? (g - b) / C :
            V == g ? (b - r) / C + 2 :
            (r - g) / C + 4
            );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {
            h: H,
            s: S,
            b: V,
            toString: hsbtoString
        };
    };

    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
    R.rgb2hsl = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
            M == r ? (g - b) / C :
            M == g ? (b - r) / C + 2 :
            (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
            L < .5 ? C / (2 * L) :
            C / (2 - 2 * L));
        return {
            h: H,
            s: S,
            l: L,
            toString: hsltoString
        };
    };

    R._path2string = function() {
        return this.join(",").replace(p2s, "$1");
    };

    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) {
            if (array[i] === item) {
                return array.push(array.splice(i, 1)[0]);
            }
        }
    }

    var cacher = R._cacher = function (f, scope, postprocessor) {
        function cachedfunction() {
            var arg = arraySlice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = cachedfunction.cache = cachedfunction.cache || {},
            count = cachedfunction.count = cachedfunction.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return cachedfunction;
    };

    var preload = R._preload = function(src, f) {
        var img = doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function() {
            f.call(this);
            this.onload = null;
            doc.body.removeChild(this);
        };
        img.onerror = function() {
            doc.body.removeChild(this);
        };
        doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (‚Äú<code>red</code>‚Äù, ‚Äú<code>green</code>‚Äù, ‚Äú<code>cornflowerblue</code>‚Äù, etc)</li>
     #     <li>#‚Ä¢‚Ä¢‚Ä¢ ‚Äî shortened HTML colour: (‚Äú<code>#000</code>‚Äù, ‚Äú<code>#fc0</code>‚Äù, etc)</li>
     #     <li>#‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Äî full length HTML colour: (‚Äú<code>#000000</code>‚Äù, ‚Äú<code>#bd2300</code>‚Äù)</li>
     #     <li>rgb(‚Ä¢‚Ä¢‚Ä¢, ‚Ä¢‚Ä¢‚Ä¢, ‚Ä¢‚Ä¢‚Ä¢) ‚Äî red, green and blue channels‚Äô values: (‚Äú<code>rgb(200,&nbsp;100,&nbsp;0)</code>‚Äù)</li>
     #     <li>rgb(‚Ä¢‚Ä¢‚Ä¢%, ‚Ä¢‚Ä¢‚Ä¢%, ‚Ä¢‚Ä¢‚Ä¢%) ‚Äî same as above, but in %: (‚Äú<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>‚Äù)</li>
     #     <li>hsb(‚Ä¢‚Ä¢‚Ä¢, ‚Ä¢‚Ä¢‚Ä¢, ‚Ä¢‚Ä¢‚Ä¢) ‚Äî hue, saturation and brightness values: (‚Äú<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>‚Äù)</li>
     #     <li>hsb(‚Ä¢‚Ä¢‚Ä¢%, ‚Ä¢‚Ä¢‚Ä¢%, ‚Ä¢‚Ä¢‚Ä¢%) ‚Äî same as above, but in %</li>
     #     <li>hsl(‚Ä¢‚Ä¢‚Ä¢, ‚Ä¢‚Ä¢‚Ä¢, ‚Ä¢‚Ä¢‚Ä¢) ‚Äî same as hsb</li>
     #     <li>hsl(‚Ä¢‚Ä¢‚Ä¢%, ‚Ä¢‚Ä¢‚Ä¢%, ‚Ä¢‚Ä¢‚Ä¢%) ‚Äî same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢,
     o     error (boolean) true if string can‚Äôt be parsed
     o }
    \*/
    R.getRGB = cacher(function(colour) {
        var opacity,
            res,
            red,
            green,
            blue,
            t,
            values,
            rgb;

        colour && is(colour, 'object') && "opacity" in colour &&
            (opacity = colour.opacity);
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {
                r: -1,
                g: -1,
                b: -1,
                hex: none,
                error: 1,
                toString: clrToString
            };
        }
        if (colour == none) {
            return {
                r: -1,
                g: -1,
                b: -1,
                hex: none,
                toString: clrToString
            };
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) ||
            colour.charAt() === "#") && (colour = toHex(colour));


        if ((rgb = colour.match(colourRegExp))) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {
                r: red,
                g: green,
                b: blue,
                toString: clrToString
            };
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: none,
            error: 1,
            toString: clrToString
        };
    }, R);

    R.tintshade = cacher(function(colour, percent) {
        var rgb = R.getRGB(colour),
            tint,
            offset = 255;

        (percent < 0) && (percent *= -1, offset = 0);
        (percent > 1) && (percent = 1);

        tint = percent === 0 ? rgb : {
            r: offset - (offset - rgb.r) * percent,
            g: offset - (offset - rgb.g) * percent,
            b: offset - (offset - rgb.b) * percent,
            toString: clrToString
        };
        tint.hex = R.rgb(tint.r, tint.g, tint.b);
        rgb.error && (tint.error = rgb.error);

        if ("opacity" in rgb) {
            tint.rgba = 'rgba(' + [tint.r, tint.g, tint.b, rgb.opacity].join(',') + ')';
            tint.opacity = rgb.opacity;
        }
        else {
            tint.rgba = 'rgb(' + [tint.r, tint.g, tint.b].join(',') + ')';
        }
        return tint;
    }, R);

    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
    R.hsb = cacher(function(h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });

    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
    R.hsl = cacher(function(h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });

    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
    R.rgb = cacher(function(r, g, b) {
        return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
    });

    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
    R.getColor = function(value) {
        var start = this.getColor.start = this.getColor.start || {
            h: 0,
            s: 1,
            b: value || .75
        },
        rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {
                h: 0,
                s: 1,
                b: start.b
            });
        }
        return rgb.hex;
    };

    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
    \*/
    R.getColor.reset = function() {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
            {
                x: +crp[i - 2],
                y: +crp[i - 1]
            },
            {
                x: +crp[i],
                y: +crp[i + 1]
            },
            {
                x: +crp[i + 2],
                y: +crp[i + 3]
            },
            {
                x: +crp[i + 4],
                y: +crp[i + 5]
            }
            ];
            if (z) {
                if (!i) {
                    p[0] = {
                        x: +crp[iLen - 2],
                        y: +crp[iLen - 1]
                    };
                } else if (iLen - 4 == i) {
                    p[3] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                } else if (iLen - 2 == i) {
                    p[2] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                    p[3] = {
                        x: +crp[2],
                        y: +crp[3]
                    };
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {
                        x: +crp[i],
                        y: +crp[i + 1]
                    };
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6 * p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
                ]);
        }

        return d;
    }

    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/
    R.parsePathString = function(pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            r: 4,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        },
        data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function(a, b, c) {
                var params = [],
                name = b.toLowerCase();
                c.replace(pathValues, function(a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else
                    while (params.length >= paramCounts[name]) {
                        data.push([b][concat](params.splice(0, paramCounts[name])));
                        if (!paramCounts[name]) {
                            break;
                        }
                    }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };

    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/
    R.parseTransformString = cacher(function(TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {
            r: 3,
            s: 4,
            t: 2,
            m: 6
        },
        data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function(a, b, c) {
                var params = [],
                name = lowerCase.call(b);
                c.replace(pathValues, function(a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function() {
            for (var key in p)
                if (p[has](key) && key != ps) {
                    p[key].sleep--;
                    !p[key].sleep && delete p[key];
                }
        });
        return p[ps];
    };

    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    // R.findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    //     var t1 = 1 - t,
    //     t13 = pow(t1, 3),
    //     t12 = pow(t1, 2),
    //     t2 = t * t,
    //     t3 = t2 * t,
    //     x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
    //     y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
    //     mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
    //     my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
    //     nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
    //     ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
    //     ax = t1 * p1x + t * c1x,
    //     ay = t1 * p1y + t * c1y,
    //     cx = t1 * c2x + t * p2x,
    //     cy = t1 * c2y + t * p2y,
    //     alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
    //     (mx > nx || my < ny) && (alpha += 180);
    //     return {
    //         x: x,
    //         y: y,
    //         m: {
    //             x: mx,
    //             y: my
    //         },
    //         n: {
    //             x: nx,
    //             y: ny
    //         },
    //         start: {
    //             x: ax,
    //             y: ay
    //         },
    //         end: {
    //             x: cx,
    //             y: cy
    //         },
    //         alpha: alpha
    //     };
    // };

    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/
    R.bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };

    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/
    R.isPointInsideBBox = function(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };

    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/
    // R.isBBoxIntersect = function(bbox1, bbox2) {
    //     var i = R.isPointInsideBBox;
    //     return i(bbox2, bbox1.x, bbox1.y) ||
    //         i(bbox2, bbox1.x2, bbox1.y) ||
    //         i(bbox2, bbox1.x, bbox1.y2) ||
    //         i(bbox2, bbox1.x2, bbox1.y2) ||
    //         i(bbox1, bbox2.x, bbox2.y) ||
    //         i(bbox1, bbox2.x2, bbox2.y) ||
    //         i(bbox1, bbox2.x, bbox2.y2) ||
    //         i(bbox1, bbox2.x2, bbox2.y2) ||
    //         (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x ||
    //             bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) &&
    //         (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    // };

    // function base3(t, p1, p2, p3, p4) {
    //     var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
    //     t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    //     return t * t2 - 3 * p1 + 3 * p2;
    // }

    // function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    //     if (z == null) {
    //         z = 1;
    //     }
    //     z = z > 1 ? 1 : z < 0 ? 0 : z;
    //     var z2 = z / 2,
    //     n = 12,
    //     Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
    //     Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
    //     sum = 0;
    //     for (var i = 0; i < n; i++) {
    //         var ct = z2 * Tvalues[i] + z2,
    //         xbase = base3(ct, x1, x2, x3, x4),
    //         ybase = base3(ct, y1, y2, y3, y4),
    //         comb = xbase * xbase + ybase * ybase;
    //         sum += Cvalues[i] * mathSqrt(comb);
    //     }
    //     return z2 * sum;
    // }

    // function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
    //     if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
    //         return;
    //     }
    //     var t = 1,
    //     step = t / 2,
    //     t2 = t - step,
    //     l,
    //     e = .01;
    //     l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    //     while (abs(l - ll) > e) {
    //         step /= 2;
    //         t2 += (l < ll ? 1 : -1) * step;
    //         l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    //     }
    //     return t2;
    // }

    // function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
    //     if (
    //         mmax(x1, x2) < mmin(x3, x4) ||
    //         mmin(x1, x2) > mmax(x3, x4) ||
    //         mmax(y1, y2) < mmin(y3, y4) ||
    //         mmin(y1, y2) > mmax(y3, y4)
    //         ) {
    //         return;
    //     }
    //     var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
    //     ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
    //     denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

    //     if (!denominator) {
    //         return;
    //     }
    //     var px = nx / denominator,
    //     py = ny / denominator,
    //     px2 = +px.toFixed(2),
    //     py2 = + py.toFixed(2);
    //     if (
    //         px2 < +mmin(x1, x2).toFixed(2) ||
    //         px2 > +mmax(x1, x2).toFixed(2) ||
    //         px2 < +mmin(x3, x4).toFixed(2) ||
    //         px2 > +mmax(x3, x4).toFixed(2) ||
    //         py2 < +mmin(y1, y2).toFixed(2) ||
    //         py2 > +mmax(y1, y2).toFixed(2) ||
    //         py2 < +mmin(y3, y4).toFixed(2) ||
    //         py2 > +mmax(y3, y4).toFixed(2)
    //         ) {
    //         return;
    //     }
    //     return {
    //         x: px,
    //         y: py
    //     };
    // }

    // function inter(bez1, bez2) {
    //     return interHelper(bez1, bez2);
    // }

    // function interCount(bez1, bez2) {
    //     return interHelper(bez1, bez2, 1);
    // }

    // function interHelper(bez1, bez2, justCount) {
    //     var bbox1 = R.bezierBBox(bez1),
    //         bbox2 = R.bezierBBox(bez2);

    //     if (!R.isBBoxIntersect(bbox1, bbox2)) {
    //         return justCount ? 0 : [];
    //     }
    //     var l1 = bezlen.apply(0, bez1),
    //         l2 = bezlen.apply(0, bez2),
    //         n1 = mmax(~~(l1 / 5), 1),
    //         n2 = mmax(~~(l2 / 5), 1),
    //         dots1 = [],
    //         dots2 = [],
    //         xy = {},
    //         res = justCount ? 0 : [];

    //     for (var i = 0; i < n1 + 1; i++) {
    //         var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
    //         dots1.push({
    //             x: p.x,
    //             y: p.y,
    //             t: i / n1
    //         });
    //     }
    //     for (i = 0; i < n2 + 1; i++) {
    //         p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
    //         dots2.push({
    //             x: p.x,
    //             y: p.y,
    //             t: i / n2
    //         });
    //     }
    //     for (i = 0; i < n1; i++) {
    //         for (var j = 0; j < n2; j++) {
    //             var di = dots1[i],
    //             di1 = dots1[i + 1],
    //             dj = dots2[j],
    //             dj1 = dots2[j + 1],
    //             ci = abs(di1.x - di.x) < .001 ? "y" : "x",
    //             cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
    //             is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
    //             if (is) {
    //                 if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
    //                     continue;
    //                 }
    //                 xy[is.x.toFixed(4)] = is.y.toFixed(4);
    //                 var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
    //                 t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
    //                 if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
    //                     if (justCount) {
    //                         res++;
    //                     } else {
    //                         res.push({
    //                             x: is.x,
    //                             y: is.y,
    //                             t1: mmin(t1, 1),
    //                             t2: mmin(t2, 1)
    //                         });
    //                     }
    //                 }
    //             }
    //         }
    //     }
    //     return res;
    // }

    // \
    //  * Raphael.pathIntersection
    //  [ method ]
    //  **
    //  * Utility method
    //  **
    //  * Finds intersections of two paths
    //  > Parameters
    //  - path1 (string) path string
    //  - path2 (string) path string
    //  = (array) dots of intersection
    //  o [
    //  o     {
    //  o         x: (number) x coordinate of the point
    //  o         y: (number) y coordinate of the point
    //  o         t1: (number) t value for segment of path1
    //  o         t2: (number) t value for segment of path2
    //  o         segment1: (number) order number for segment of path1
    //  o         segment2: (number) order number for segment of path2
    //  o         bez1: (array) eight coordinates representing bezi√©r curve for the segment of path1
    //  o         bez2: (array) eight coordinates representing bezi√©r curve for the segment of path2
    //  o     }
    //  o ]
    // \
    // R.pathIntersection = function(path1, path2) {
    //     return interPathHelper(path1, path2);
    // };
    // R.pathIntersectionNumber = function(path1, path2) {
    //     return interPathHelper(path1, path2, 1);
    // };
    // function interPathHelper(path1, path2, justCount) {
    //     path1 = R._path2curve(path1);
    //     path2 = R._path2curve(path2);
    //     var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
    //     res = justCount ? 0 : [];
    //     for (var i = 0, ii = path1.length; i < ii; i++) {
    //         var pi = path1[i];
    //         if (pi[0] == "M") {
    //             x1 = x1m = pi[1];
    //             y1 = y1m = pi[2];
    //         } else {
    //             if (pi[0] == "C") {
    //                 bez1 = [x1, y1].concat(pi.slice(1));
    //                 x1 = bez1[6];
    //                 y1 = bez1[7];
    //             } else {
    //                 bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
    //                 x1 = x1m;
    //                 y1 = y1m;
    //             }
    //             for (var j = 0, jj = path2.length; j < jj; j++) {
    //                 var pj = path2[j];
    //                 if (pj[0] == "M") {
    //                     x2 = x2m = pj[1];
    //                     y2 = y2m = pj[2];
    //                 } else {
    //                     if (pj[0] == "C") {
    //                         bez2 = [x2, y2].concat(pj.slice(1));
    //                         x2 = bez2[6];
    //                         y2 = bez2[7];
    //                     } else {
    //                         bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
    //                         x2 = x2m;
    //                         y2 = y2m;
    //                     }
    //                     var intr = interHelper(bez1, bez2, justCount);
    //                     if (justCount) {
    //                         res += intr;
    //                     } else {
    //                         for (var k = 0, kk = intr.length; k < kk; k++) {
    //                             intr[k].segment1 = i;
    //                             intr[k].segment2 = j;
    //                             intr[k].bez1 = bez1;
    //                             intr[k].bez2 = bez2;
    //                         }
    //                         res = res.concat(intr);
    //                     }
    //                 }
    //             }
    //         }
    //     }
    //     return res;
    // }

    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/
    R.isPointInsidePath = function(path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
        ((interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1) ||
        (interPathHelper(path, [["M", x, y], ["V", bbox.y2 + 10]], 1) % 2 == 1))
    };
    R._removedFactory = function(methodname) {
        return function() {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };

    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/
    var pathDimensions = R.pathBBox = function(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return pth.bbox;
        }
        if (!path) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                x2: 0,
                y2: 0
            };
        }
        path = path2curve(path);
        var x = 0,
        y = 0,
        X = [],
        Y = [],
        p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
        ymin = mmin[apply](0, Y),
        xmax = mmax[apply](0, X),
        ymax = mmax[apply](0, Y),
        bb = {
            x: xmin,
            y: ymin,
            x2: xmax,
            y2: ymax,
            width: xmax - xmin,
            height: ymax - ymin
        };
        pth.bbox = clone(bb);
        return bb;
    },
    pathClone = function(pathArray) {
        var res = clone(pathArray);
        res.toString = R._path2string;
        return res;
    },
    // pathToRelative = R._pathToRelative = function(pathArray) {
    //     var pth = paths(pathArray);
    //     if (pth.rel) {
    //         return pathClone(pth.rel);
    //     }
    //     if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
    //         pathArray = R.parsePathString(pathArray);
    //     }
    //     var res = [],
    //     x = 0,
    //     y = 0,
    //     mx = 0,
    //     my = 0,
    //     start = 0;
    //     if (pathArray[0][0] == "M") {
    //         x = pathArray[0][1];
    //         y = pathArray[0][2];
    //         mx = x;
    //         my = y;
    //         start++;
    //         res.push(["M", x, y]);
    //     }
    //     for (var i = start, ii = pathArray.length; i < ii; i++) {
    //         var r = res[i] = [],
    //         pa = pathArray[i];
    //         if (pa[0] != lowerCase.call(pa[0])) {
    //             r[0] = lowerCase.call(pa[0]);
    //             switch (r[0]) {
    //                 case "a":
    //                     r[1] = pa[1];
    //                     r[2] = pa[2];
    //                     r[3] = pa[3];
    //                     r[4] = pa[4];
    //                     r[5] = pa[5];
    //                     r[6] = +(pa[6] - x).toFixed(3);
    //                     r[7] = +(pa[7] - y).toFixed(3);
    //                     break;
    //                 case "v":
    //                     r[1] = +(pa[1] - y).toFixed(3);
    //                     break;
    //                 case "m":
    //                     mx = pa[1];
    //                     my = pa[2];
    //                 default:
    //                     for (var j = 1, jj = pa.length; j < jj; j++) {
    //                         r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
    //                     }
    //             }
    //         } else {
    //             r = res[i] = [];
    //             if (pa[0] == "m") {
    //                 mx = pa[1] + x;
    //                 my = pa[2] + y;
    //             }
    //             for (var k = 0, kk = pa.length; k < kk; k++) {
    //                 res[i][k] = pa[k];
    //             }
    //         }
    //         var len = res[i].length;
    //         switch (res[i][0]) {
    //             case "z":
    //                 x = mx;
    //                 y = my;
    //                 break;
    //             case "h":
    //                 x += +res[i][len - 1];
    //                 break;
    //             case "v":
    //                 y += +res[i][len - 1];
    //                 break;
    //             default:
    //                 x += +res[i][len - 2];
    //                 y += +res[i][len - 1];
    //         }
    //     }
    //     res.toString = R._path2string;
    //     pth.rel = pathClone(res);
    //     return res;
    // },
    pathToAbsolute = R._pathToAbsolute = function(pathArray) {
        var pth = paths(pathArray), res;
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
            pathArray = R.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            res = ["M", 0, 0];
            res.toString = R._path2string;
            return res;
        }
        var x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        res = [];
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y][concat](pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa[0] == "R") {
                dots = [x, y][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = ["R"][concat](pa.slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            switch (r[0]) {
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = R._path2string;
        pth.abs = pathClone(res);
        return res;
    },
    l2c = function(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    },
    q2c = function(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
        _23 = 2 / 3;
        return [
        _13 * x1 + _23 * ax,
        _13 * y1 + _23 * ay,
        _13 * x2 + _23 * ax,
        _13 * y2 + _23 * ay,
        x2,
        y2
        ];
    },
    a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
        rad = deg2rad * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function(x, y, rad) {
            var X = x * mathCos(rad) - y * mathSin(rad),
            Y = x * mathSin(rad) + y * mathCos(rad);
            return {
                x: X,
                y: Y
            };
        });
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = mathCos(deg2rad * angle),
            sin = mathSin(deg2rad * angle),
            x = (x1 - x2) / 2,
            y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = mathSqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
            ry2 = ry * ry,
            k = (large_arc_flag == sweep_flag ? -1 : 1) *
            mathSqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
            cx = k * rx * y / ry + (x1 + x2) / 2,
            cy = k * -ry * x / rx + (y1 + y2) / 2,
            f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
            f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
            x2old = x2,
            y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * mathCos(f2);
            y2 = cy + ry * mathSin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = mathCos(f1),
        s1 = mathSin(f1),
        c2 = mathCos(f2),
        s2 = mathSin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4][concat](res);
        } else {
            res = [m2, m3, m4][concat](res).join()[split](",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    },
    findDotAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    },
    curveDim = cacher(function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
        b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
        c = p1x - c1x,
        t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a,
        t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a,
        y = [p1y, p2y],
        x = [p1x, p2x],
        dot;
        abs(t1) > "1e12" && (t1 = .5);
        abs(t2) > "1e12" && (t2 = .5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
        c = p1y - c1y;
        t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a;
        t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a;
        abs(t1) > "1e12" && (t1 = .5);
        abs(t2) > "1e12" && (t2 = .5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        return {
            min: {
                x: mmin[apply](0, x),
                y: mmin[apply](0, y)
            },
            max: {
                x: mmax[apply](0, x),
                y: mmax[apply](0, y)
            }
        };
    }),
    path2curve = R._path2curve = cacher(function(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        attrs2 = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        processPath = function(path, d) {
            var nx, ny;
            if (!path) {
                return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
            }
            !(path[0] in {
                T: 1,
                Q: 1
            }) && (d.qx = d.qy = null);
            switch (path[0]) {
                case "M":
                    d.X = path[1];
                    d.Y = path[2];
                    break;
                case "A":
                    path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                    break;
                case "S":
                    nx = d.x + (d.x - (d.bx || d.x));
                    ny = d.y + (d.y - (d.by || d.y));
                    path = ["C", nx, ny][concat](path.slice(1));
                    break;
                case "T":
                    d.qx = d.x + (d.x - (d.qx || d.x));
                    d.qy = d.y + (d.y - (d.qy || d.y));
                    path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                    break;
                case "Q":
                    d.qx = path[1];
                    d.qy = path[2];
                    path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                    break;
                case "L":
                    path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                    break;
                case "H":
                    path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                    break;
                case "V":
                    path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                    break;
                case "Z":
                    path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                    break;
            }
            return path;
        },
        fixArc = function(pp, i) {
            if (pp[i].length > 7) {
                pp[i].shift();
                var pi = pp[i];
                while (pi.length) {
                    pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                }
                pp.splice(i, 1);
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        },
        fixM = function(path1, path2, a1, a2, i) {
            if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                path2.splice(i, 0, ["M", a2.x, a2.y]);
                a1.bx = 0;
                a1.by = 0;
                a1.x = path1[i][1];
                a1.y = path1[i][2];
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] = processPath(p[i], attrs);
            fixArc(p, i);
            p2 && (p2[i] = processPath(p2[i], attrs2));
            p2 && fixArc(p2, i);
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
            seg2 = p2 && p2[i],
            seglen = seg.length,
            seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }, null, pathClone),
    parseDots = R._parseDots = cacher(function(gradient) {
        var dots = [];
        for (var i = 0, ii = gradient.length; i < ii; i++) {
            var dot = {},
            par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
            dot.color = R.getRGB(par[1]);
            if (dot.color.error) {
                return null;
            }
            //store opacity information
            dot.opacity = dot.color.opacity;
            dot.color = dot.color.hex;
            par[2] && (dot.offset = par[2] + "%");
            dots.push(dot);
        }
        for (i = 1, ii = dots.length - 1; i < ii; i++) {
            if (!dots[i].offset) {
                var start = toFloat(dots[i - 1].offset || 0),
                end = 0;
                for (var j = i + 1; j < ii; j++) {
                    if (dots[j].offset) {
                        end = dots[j].offset;
                        break;
                    }
                }
                if (!end) {
                    end = 100;
                    j = ii;
                }
                end = toFloat(end);
                var d = (end - start) / (j - i + 1);
                for (; i < j; i++) {
                    start += d;
                    dots[i].offset = start + "%";
                }
            }
        }
        return dots;
    }),
    tear = R._tear = function(el, paper) {
        el == paper.top && (paper.top = el.prev);
        el == paper.bottom && (paper.bottom = el.next);
        el.next && (el.next.prev = el.prev);
        el.prev && (el.prev.next = el.next);
    },
    tofront = R._tofront = function(el, paper) {
        if (paper.top === el) {
            return false;
        }
        tear(el, paper);
        el.next = null;
        el.prev = paper.top;
        paper.top.next = el;
        paper.top = el;
        return true;
    },
    toback = R._toback = function(el, paper) {
        if (paper.bottom === el) {
            return false;
        }
        tear(el, paper);
        el.next = paper.bottom;
        el.prev = null;
        paper.bottom.prev = el;
        paper.bottom = el;
        return true;
    },
    insertafter = R._insertafter = function(el, el2, paper, paper2) {
        tear(el, paper);
        el.parent = paper2;
        el2 === paper2.top && (paper2.top = el);
        el2.next && (el2.next.prev = el);
        el.next = el2.next;
        el.prev = el2;
        el2.next = el;
    },
    insertbefore = R._insertbefore = function(el, el2, paper, paper2) {
        tear(el, paper);
        el.parent = paper2;
        el2 === paper2.bottom && (paper2.bottom = el);
        el2.prev && (el2.prev.next = el);
        el.prev = el2.prev;
        el2.prev = el;
        el.next = el2;
    },

        /*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/
    toMatrix = R.toMatrix = function(path, transform) {
        var bb = pathDimensions(path),
        el = {
            _: {
                transform: E
            },
            getBBox: function() {
                return bb;
            }
        };
        extractTransform(el, transform);
        return el.matrix;
    },

        /*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/
    transformPath = R.transformPath = function(path, transform) {
        return mapPath(path, toMatrix(path, transform));
    },
    extractTransform = R._extractTransform = function(el, tstr) {
        if (tstr == null) {
            return el._.transform;
        }
        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
        var tdata = R.parseTransformString(tstr),
        deg = 0,
        dx = 0,
        dy = 0,
        sx = 1,
        sy = 1,
        _ = el._,
        m = new Matrix;
        _.transform = tdata || [];
        if (tdata) {
            for (var i = 0, ii = tdata.length; i < ii; i++) {
                var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
                if (command == "t" && tlen == 3) {
                    if (absolute) {
                        x1 = inver.x(0, 0);
                        y1 = inver.y(0, 0);
                        x2 = inver.x(t[1], t[2]);
                        y2 = inver.y(t[1], t[2]);
                        m.translate(x2 - x1, y2 - y1);
                    } else {
                        m.translate(t[1], t[2]);
                    }
                } else if (command == "r") {
                    if (tlen == 2) {
                        bb = bb || el.getBBox(1);
                        m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        deg += t[1];
                    } else if (tlen == 4) {
                        if (absolute) {
                            x2 = inver.x(t[2], t[3]);
                            y2 = inver.y(t[2], t[3]);
                            m.rotate(t[1], x2, y2);
                        } else {
                            m.rotate(t[1], t[2], t[3]);
                        }
                        deg += t[1];
                    }
                } else if (command == "s") {
                    if (tlen == 2 || tlen == 3) {
                        bb = bb || el.getBBox(1);
                        m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        sx *= t[1];
                        sy *= t[tlen - 1];
                    } else if (tlen == 5) {
                        if (absolute) {
                            x2 = inver.x(t[3], t[4]);
                            y2 = inver.y(t[3], t[4]);
                            m.scale(t[1], t[2], x2, y2);
                        } else {
                            m.scale(t[1], t[2], t[3], t[4]);
                        }
                        sx *= t[1];
                        sy *= t[2];
                    }
                } else if (command == "m" && tlen == 7) {
                    m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                }
                _.dirtyT = 1;
                el.matrix = m;
            }
        }

        /*\
         * Element.matrix
         [ property (object) ]
         **
         * Keeps @Matrix object, which represents element transformation
        \*/
        el.matrix = m;

        _.sx = sx;
        _.sy = sy;
        _.deg = deg;
        _.dx = dx = m.e;
        _.dy = dy = m.f;

        if (sx == 1 && sy == 1 && !deg && _.bbox) {
            _.bbox.x += +dx;
            _.bbox.y += +dy;
        } else {
            _.dirtyT = 1;
        }
    },
    getEmpty = function(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t":
                return [l, 0, 0];
            case "m":
                return [l, 1, 0, 0, 1, 0, 0];
            case "r":
                if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
            case "s":
                if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
        }
    },
    equaliseTransform = R._equaliseTransform = function(t1, t2) {
        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
        t1 = R.parseTransformString(t1) || [];
        t2 = R.parseTransformString(t2) || [];
        var maxlength = mmax(t1.length, t2.length),
        from = [],
        to = [],
        i = 0, j, jj,
        tt1, tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if ((tt1[0] != tt2[0]) ||
                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                ) {
                return;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: from,
            to: to
        };
    };
    R._getContainer = function(x, y, w, h) {
        var container;
        container = h == null && !R.is(x, object) ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };

    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    // R.pathToRelative = pathToRelative;
    R._engine = {};

    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.path2curve = path2curve;

    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/
    R.matrix = function(a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };

    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function(matrixproto) {

        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function(a, b, c, d, e, f) {
            var out = [[], [], []],
            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
            x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };

        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function() {
            var me = this,
            x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };

        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function() {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };

        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
        \*/
        matrixproto.translate = function(x, y) {
            this.add(1, 0, 0, 1, x, y);
        };

        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/
        matrixproto.scale = function(x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };

        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/
        matrixproto.rotate = function(a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +mathCos(a).toFixed(9),
            sin = + mathSin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };

        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function(x, y) {
            return x * this.a + y * this.c + this.e;
        };

        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function(x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function(i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function() {
            return R.svg ?
            "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
            [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toMatrixString = function() {
            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
        };
        matrixproto.toFilter = function() {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
            ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
            ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function() {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = mathSqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }

        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function() {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = mathSqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = mathSqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
            cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };

        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function(shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
        (navigator.vendor == "Google Inc." && version && version[1] < 8)) {

        /*\
         * Paper.safari
         [ method ]
         **
         * There is an inconvenient rendering bug in Safari (WebKit):
         * sometimes the rendering should be forced.
         * This method should help with dealing with this bug.
        \*/
        paperproto.safari = function() {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
                stroke: "none"
            });
            setTimeout(function() {
                rect.remove();
            });
            return true;
        };
    } else {
        paperproto.safari = fun;
    }

    var preventDefault = function() {
        this.returnValue = false;
    },
    preventTouch = function() {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function() {
        this.cancelBubble = true;
    },
    stopTouch = function() {
        return this.originalEvent.stopPropagation();
    },
    addEvent = R.addEvent = (function() {
        if (g.doc.addEventListener) {
            return function(obj, type, fn, element) {
                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                f = function(e) {
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                    if (supportsTouch && touchMap[has](type)) {
                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                var olde = e;
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }
                    }
                    return fn.call(element, e, e.clientX + scrollX, e.clientY + scrollY);
                };
                obj.addEventListener(realName, f, false);
                return function() {
                    obj.removeEventListener(realName, f, false);
                    return true;
                };
            };
        } else if (g.doc.attachEvent) {
            return function(obj, type, fn, element) {
                var f = function(e) {
                    e = e || g.win.event;
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                    x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e, x, y);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function() {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),

    drag = [],

    dragMove = function(e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;

        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches.length,
                touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }

            if (dragi.el.removed) {
                continue;
            }

            var node = R._engine.getNode(dragi.el),
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;

            g.win.opera && parent.removeChild(node);

            node.style.display = "none";
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function(e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;

        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    },

    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn‚Äôt affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \*/
    elproto = R.el = {};

    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--; ) {
        (function(eventName) {
            R[eventName] = elproto[eventName] = function(fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                    });
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function(fn) {
                var events = this.events || [],
                l = events.length;
                while (l--)
                    if (events[l].name == eventName && events[l].f == fn) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                        return this;
                    }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function(key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 1) {
            if (R.is(key, object)) {
                for (var i in key)
                    if (key[has](i)) {
                        this.data(i, key[i]);
                    }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };

    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            delete eldata[this.id];
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };

     /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
    \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };

    var downables = window.ddownables = [],
        mouseDown = function () {
            this.untrack = addEvent(g.doc, 'mouseup', mouseUp, this);
        },
        mouseUp = function () {
            this.untrack();
            this.untrack = null;
            return this.fn && this.fn.apply(this.scope || this.el, arguments);

        };
    elproto.mouseup = function (fn, scope, track) {
        if (!track) {
            return R.mouseup.apply(this, arguments);
        }
        downables.push(track = {
            el: this,
            fn: fn,
            scope: scope
        });
        track.unbind = addEvent(this.shape || this.node || g.doc,
            'mousedown', mouseDown, track);

        return this;
    };

    elproto.unmouseup = function (fn) {
        var i = downables.length,
            undowned;
        while (i--) {
            if (downables[i].el === this && downables[i].fn === fn) {
                undowned = downables[i];
                undowned.unbind();
                undowned.untrack && undowned.untrack();
                downables.splice(i, 1);
            }
        }
        return undowned ? this : R.unmouseup.apply(this, arguments);
    };

    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function(f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };

    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function(f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];

    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

            this._drag.x = e.clientX + scrollX;
            this._drag.y = e.clientY + scrollY;
            this._drag.id = e.identifier;

            !drag.length && R.mousemove(dragMove).mouseup(dragUp);

            drag.push({
                el: this,
                move_scope: move_scope,
                start_scope: start_scope,
                end_scope: end_scope
            });

            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({
            el: this,
            start: start
        });
        this.mousedown(start);
        return this;
    };

    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    elproto.onDragOver = function(f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };

    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/
    elproto.undrag = function() {
        var i = draggable.length;
        while (i--) {
            if (draggable[i].el == this) {
                this.unmousedown(draggable[i].start);
                draggable.splice(i, 1);
                eve.unbind("raphael.drag.*." + this.id);
            }
        }

        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        delete this._drag;
    };

    elproto.follow = function(el, callback, stalk) {
        if (el.removed || el.constructor !== R.el.constructor) {
            return this;
        }
        el.followers.push({
            el: this,
            stalk: (stalk = {before: 'insertBefore', after: 'insertAfter'}[stalk]),
            cb: callback
        });

        stalk && this[stalk](el);
        return this;
    };

    elproto.unfollow = function(el) {
        if (el.removed || el.constructor !== R.el.constructor) {
            return this;
        }
        for (var i = 0, ii = el.followers.length; i < ii; i++) {
            if (el.followers[i].el === this) {
                el.followers.splice(i, 1);
                break;
            }
        }
        return this;
    };

    /*\
     * Paper.hide
     [ method ]
     **
     * Hides a paper
     **
     > Usage
     | paper.hide();
    \*/
    paperproto.hide = function () {
        var paper = this;
        paper.canvas.style.visibility = "hidden";
        return paper;
    };

    /*\
     * Paper.show
     [ method ]
     **
     * Shows a hidden paper
     **
     > Usage
     | paper.show();
    \*/
    paperproto.show = function () {
        var paper = this;
        paper.canvas.style.visibility = E;
        return paper;
    };

    /*\
     * Paper.group
     [ method ]
     **
     * Creates a group
     **
     > Parameters
     **
     - id (number) id of the group
     = (object) Rapha√´l element object with type ‚Äúgroup‚Äù
     **
     > Usage
     | var g = paper.group();
    \*/
    paperproto.group = function () { // id
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            out = R._engine.group(paper, args[0], group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Rapha√´l element object with type ‚Äúcircle‚Äù
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    paperproto.circle = function () { // x, y, r
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "cx", 0,
                "cy", 0,
                "r", 0,
                "fill", none,
                "stroke", black),
            out = R._engine.circle(paper, attrs, group);

        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };


    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Rapha√´l element object with type ‚Äúrect‚Äù
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    paperproto.rect = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "x", 0,
                "y", 0,
                "width", 0,
                "height", 0,
                "r", 0,
                "fill", none,
                "stroke", black),
            out = R._engine.rect(paper, attrs, group);

        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Rapha√´l element object with type ‚Äúellipse‚Äù
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    paperproto.ellipse = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "x", 0,
                "y", 0,
                "rx", 0,
                "ry", 0,
                "fill", none,
                "stroke", black),
            out = R._engine.ellipse(this, attrs, group);

        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: ‚ÄúM‚Äù, with arguments `(10, 20)` and ‚ÄúL‚Äù with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case‚Äîrelative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic B√©zier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic B√©zier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull‚ÄìRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * ‚ÄúCatmull-Rom curveto‚Äù is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: ‚ÄúM10,10R‚Ä¶z‚Äù. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/
    paperproto.path = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "path", E,
                "fill", none,
                "stroke", black),
            out = R._engine.path(paper, attrs, group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Rapha√´l element object with type ‚Äúimage‚Äù
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    paperproto.image = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "src", "about:blank",
                "x", 0,
                "y", 0,
                "width", 0,
                "height", 0)
            out = R._engine.image(paper, attrs, group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put ‚Äú\n‚Äù in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Rapha√´l element object with type ‚Äútext‚Äù
     **
     > Usage
     | var t = paper.text(50, 50, "Rapha√´l\nkicks\nbutt!");
    \*/
    paperproto.text = function() {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "x", 0,
                "y", 0,
                "text", E,
                "stroke", none,
                "fill", black,
                "text-anchor", "middle",
                "vertical-align", "middle"),

            out = R._engine.text(paper, attrs, group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn‚Äôt create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements ‚Äî all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.set = function(itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = arraySplice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        return out;
    };

    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.setStart = function(set) {
        this.__set__ = set || this.set();
    };

    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/
    paperproto.setFinish = function(set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };

    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/
    paperproto.setSize = function(width, height) {
        return R._engine.setSize.call(this, width, height);
    };

    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/
    paperproto.setViewBox = function(x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };

    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/
    paperproto.top = paperproto.bottom = null;

    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/
    paperproto.raphael = R;

    var getOffset = function(elem) {
        var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };

    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Rapha√´l element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
    // paperproto.getElementByPoint = function(x, y) {
    //     var paper = this,
    //     svg = paper.canvas,
    //     target = g.doc.elementFromPoint(x, y);
    //     if (g.win.opera && target.tagName == "svg") {
    //         var so = getOffset(svg),
    //         sr = svg.createSVGRect();
    //         sr.x = x - so.x;
    //         sr.y = y - so.y;
    //         sr.width = sr.height = 1;
    //         var hits = svg.getIntersectionList(sr, null);
    //         if (hits.length) {
    //             target = hits[hits.length - 1];
    //         }
    //     }
    //     if (!target) {
    //         return null;
    //     }
    //     while (target.parentNode && target != svg.parentNode && !target.raphael) {
    //         target = target.parentNode;
    //     }
    //     target == paper.canvas.parentNode && (target = svg);
    //     target = target && target.raphael ? paper.getById(target.raphaelid) : null;
    //     return target;
    // };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
     paperproto.getElementsByBBox = function (bbox) {
         var set = this.set();
         this.forEach(function (el) {
             if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                 set.push(el);
             }
         });
         return set;
     };

    paperproto.getById = function(id) {
        return this._elementsById[id] || null;
    };

    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/
    paperproto.forEach = function(callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };

    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/
    paperproto.getElementsByPoint = function(x, y) {
        var set = this.set();
        this.forEach(function(el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }

    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element‚Äôs shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/
    elproto.isPointInside = function(x, y) {
        var rp = this.realPath = this.realPath || getPath[this.type](this),
            tr;
        return R.isPointInsidePath(((tr = this.attr('transform')) &&
                tr.length && R.transformPath(rp, tr)) || rp, x, y);
    };

    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/
    elproto.getBBox = function(isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };

    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/
    elproto.clone = function() {
        if (this.removed) {
            return null;
        }
        var o = this,
            out = o.paper[o.type]().attr(o.attr());
        o.__set__ && o.__set__.push(out);
        return out;
    };

    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won‚Äôt adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/
    elproto.glow = function(glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity || .5,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        },
        c = s.width / 2,
        r = this.paper,
        out = r.set(),
        path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    },
    getLengthFactory = function(istotal, subpath) {
        return function(path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
            len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {
                                return sp;
                            }
                            subpaths.start = sp;
                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {
                                x: point.x,
                                y: point.y,
                                alpha: point.alpha
                            };
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {
                x: point.x,
                y: point.y,
                alpha: point.alpha
            });
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
    getPointAtLength = getLengthFactory(),
    getSubpathsAtLength = getLengthFactory(0, 1);

    R.getTotalLength = getTotalLength;

    R.getPointAtLength = getPointAtLength;

    R.getSubpath = function(path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };

    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/
    elproto.getTotalLength = function() {
        if (this.type != "path") {
            return;
        }
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
        return getTotalLength(this.attrs.path);
    };

    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function(length) {
        if (this.type != "path") {
            return;
        }
        return getPointAtLength(this.attrs.path, length);
    };

    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    elproto.getSubpath = function(from, to) {
        if (this.type != "path") {
            return;
        }
        return R.getSubpath(this.attrs.path, from, to);
    };

    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>‚Äúlinear‚Äù</li>
     #     <li>‚Äú&lt;‚Äù or ‚ÄúeaseIn‚Äù or ‚Äúease-in‚Äù</li>
     #     <li>‚Äú>‚Äù or ‚ÄúeaseOut‚Äù or ‚Äúease-out‚Äù</li>
     #     <li>‚Äú&lt;>‚Äù or ‚ÄúeaseInOut‚Äù or ‚Äúease-in-out‚Äù</li>
     #     <li>‚ÄúbackIn‚Äù or ‚Äúback-in‚Äù</li>
     #     <li>‚ÄúbackOut‚Äù or ‚Äúback-out‚Äù</li>
     #     <li>‚Äúelastic‚Äù</li>
     #     <li>‚Äúbounce‚Äù</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
    \*/
    var ef = R.easing_formulas = {
        linear: function(n) {
            return n;
        },
        "<": function(n) {
            return pow(n, 1.7);
        },
        ">": function(n) {
            return pow(n, .48);
        },
        "<>": function(n) {
            var q = .48 - n / 1.04,
            Q = mathSqrt(.1734 + q * q),
            x = Q - q,
            X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function(n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function(n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function(n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * mathSin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function(n) {
            var s = 7.5625,
            p = 2.75,
            l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
    requestAnimFrame = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 16);
    },
    animation = function() {
        var Now = +new Date,
        l = 0;
        for (; l < animationElements.length; l++) {
            var e = animationElements[l];
            if (e.el.removed || e.paused) {
                continue;
            }
            var time = Now - e.start,
            ms = e.ms,
            easing = e.easing,
            from = e.from,
            diff = e.diff,
            to = e.to,
            t = e.t,
            that = e.el,
            set = {},
            now,
            init = {},
            key;
            if (e.initstatus) {
                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                e.status = e.initstatus;
                delete e.initstatus;
                e.stop && animationElements.splice(l--, 1);
            } else {
                e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
            }
            if (time < 0) {
                continue;
            }
            if (time < ms) {
                var pos = easing(time / ms);
                for (var attr in from)
                    if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = (+from[attr][i][j] + pos * ms * diff[attr][i][j]).toFixed(4);
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function(i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.ca[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                that.attr(set);
                (function(id, that, anim) {
                    setTimeout(function() {
                        eve("raphael.anim.frame." + id, that, anim);
                    });
                })(that.id, that, e.anim);
            } else {
                (function(f, el, a) {
                    setTimeout(function() {
                        eve("raphael.anim.frame." + el.id, el, a);
                        eve("raphael.anim.finish." + el.id, el, a);
                        R.is(f, "function") && f.call(el);
                    });
                })(e.callback, that, e.anim);
                that.attr(to);
                animationElements.splice(l--, 1);
                if (e.repeat > 1 && !e.next) {
                    for (key in to)
                        if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                    e.el.attr(init);
                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                }
                if (e.next && !e.stop) {
                    runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                }
            }
        }
        R.svg && that && that.paper && that.paper.safari();
        animationElements.length && requestAnimFrame(animation);
    },
    upto255 = function(color) {
        return color > 255 ? 255 : color < 0 ? 0 : color;
    };

    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animateWith = function(el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
        x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
    //
    //
    // var a = params ? R.animation(params, ms, easing, callback) : anim,
    //     status = element.status(anim);
    // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
        bx = 3 * (p2x - p1x) - cx,
        ax = 1 - cx - bx,
        cy = 3 * p1y,
        by = 3 * (p2y - p1y) - cy,
        ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for (t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function(f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
        newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim)
                if (anim[has](attr)) {
                    newAnim[toFloat(attr)] = anim[attr];
                    percents.push(toFloat(attr));
                }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }

    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/
    Animation.prototype.delay = function(delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };

    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/
    Animation.prototype.repeat = function(times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
        isInAnim,
        isInAnimSet,
        percents = [],
        next,
        prev,
        timestamp,
        ms = anim.ms,
        from = {},
        to = {},
        diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params)
                if (params[has](attr)) {
                    if (availableAnimAttrs[has](attr) || element.ca[attr]) {
                        from[attr] = element.attr(attr);
                        (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                        to[attr] = params[attr];
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                diff[attr] = (to[attr] - from[attr]) / ms;
                                break;
                            case "colour":
                                from[attr] = R.getRGB(from[attr]);
                                var toColour = R.getRGB(to[attr]);
                                diff[attr] = {
                                    r: (toColour.r - from[attr].r) / ms,
                                    g: (toColour.g - from[attr].g) / ms,
                                    b: (toColour.b - from[attr].b) / ms
                                };
                                break;
                            case "path":
                                var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                                from[attr] = pathes[0];
                                diff[attr] = [];
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [0];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                                break;
                            case "transform":
                                var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                                if (eq) {
                                    from[attr] = eq.from;
                                    to[attr] = eq.to;
                                    diff[attr] = [];
                                    diff[attr].real = true;
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        diff[attr][i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                        }
                                    }
                                } else {
                                    var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {
                                            transform: _.transform
                                        },
                                        getBBox: function() {
                                            return element.getBBox(1);
                                        }
                                    };
                                    from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                    ];
                                    extractTransform(to2, to[attr]);
                                    to[attr] = to2._.transform;
                                    diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                    ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                                }
                                break;
                            case "csv":
                                var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                                if (attr == "clip-rect") {
                                    from[attr] = from2;
                                    diff[attr] = [];
                                    i = from2.length;
                                    while (i--) {
                                        diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                    }
                                }
                                to[attr] = values;
                                break;
                            default:
                                values = [][concat](params[attr]);
                                from2 = [][concat](from[attr]);
                                diff[attr] = [];
                                i = element.ca[attr].length;
                                while (i--) {
                                    diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                                }
                                break;
                        }
                    }
                }
            var easing = params.easing,
            easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function(t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }

    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/
    R.animation = function(params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
        json,
        attr;
        for (attr in params)
            if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
                json = true;
                p[attr] = params[attr];
            }
        if (!json) {
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({
                100: p
            }, ms);
        }
    };

    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animate = function(params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };

    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
    \*/
    elproto.setTime = function(anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };

    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 ‚Äì 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/
    elproto.status = function(anim, value) {
        var out = [],
        i = 0,
        len,
        e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };

    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.pause = function(anim) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                    animationElements[i].paused = true;
                }
            }
        return this;
    };

    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.resume = function(anim) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                var e = animationElements[i];
                if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                    delete e.paused;
                    this.status(e.anim, e.status);
                }
            }
        return this;
    };

    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.stop = function(anim) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                    animationElements.splice(i--, 1);
                }
            }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.paper == paper) {
                animationElements.splice(i--, 1);
            }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function() {
        return "Rapha\xebl\u2019s object";
    };

    elproto.toFront = function() {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            parent = o.parent,
            followers = o.followers,
            follower,
            i,
            ii;

        if (R._tofront(o, parent)) {
            parent.canvas.appendChild(thisNode);
        }

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](o);
        }
        return o;
    };

    elproto.toBack = function() {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            parent = o.parent,
            followers = o.followers,
            follower,
            i,
            ii;

        if (R._toback(o, parent)) {
            parent.canvas.insertBefore(thisNode, parent.canvas.firstChild);
        }

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](o);
        }
        return o;
    };

    elproto.insertAfter = function(element) {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            thatNode = R._engine.getLastNode(element),
            parentNode = element.parent.canvas,
            followers = o.followers,
            follower,
            i,
            ii;

        if (thatNode.nextSibling) {
            parentNode.insertBefore(thisNode, thatNode.nextSibling);
        }
        else {
            parentNode.appendChild(thisNode);
        }
        R._insertafter(o, element, o.parent, element.parent);

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk &&
                follower.el[follower.stalk](element);
        }
        return o;
    };

    elproto.insertBefore = function(element) {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            thatNode = R._engine.getNode(element),
            followers = o.followers,
            follower,
            i,
            ii;

        element.parent.canvas.insertBefore(thisNode, thatNode);
        R._insertbefore(o, element, o.parent, element.parent);
        o.parent = element.parent;

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk &&
                follower.el[follower.stalk](element);
        }
        return this;
    };

    elproto.appendChild = function (element) {
        if (this.removed || this.type !== 'group') {
            return this;
        }

        var group = this,
            followers = group.followers,
            follower,
            thatNode,
            i,
            ii;

        // If appending in same group, simply perform toFront().
        if (element.parent === group) {
            element.toFront();
            return group;
        }

        thatNode = R._engine.getNode(element);

        // first remove from own group
        R._tear(element, element.parent);

        group.canvas.appendChild(thatNode);
        element.parent = group;

        !group.bottom && (group.bottom = element);
        element.prev = group.top;
        element.next = null;
        group.top && (group.top.next = element);
        group.top = element;

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk &&
                follower.el[follower.stalk](element);
        }

        return group;
    };

    elproto.removeChild = function (element) {
        if (this.removed || this.type !== 'group' || element.parent !== this) {
            return this;
        }

        var o = this,
            thatNode = R._engine.getNode(element),
            paper = o.paper;

        R._tear(element, o);
        paper.canvas.appendChild(thatNode);

        o.parent = paper;
        !paper.bottom && (paper.bottom = o);

        o.prev = paper.top;
        paper.top && (paper.top.next = o);
        paper.top = o;
        o.next = null;

        return o;
    };

    // Set
    var Set = function(items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    };
    setproto = Set.prototype;

    // /*\
    //  * Set.push
    //  [ method ]
    //  **
    //  * Adds each argument to the current set.
    //  = (object) original element
    // \*/
    // setproto.push = function() {
    //     var item,
    //     len;
    //     for (var i = 0, ii = arguments.length; i < ii; i++) {
    //         item = arguments[i];
    //         if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
    //             len = this.items.length;
    //             this[len] = this.items[len] = item;
    //             this.length++;
    //         }
    //     }
    //     return this;
    // };

    // /*\
    //  * Set.pop
    //  [ method ]
    //  **
    //  * Removes last element and returns it.
    //  = (object) element
    // \*/
    // setproto.pop = function() {
    //     this.length && delete this[this.length--];
    //     return this.items.pop();
    // };

    // /*\
    //  * Set.forEach
    //  [ method ]
    //  **
    //  * Executes given function for each element in the set.
    //  *
    //  * If function returns `false` it will stop loop running.
    //  **
    //  > Parameters
    //  **
    //  - callback (function) function to run
    //  - thisArg (object) context object for the callback
    //  = (object) Set object
    // \*/
    // setproto.forEach = function(callback, thisArg) {
    //     for (var i = 0, ii = this.items.length; i < ii; i++) {
    //         if (callback.call(thisArg, this.items[i], i) === false) {
    //             return this;
    //         }
    //     }
    //     return this;
    // };
    // for (var method in elproto)
    //     if (elproto[has](method)) {
    //         setproto[method] = (function(methodname) {
    //             return function() {
    //                 var arg = arguments;
    //                 return this.forEach(function(el) {
    //                     el[methodname][apply](el, arg);
    //                 });
    //             };
    //         })(method);
    //     }
    // setproto.attr = function(name, value) {
    //     if (name && R.is(name, array) && R.is(name[0], object)) {
    //         for (var j = 0, jj = name.length; j < jj; j++) {
    //             this.items[j].attr(name[j]);
    //         }
    //     } else {
    //         for (var i = 0, ii = this.items.length; i < ii; i++) {
    //             this.items[i].attr(name, value);
    //         }
    //     }
    //     return this;
    // };

    // /*\
    //  * Set.clear
    //  [ method ]
    //  **
    //  * Removeds all elements from the set
    // \*/
    // setproto.clear = function() {
    //     while (this.length) {
    //         this.pop();
    //     }
    // };

    // /*\
    //  * Set.splice
    //  [ method ]
    //  **
    //  * Removes given element from the set
    //  **
    //  > Parameters
    //  **
    //  - index (number) position of the deletion
    //  - count (number) number of element to remove
    //  - insertion‚Ä¶ (object) #optional elements to insert
    //  = (object) set elements that were deleted
    // \*/
    // setproto.splice = function(index, count, insertion) {
    //     index = index < 0 ? mmax(this.length + index, 0) : index;
    //     count = mmax(0, mmin(this.length - index, isNaN(count) && this.length || count));
    //     var tail = [],
    //     todel = [],
    //     args = [],
    //     i;
    //     for (i = 2; i < arguments.length; i++) {
    //         args.push(arguments[i]);
    //     }
    //     for (i = 0; i < count; i++) {
    //         todel.push(this[index + i]);
    //     }
    //     for (; i < this.length - index; i++) {
    //         tail.push(this[index + i]);
    //     }
    //     var arglen = args.length;
    //     for (i = 0; i < arglen + tail.length; i++) {
    //         this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
    //     }
    //     i = this.items.length = this.length -= count - arglen;
    //     while (this[i]) {
    //         delete this[i++];
    //     }
    //     return new Set(todel);
    // };

    // /*\
    //  * Set.exclude
    //  [ method ]
    //  **
    //  * Removes given element from the set
    //  **
    //  > Parameters
    //  **
    //  - element (object) element to remove
    //  = (boolean) `true` if object was found & removed from the set
    // \*/
    // setproto.exclude = function(el) {
    //     for (var i = 0, ii = this.length; i < ii; i++)
    //         if (this[i] == el) {
    //             this.splice(i, 1);
    //             return true;
    //         }
    // };
    // setproto.animate = function(params, ms, easing, callback) {
    //     (R.is(easing, "function") || !easing) && (callback = easing || null);
    //     var len = this.items.length,
    //     i = len,
    //     item,
    //     set = this,
    //     collector;
    //     if (!len) {
    //         return this;
    //     }
    //     callback && (collector = function() {
    //         !--len && callback.call(set);
    //     });
    //     easing = R.is(easing, string) ? easing : collector;
    //     var anim = R.animation(params, ms, easing, collector);
    //     item = this.items[--i].animate(anim);
    //     while (i--) {
    //         this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
    //     }
    //     return this;
    // };
    // setproto.insertAfter = function(el) {
    //     var i = this.items.length;
    //     while (i--) {
    //         this.items[i].insertAfter(el);
    //     }
    //     return this;
    // };
    // setproto.getBBox = function() {
    //     var x = [],
    //     y = [],
    //     x2 = [],
    //     y2 = [];
    //     for (var i = this.items.length; i--; )
    //         if (!this.items[i].removed) {
    //             var box = this.items[i].getBBox();
    //             x.push(box.x);
    //             y.push(box.y);
    //             x2.push(box.x + box.width);
    //             y2.push(box.y + box.height);
    //         }
    //     x = mmin[apply](0, x);
    //     y = mmin[apply](0, y);
    //     x2 = mmax[apply](0, x2);
    //     y2 = mmax[apply](0, y2);
    //     return {
    //         x: x,
    //         y: y,
    //         x2: x2,
    //         y2: y2,
    //         width: x2 - x,
    //         height: y2 - y
    //     };
    // };
    // setproto.clone = function(s) {
    //     s = new Set;
    //     for (var i = 0, ii = this.items.length; i < ii; i++) {
    //         s.push(this.items[i].clone());
    //     }
    //     return s;
    // };
    // setproto.toString = function() {
    //     return "Rapha\xebl\u2018s set";
    // };

    //  setproto.glow = function(glowConfig) {
    //      var ret = this.paper.set();
    //      this.forEach(function(shape, index){
    //          var g = shape.glow(glowConfig);
    //          if(g != null){
    //              g.forEach(function(shape2, index2){
    //                  ret.push(shape2);
    //              });
    //          }
    //      });
    //      return ret;
    //  };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Rapha√´l. Should be used as an internal call from within Cuf√≥n‚Äôs font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cuf√≥n and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({‚Ä¶}));
    \*/
    // R.registerFont = function(font) {
    //     if (!font.face) {
    //         return font;
    //     }
    //     this.fonts = this.fonts || {};
    //     var fontcopy = {
    //         w: font.w,
    //         face: {},
    //         glyphs: {}
    //     },
    //     family = font.face["font-family"];
    //     for (var prop in font.face)
    //         if (font.face[has](prop)) {
    //             fontcopy.face[prop] = font.face[prop];
    //         }
    //     if (this.fonts[family]) {
    //         this.fonts[family].push(fontcopy);
    //     } else {
    //         this.fonts[family] = [fontcopy];
    //     }
    //     if (!font.svg) {
    //         fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
    //         for (var glyph in font.glyphs)
    //             if (font.glyphs[has](glyph)) {
    //                 var path = font.glyphs[glyph];
    //                 fontcopy.glyphs[glyph] = {
    //                     w: path.w,
    //                     k: {},
    //                     d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function(command) {
    //                         return {
    //                             l: "L",
    //                             c: "C",
    //                             x: "z",
    //                             t: "m",
    //                             r: "l",
    //                             v: "c"
    //                         }
    //                         [command] || "M";
    //                     }) + "z"
    //                 };
    //                 if (path.k) {
    //                     for (var k in path.k)
    //                         if (path[has](k)) {
    //                             fontcopy.glyphs[glyph].k[k] = path.k[k];
    //                         }
    //                 }
    //             }
    //     }
    //     return font;
    // };

    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like ‚ÄúMyriad‚Äù for ‚ÄúMyriad Pro‚Äù.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/
    // paperproto.getFont = function(family, weight, style, stretch) {
    //     stretch = stretch || "normal";
    //     style = style || "normal";
    //     weight = +weight || {
    //         normal: 400,
    //         bold: 700,
    //         lighter: 300,
    //         bolder: 800
    //     }
    //     [weight] || 400;
    //     if (!R.fonts) {
    //         return;
    //     }
    //     var font = R.fonts[family];
    //     if (!font) {
    //         var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
    //         for (var fontName in R.fonts)
    //             if (R.fonts[has](fontName)) {
    //                 if (name.test(fontName)) {
    //                     font = R.fonts[fontName];
    //                     break;
    //                 }
    //             }
    //     }
    //     var thefont;
    //     if (font) {
    //         for (var i = 0, ii = font.length; i < ii; i++) {
    //             thefont = font[i];
    //             if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
    //                 break;
    //             }
    //         }
    //     }
    //     return thefont;
    // };

    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/
    // paperproto.print = function(x, y, string, font, size, origin, letter_spacing) {
    //     origin = origin || "middle"; // baseline|middle
    //     letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
    //     var letters = Str(string)[split](E),
    //     shift = 0,
    //     notfirst = 0,
    //     path = E,
    //     scale;
    //     R.is(font, string) && (font = this.getFont(font));
    //     if (font) {
    //         scale = (size || 16) / font.face["units-per-em"];
    //         var bb = font.face.bbox[split](separator),
    //         top = +bb[0],
    //         lineHeight = bb[3] - bb[1],
    //         shifty = 0,
    //         height = + bb[1] + (origin == "baseline" ? lineHeight + ( + font.face.descent) : lineHeight / 2);
    //         for (var i = 0, ii = letters.length; i < ii; i++) {
    //             if (letters[i] == "\n") {
    //                 shift = 0;
    //                 curr = 0;
    //                 notfirst = 0;
    //                 shifty += lineHeight;
    //             } else {
    //                 var prev = notfirst && font.glyphs[letters[i - 1]] || {},
    //                 curr = font.glyphs[letters[i]];
    //                 shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
    //                 notfirst = 1;
    //             }
    //             if (curr && curr.d) {
    //                 path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
    //             }
    //         }
    //     }
    //     return this.path(path).attr({
    //         fill: "#000",
    //         stroke: "none"
    //     });
    // };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/
    paperproto.add = function(json) {
        if (R.is(json, "array")) {
            var res = this.set(),
            i = 0,
            ii = json.length,
            j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type ‚Äú`{<number>}`‚Äù to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - ‚Ä¶ (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/
    R.format = function(token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function(str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };

    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type ‚Äú`{<name>}`‚Äù to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
    // R.fullfill = (function() {
    //     var tokenRegex = /\{([^\}]+)\}/g,
    //     objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
    //     replacer = function(all, key, obj) {
    //         var res = obj;
    //         key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {
    //             name = name || quotedName;
    //             if (res) {
    //                 if (name in res) {
    //                     res = res[name];
    //                 }
    //                 typeof res == "function" && isFunc && (res = res());
    //             }
    //         });
    //         res = (res == null || res == obj ? all : res) + "";
    //         return res;
    //     };
    //     return function(str, obj) {
    //         return String(str).replace(tokenRegex, function(all, key) {
    //             return replacer(all, key, obj);
    //         });
    //     };
    // })();

    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Rapha√´l (Well, Rapha√´l creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     ‚Ä¶
     | })(Raphael.ninja());
    \*/
    // R.ninja = function() {
    //     oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
    //     return R;
    // };

    // var crispFixer = (R.vml && 0.5 || 0);

    // R.crispBound = cacher(function (x, y, w, h, s) {
    //     var at = {},
    //         normalizer;

    //     x = x || 0;
    //     y = y || 0;
    //     w = w || 0;
    //     h = h || 0;
    //     s = s || 0;
    //     normalizer = s % 2 / 2 + crispFixer;

    //     // normalize for crisp edges
    //     at.x = round(x + normalizer) - normalizer;
    //     at.y = round(y + normalizer) - normalizer;
    //     at.width = round(x + w + normalizer) - normalizer - at.x;
    //     at.height = round(y + h + normalizer) - normalizer - at.y;
    //     at['stroke-width'] = s;

    //     // adjust to single pixel if resultant dimension is zero.
    //     (at.width === 0 && w !== 0) && (at.width = 1);
    //     (at.height === 0 && h !== 0) && (at.height = 1);

    //     return at;
    // }, R);

    // elproto.crisp = function () {
    //     var o = this,
    //         attrs = o.attrs,
    //         key,
    //         attr = {},
    //         values = o.attr(['x', 'y', 'width', 'height', 'stroke-width']);

    //     values = R.crispBound(values.x, values.y, values.width, values.height,
    //         values['stroke-width']);

    //     for (key in values) {
    //         if (attrs[key] === values[key]) { // only set attribute if changed
    //             delete values[key];
    //         }
    //     }

    //     return o.attr(values);
    // };

    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/
    R.st = setproto;

    /*\
     * Raphael.define
     [ method ]
     **
     * Allows a unified definition of composite shapes and other behaviours using
     * simple directives.
     **
     > Parameters
     **
     - definition (object) the shape definition
    \*/
    R.define = function (name, init, ca, fn, e, data) {
        var i,
            ii;

        // multi definition
        if (R.is(name, array)) {
            for (i = 0, ii = name.length; i < ii; i++) {
                R.define(name[i]);
            }
            return;
        }
        // object definition
        else if (R.is(name, object)) {
            R.define(name.name, name[name.name], name.ca, name.fn, name.e, name.data);
            return;
        }
        // invalid or duplicate definition
        else if (!name || R.fn[name]) {
            return;
        }

        R.fn[name] = function () {
            var args = arguments,
                element = init.apply(this, args),
                key;

            if (fn && R.is(fn, object)) {
                for (key in fn) {
                    element[key] = fn[key];
                }
            }

            if (e && R.is(e, object)) {
                for (key in e) {
                    element[key] && element[key](e[key]);
                }
            }

            if (ca) {
                if (R.is(ca, 'function')) {
                    element.ca[name] = ca;
                }
                else {
                    for (key in ca) {
                        element.ca[key] = ca[key];
                    }
                }

                // Check if namesake ca exists and apply it
                if (element.ca[name]) {
                    R._lastArgIfGroup(args, true); // purge group
                    element.attr(name, arraySlice.call(args))
                }
            }

            return element;
        };

        if (ca) { R.fn[name].ca = ca; }
        if (fn) { R.fn[name].fn = fn; }
        if (e) { R.fn[name].e = e; }
        if (data) { R.fn[name].data = data; }

        return R.fn[name];
    };
    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function(doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener) {
            doc.addEventListener(loaded, f = function() {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    eve.on("raphael.DOMload", function() {
        loaded = true;
    });

/**!
* RedRaphael 1.0.0 - JavaScript Vector Library SVG Module
* Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
*
* Raphael 2.1.0 - JavaScript Vector Library SVG Module
* Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
* Copyright ¬© 2008-2012 Sencha Labs <http://sencha.com>
*
* Licensed under the MIT license.
*/
(function(){
    if (!R.svg) {
        return;
    }
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        sqrt = math.sqrt,
        separator = /[, ]+/,
        zeroStrokeFix = !!(/AppleWebKit/.test(R._g.win.navigator.userAgent) &&
                (!/Chrome/.test(R._g.win.navigator.userAgent) ||
                R._g.win.navigator.appVersion.match(/Chrome\/(\d+)\./)[1] < 29)),
        eve = R.eve,
        E = "",
        S = " ",
        xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {},
        updateReferenceUrl = function () {
            return R._url = R._g.win.location.href.replace(/#.*?$/, E);
        };

    R.toString = function() {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };

    // Code commented as resources will now be referenced using relative urls.
    // @todo Remove once we have acertained that there are no issues in any environment.
    // Automatic gradient and other reference update on state change
    // R._url = (/msie/i.test(navigator.userAgent) && !window.opera) ?
    //     E : updateReferenceUrl();
    // if (R._url && R._g.win.history.pushState) {
    //     R._g.win.history.pushState = (function () {
    //         var fn = R._g.win.history.pushState;
    //         return function () {
    //             var ret = fn.apply(R._g.win.history, arguments);
    //             return updateReferenceUrl(), ret;
    //         };
    //     }());
    //     R._g.win.addEventListener("popstate", updateReferenceUrl, false);
    // }
    R._url = E;

    var updateGradientReference = function (element, newGradient) {
        var gradient = element.gradient;

        if (gradient) {
            if (gradient === newGradient) {
                return; // no change
            }
            // else gradient is specified and it is not same as newGradient, implying a dereference
            gradient.refCount--;
            if (!gradient.refCount) {
                gradient.parentNode.removeChild(gradient);
            }
            delete element.gradient;
        }

        if (newGradient) { // add new gradient
            element.gradient = newGradient;
            newGradient.refCount++;
        }
    };

    var $ = R._createNode = function(el, attr) {
        if (attr) {
            if (typeof el == "string") {
                el = $(el);
            }
            for (var key in attr)
                if (attr[has](key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                    } else {
                        el.setAttribute(key, Str(attr[key]));
                    }
                }
        } else {
            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
        }
        return el;
    },
    gradientUnitNames = {
        userSpaceOnUse: 'userSpaceOnUse',
        objectBoundingBox: 'objectBoundingBox'
    },
    gradientSpreadNames = {
        pad: 'pad',
        redlect: 'reflect',
        repeat: 'repeat'
    },
    // addGradientFill = function(element, gradient) {
    //     if (!element.paper || !element.paper.defs) {
    //         return 0;
    //     }

    //     var type = "linear",
    //         SVG = element.paper,
    //         id = (SVG.id + '-' + gradient).replace(/[\(\)\s,\xb0#]/g, "_"),
    //         fx = .5, fy = .5, r, cx, cy, units, spread,
    //         o = element.node,
    //         s = o.style,
    //         el = R._g.doc.getElementById(id);

    //     if (!el) {
    //         gradient = Str(gradient).replace(R._radial_gradient, function(all, opts) {
    //             type = "radial";
    //             opts = opts && opts.split(',') || [];
    //             units = opts[5];
    //             spread = opts[6];

    //             var _fx = opts[0],
    //                 _fy = opts[1],
    //                 _r = opts[2],
    //                 _cx = opts[3],
    //                 _cy = opts[4],
    //                 shifted = (_fx && _fy),
    //                 dir,
    //                 sqx;

    //             if (_r) {
    //                 r = /\%/.test(_r) ? _r : toFloat(_r);
    //             }

    //             if (units === gradientUnitNames.userSpaceOnUse) {
    //                 if (shifted) {
    //                     fx = _fx;
    //                     fy = _fy;
    //                 }
    //                 if (_cx && _cy) {
    //                     cx = _cx;
    //                     cy = _cy;
    //                     if (!shifted) {
    //                         fx = cx;
    //                         fy = cy;
    //                     }
    //                 }
    //                 return E;
    //             }

    //             if (shifted) {
    //                 fx = toFloat(_fx);
    //                 fy = toFloat(_fy);
    //                 dir = ((fy > .5) * 2 - 1);
    //                 (sqx = pow(fx - .5, 2)) + pow(fy - .5, 2) > .25 &&
    //                 (sqx < .25) && (fy = sqrt(.25 - sqx) * dir + .5) &&
    //                 fy !== .5 &&
    //                 (fy = fy.toFixed(5) - 1e-5 * dir);
    //             }
    //             if (_cx && _cy) {
    //                 cx = toFloat(_cx);
    //                 cy = toFloat(_cy);
    //                 dir = ((cy > .5) * 2 - 1);

    //                 (sqx = pow(cx - .5, 2)) + pow(cy - .5, 2) > .25 &&
    //                 (sqx < .25) && (cy = sqrt(.25 - sqx) * dir + .5) &&
    //                 cy !== .5 &&
    //                 (cy = cy.toFixed(5) - 1e-5 * dir);

    //                 if (!shifted) {
    //                     fx = cx;
    //                     fy = cy;
    //                 }
    //             }

    //             return E;
    //         });
    //         gradient = gradient.split(/\s*\-\s*/);
    //         if (type == "linear") {
    //             var angle = gradient.shift(),
    //                 specs = angle.match(/\((.*)\)/),
    //                 vector,
    //                 max;

    //             specs = specs && specs[1] && specs[1].split(/\s*\,\s*/);
    //             angle = -toFloat(angle);
    //             if (isNaN(angle)) {
    //                 return null;
    //             }
    //             if (specs && specs.length) {
    //                 if (specs[0] in gradientUnitNames) {
    //                     units = specs.shift();
    //                     (specs[0] in gradientSpreadNames) &&
    //                         (spread = specs.shift());
    //                 }
    //                 else {
    //                     specs[4] && (units = specs[4]);
    //                     specs[5] && (spread = specs[5]);
    //                 }

    //                 /** @todo apply angle rotation and validation */
    //                 vector = [
    //                     specs[0] || "0%", specs[1] || "0%",
    //                     specs[2] || "100%", specs[3] || "0%"
    //                 ];
    //             }
    //             else {
    //                 vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))];
    //                 max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
    //                 vector[2] *= max;
    //                 vector[3] *= max;
    //                 if (vector[2] < 0) {
    //                     vector[0] = -vector[2];
    //                     vector[2] = 0;
    //                 }
    //                 if (vector[3] < 0) {
    //                     vector[1] = -vector[3];
    //                     vector[3] = 0;
    //                 }
    //             }
    //         }
    //         var dots = R._parseDots(gradient);
    //         if (!dots) {
    //             return null;
    //         }

    //         el = $(type + "Gradient", {
    //             id: id
    //         });
    //         el.refCount = 0;
    //         (units in gradientUnitNames) &&
    //                 el.setAttribute('gradientUnits', Str(units));
    //         (spread in gradientSpreadNames) &&
    //                 el.setAttribute('spreadMethod', Str(spread));
    //         if (type === "radial") {
    //             (r !== undefined) && el.setAttribute('r', Str(r));

    //             if (cx !== undefined && cy !== undefined) {
    //                 el.setAttribute('cx', Str(cx));
    //                 el.setAttribute('cy', Str(cy));
    //             }
    //             el.setAttribute('fx', Str(fx));
    //             el.setAttribute('fy', Str(fy));
    //         }
    //         else {
    //             $(el, {
    //                 x1: vector[0],
    //                 y1: vector[1],
    //                 x2: vector[2],
    //                 y2: vector[3]
    //             });
    //         }

    //         for (var i = 0, ii = dots.length; i < ii; i++) {
    //             el.appendChild($("stop", {
    //                 offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
    //                 "stop-color": dots[i].color || "#fff",
    //                 //add stop opacity information
    //                 "stop-opacity": dots[i].opacity === undefined ? 1 : dots[i].opacity
    //             }));
    //         }
    //         SVG.defs.appendChild(el);
    //     }

    //     updateGradientReference(element, el);

    //     $(o, {
    //         fill: "url('" + R._url + "#" + id + "')",
    //         opacity: 1,
    //         "fill-opacity": 1
    //     });
    //     s.fill = E;
    //     s.opacity = 1;
    //     s.fillOpacity = 1;
    //     return 1;
    // },
    updatePosition = function(o) {
        var bbox = o.getBBox(1);
        $(o.pattern, {
            patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"
        });
    },
    // addArrow = function(o, value, isEnd) {
    //     if (o.type == "path") {
    //         var values = Str(value).toLowerCase().split("-"),
    //         p = o.paper,
    //         se = isEnd ? "end" : "start",
    //         node = o.node,
    //         attrs = o.attrs,
    //         stroke = attrs["stroke-width"],
    //         i = values.length,
    //         type = "classic",
    //         from,
    //         to,
    //         dx,
    //         refX,
    //         attr,
    //         w = 3,
    //         h = 3,
    //         t = 5;
    //         while (i--) {
    //             switch (values[i]) {
    //                 case "block":
    //                 case "classic":
    //                 case "oval":
    //                 case "diamond":
    //                 case "open":
    //                 case "none":
    //                     type = values[i];
    //                     break;
    //                 case "wide":
    //                     h = 5;
    //                     break;
    //                 case "narrow":
    //                     h = 2;
    //                     break;
    //                 case "long":
    //                     w = 5;
    //                     break;
    //                 case "short":
    //                     w = 2;
    //                     break;
    //             }
    //         }
    //         if (type == "open") {
    //             w += 2;
    //             h += 2;
    //             t += 2;
    //             dx = 1;
    //             refX = isEnd ? 4 : 1;
    //             attr = {
    //                 fill: "none",
    //                 stroke: attrs.stroke
    //             };
    //         } else {
    //             refX = dx = w / 2;
    //             attr = {
    //                 fill: attrs.stroke,
    //                 stroke: "none"
    //             };
    //         }
    //         if (o._.arrows) {
    //             if (isEnd) {
    //                 o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
    //                 o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
    //             } else {
    //                 o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
    //                 o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
    //             }
    //         } else {
    //             o._.arrows = {};
    //         }
    //         if (type != "none") {
    //             var pathId = "raphael-marker-" + type,
    //             markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
    //             if (!R._g.doc.getElementById(pathId)) {
    //                 p.defs.appendChild($($("path"), {
    //                     "stroke-linecap": "round",
    //                     d: markers[type],
    //                     id: pathId
    //                 }));
    //                 markerCounter[pathId] = 1;
    //             } else {
    //                 markerCounter[pathId]++;
    //             }
    //             var marker = R._g.doc.getElementById(markerId),
    //             use;
    //             if (!marker) {
    //                 marker = $($("marker"), {
    //                     id: markerId,
    //                     markerHeight: h,
    //                     markerWidth: w,
    //                     orient: "auto",
    //                     refX: refX,
    //                     refY: h / 2
    //                 });
    //                 use = $($("use"), {
    //                     "xlink:href": "#" + pathId,
    //                     transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
    //                     "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
    //                 });
    //                 marker.appendChild(use);
    //                 p.defs.appendChild(marker);
    //                 markerCounter[markerId] = 1;
    //             } else {
    //                 markerCounter[markerId]++;
    //                 use = marker.getElementsByTagName("use")[0];
    //             }
    //             $(use, attr);
    //             var delta = dx * (type != "diamond" && type != "oval");
    //             if (isEnd) {
    //                 from = o._.arrows.startdx * stroke || 0;
    //                 to = R.getTotalLength(attrs.path) - delta * stroke;
    //             } else {
    //                 from = delta * stroke;
    //                 to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
    //             }
    //             attr = {};
    //             attr["marker-" + se] = "url('" + R._url + "#" + markerId + "')";
    //             if (to || from) {
    //                 attr.d = Raphael.getSubpath(attrs.path, from, to);
    //             }
    //             $(node, attr);
    //             o._.arrows[se + "Path"] = pathId;
    //             o._.arrows[se + "Marker"] = markerId;
    //             o._.arrows[se + "dx"] = delta;
    //             o._.arrows[se + "Type"] = type;
    //             o._.arrows[se + "String"] = value;
    //         } else {
    //             if (isEnd) {
    //                 from = o._.arrows.startdx * stroke || 0;
    //                 to = R.getTotalLength(attrs.path) - from;
    //             } else {
    //                 from = 0;
    //                 to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
    //             }
    //             o._.arrows[se + "Path"] && $(node, {
    //                 d: Raphael.getSubpath(attrs.path, from, to)
    //             });
    //             delete o._.arrows[se + "Path"];
    //             delete o._.arrows[se + "Marker"];
    //             delete o._.arrows[se + "dx"];
    //             delete o._.arrows[se + "Type"];
    //             delete o._.arrows[se + "String"];
    //         }
    //         for (attr in markerCounter)
    //             if (markerCounter[has](attr) && !markerCounter[attr]) {
    //                 var item = R._g.doc.getElementById(attr);
    //                 item && item.parentNode.removeChild(item);
    //             }
    //     }
    // },
    // dasharray = {
    //     "": [0],
    //     "none": [0],
    //     "-": [3, 1],
    //     ".": [1, 1],
    //     "-.": [3, 1, 1, 1],
    //     "-..": [3, 1, 1, 1, 1, 1],
    //     ". ": [1, 3],
    //     "- ": [4, 3],
    //     "--": [8, 3],
    //     "- .": [4, 3, 1, 3],
    //     "--.": [8, 3, 1, 3],
    //     "--..": [8, 3, 1, 3, 1, 3]
    // },
    // addDashes = function(o, value, params) {
    //     var predefValue = dasharray[Str(value).toLowerCase()];
    //     value = predefValue || ((value !== undefined) && [].concat(value));
    //     if (value) {
    //         var width = o.attrs["stroke-width"] || "1",
    //                 butt = {
    //                 round: width,
    //                 square: width,
    //                 butt: 0
    //             }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
    //                 i,
    //                 l = i = value.length;
    //         if (predefValue) {
    //             while (i--) {
    //                 value[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
    //             }
    //         }
    //         else {
    //             for (i = 0; i < l; i += 2) {
    //                 value[i] -= butt;
    //                 value[i + 1] && (value[i + 1] += butt);
    //                 if (value[i] <= 0) {
    //                     value[i] = 0.1;
    //                 }
    //             }
    //         }
    //         if (R.is(value, 'array')) {
    //             $(o.node, {
    //                 "stroke-dasharray": value.join(",")
    //             });
    //         }
    //     }
    // },

    applyCustomAttributes = function (o, attrs) {
        for (var key in o.ca) {
            if (attrs.hasOwnProperty(key)) {
                o.attr(key, attrs[key]);
            }
        }
    },

    setFillAndStroke = R._setFillAndStroke = function(o, params) {
        if (!o.paper.canvas) {
            return;
        }
        var node = o.node,
            attrs = o.attrs,
            paper = o.paper,
            s = node.style,
            vis = s.visibility;

        s.visibility = "hidden";
        for (var att in params) {
            if (params[has](att)) {
                if (!R._availableAttrs[has](att)) {
                    continue;
                }
                var value = params[att];
                attrs[att] = value;
                switch (att) {
                    case "blur":
                        o.blur(value);
                        break;
                    case "href":
                    case "title":
                    case "target":
                        var pn = node.parentNode;
                        if (pn.tagName.toLowerCase() != "a") {
                            if (value == E) { break; }
                            var hl = $("a");
                            hl.raphael = true;
                            hl.raphaelid = node.raphaelid;
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        if (att == "target") {
                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                        } else {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        node.titleNode = pn;
                        break;
                    case "cursor":
                        s.cursor = value;
                        break;
                    case "transform":
                        o.transform(value);
                        break;
                    case "rotation":
                        if (R.is(value, "array")) {
                            o.rotate.apply(o, value);
                        }
                        else {
                            o.rotate(value);
                        }
                        break;
                    case "arrow-start":
                        addArrow(o, value);
                        break;
                    case "arrow-end":
                        addArrow(o, value, 1);
                        break;
                    case "clip-path":
                        var pathClip = true;
                    case "clip-rect":
                        var rect = !pathClip && Str(value).split(separator);
                        o._.clipispath = !!pathClip;
                        if (pathClip || rect.length == 4) {
                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            var el = $("clipPath"),
                            rc = $(pathClip ? "path" : "rect");
                            el.id = R.createUUID();
                            $(rc, pathClip ? {
                                d: value ? attrs['clip-path'] = R._pathToAbsolute(value) : R._availableAttrs.path,
                                fill: 'none'
                            } : {
                                x: rect[0],
                                y: rect[1],
                                width: rect[2],
                                height: rect[3],
                                transform: o.matrix.invert()
                            });
                            el.appendChild(rc);
                            paper.defs.appendChild(el);
                            $(node, {
                                "clip-path": "url('" + R._url +"#" + el.id + "')"
                            });
                            o.clip = rc;
                        }
                        if (!value) {
                            var path = node.getAttribute("clip-path");
                            if (path) {
                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {
                                    "clip-path": E
                                });
                                delete o.clip;
                            }
                        }
                        break;
                    case "path":
                        if (o.type == "path") {
                            $(node, {
                                d: value ? attrs.path = R._pathToAbsolute(value) : R._availableAttrs.path
                            });
                            o._.dirty = 1;
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "width":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fx) {
                            att = "x";
                            value = attrs.x;
                        } else {
                            break;
                        }
                    case "x":
                        if (attrs.fx) {
                            value = -attrs.x - (attrs.width || 0);
                        }
                    case "rx":
                        if (att == "rx" && o.type == "rect") {
                            break;
                        }
                    case "cx":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "height":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fy) {
                            att = "y";
                            value = attrs.y;
                        } else {
                            break;
                        }
                    case "y":
                        if (attrs.fy) {
                            value = -attrs.y - (attrs.height || 0);
                        }
                    case "ry":
                        if (att == "ry" && o.type == "rect") {
                            break;
                        }
                    case "cy":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "r":
                        if (o.type == "rect") {
                            $(node, {
                                rx: value,
                                ry: value
                            });
                        } else {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = 1;
                        break;
                    case "src":
                        if (o.type == "image") {
                            node.setAttributeNS(xlink, "href", value);
                        }
                        break;
                    case "stroke-width":
                        if (o._.sx != 1 || o._.sy != 1) {
                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                        }
                        if (paper._vbSize) {
                            value *= paper._vbSize;
                        }
                        if (zeroStrokeFix && value === 0) {
                            value = 0.000001;
                        }
                        node.setAttribute(att, value);
                        if (attrs["stroke-dasharray"]) {
                            addDashes(o, attrs["stroke-dasharray"], params);
                        }
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "stroke-dasharray":
                        addDashes(o, value, params);
                        break;
                    case "fill":
                        var isURL = Str(value).match(R._ISURL);
                        if (isURL) {
                            el = $("pattern");
                            var ig = $("image");
                            el.id = R.createUUID();
                            $(el, {
                                x: 0,
                                y: 0,
                                patternUnits: "userSpaceOnUse",
                                height: 1,
                                width: 1
                            });
                            $(ig, {
                                x: 0,
                                y: 0,
                                "xlink:href": isURL[1]
                            });
                            el.appendChild(ig);

                            (function(el) {
                                R._preload(isURL[1], function() {
                                    var w = this.offsetWidth,
                                    h = this.offsetHeight;
                                    $(el, {
                                        width: w,
                                        height: h
                                    });
                                    $(ig, {
                                        width: w,
                                        height: h
                                    });
                                    paper.safari();
                                });
                            })(el);
                            paper.defs.appendChild(el);
                            $(node, {
                                fill: "url('" + R._url + "#" + el.id + "')"
                            });
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                            break;
                        }
                        var clr = R.getRGB(value);
                        if (!clr.error) {
                            delete params.gradient;
                            delete attrs.gradient;
                            !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {
                                    opacity: attrs.opacity
                                });
                            !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {
                                    "fill-opacity": attrs["fill-opacity"]
                                });
                                o.gradient && updateGradientReference(o);
                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {
                                        "stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)
                                    });
                                }
                            }
                            attrs.gradient = value;
                            attrs.fill = "none";
                            break;
                        }
                        if (clr[has]("opacity")) {
                            $(node, {
                                "fill-opacity": (s.fillOpacity =
                                        (clr.opacity > 1 ? clr.opacity / 100 : clr.opacity))
                            });
                            o._.opacitydirty = true;
                        }
                        else if (o._.opacitydirty && R.is(attrs['fill-opacity'], "undefined") &&
                                R.is(params["fill-opacity"], "undefined")) {
                            node.removeAttribute('fill-opacity');
                            s.fillOpacity = E;
                            delete o._.opacitydirty;
                        }
                    case "stroke":
                        clr = R.getRGB(value);
                        node.setAttribute(att, clr.hex);
                        att == "stroke" && clr[has]("opacity") && $(node, {
                            "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                        });
                        if (att == "stroke" && o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "gradient":
                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                        break;
                    case 'line-height': // do not apply
                    case 'vertical-align': // do not apply
                        break;
                    case "visibility":
                        value === 'hidden' ? o.hide() : o.show();
                        break;
                    case "opacity":
                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                            $(node, {
                                "stroke-opacity": value > 1 ? value / 100 : value
                            });
                        }
                    // fall
                    case "fill-opacity":
                        if (attrs.gradient) {
                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                stops = gradient.getElementsByTagName("stop");
                                $(stops[stops.length - 1], {
                                    "stop-opacity": value
                                });
                            }
                            break;
                        }
                    default:
                        att == "font-size" && (value = toInt(value, 10) + "px");
                        var cssrule = att.replace(/(\-.)/g, function(w) {
                            return w.substring(1).toUpperCase();
                        });
                        s[cssrule] = value;
                        o._.dirty = 1;
                        node.setAttribute(att, value);
                        break;
                }
            }
        }

        (o.type === 'text') && tuneText(o, params);
        s.visibility = vis;
    },
    leading = 1.2,
    tuneText = function(el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") ||
                params[has]("font-size") || params[has]("x") || params[has]("y") ||
                params[has]("line-height") || params[has]("vertical-align"))) {
            return;
        }
        var a = el.attrs,
            node = el.node,
            computedStyle = node.firstChild && R._g.doc.defaultView.getComputedStyle(node.firstChild, E),
            fontSize = computedStyle ?
                toFloat(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size")) : 10,
            lineHeight = toFloat(params['line-height'] || a['line-height']) || fontSize * leading,
            valign = a[has]("vertical-align") ? a["vertical-align"] : "middle";

        if (isNaN(lineHeight)) {
            lineHeight = fontSize * leading;
        }

        if (R.is(params.text, 'array')) {
            params.text = params.text.join('<br>');
        }

        valign = valign === 'top' ? -0.5 : (valign === 'bottom' ? 0.5 : 0);

        if (params[has]("text") && (params.text !== a.text || el._textdirty)) {
            a.text = params.text;
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var texts = Str(params.text).split(/\n|<br\s*?\/?>/ig),
            tspans = [],
            tspan;
            for (var i = 0, ii = texts.length; i < ii; i++) {
                tspan = $("tspan");
                if (i) {
                    $(tspan, {
                        dy: lineHeight,
                        x: a.x
                    });
                } else {
                    $(tspan, {
                        dy: lineHeight * texts.length * valign,
                        x: a.x
                    });
                }
                if (!texts[i]) { // preserve blank lines
                    tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace",
                        "xml:space","preserve");
                    texts[i] = " ";
                }
                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
            el._textdirty = false;
        } else {
            tspans = node.getElementsByTagName("tspan");
            for (i = 0, ii = tspans.length; i < ii; i++)
                if (i) {
                    $(tspans[i], {
                        dy: lineHeight,
                        x: a.x
                    });
                } else {
                    $(tspans[0], {
                        dy: lineHeight * tspans.length * valign,
                        x: a.x
                    });
                }
        }
        $(node, {
            x: a.x,
            y: a.y
        });
        el._.dirty = 1;
        var bb = el._getBBox(),
        dif = a.y - (bb.y + bb.height / 2);

        // If the bbox is calculated then we need to make additional adjustments,
        // to account for the fact that the calculated bbox already has the
        // text alignment, both horizontal and vertical, included in the calculation.
        if (bb.isCalculated) {
            switch (a['vertical-align']) {
                case "top":
                    dif = bb.height * .75;
                    break;
                case "bottom":
                    dif = - (bb.height * .25);
                    break;
                default:
                    dif = a.y - (bb.y + bb.height * .25);
                    break;
            };
        }

        dif && R.is(dif, "finite") && tspans[0] && $(tspans[0], {
            dy: dif
        });
    },
    Element = function(node, svg, group) {
        var o = this,
            parent = group || svg;

        parent.canvas && parent.canvas.appendChild(node);

        o.node = o[0] = node;
        node.raphael = true;
        node.raphaelid = o.id = R._oid++;

        o.matrix = R.matrix();
        o.realPath = null;

        o.attrs = o.attrs || {};
        o.followers = o.followers || [];

        o.paper = svg;
        o.ca = o.customAttributes = o.customAttributes ||
            new svg._CustomAttributes();

        o._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };

        o.parent = parent;
        !parent.bottom && (parent.bottom = o);

        o.prev = parent.top;
        parent.top && (parent.top.next = o);
        parent.top = o;
        o.next = null;
    },
    elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.getNode = function (el) {
        var node = el.node || el[0].node;
        return node.titleNode || node;
    };
    R._engine.getLastNode = function (el) {
        var node = el.node || el[el.length - 1].node;
        return node.titleNode || node;
    };

    elproto.rotate = function(deg, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        o.transform(o._.transform.concat([["r", deg, cx, cy]]));
        return o;
    };

    elproto.scale = function(sx, sy, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        o.transform(o._.transform.concat([["s", sx, sy, cx, cy]]));
        return o;
    };

    elproto.translate = function(dx, dy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        o.transform(o._.transform.concat([["t", dx, dy]]));
        return o;
    };

    elproto.transform = function(tstr) {
        var o = this,
            _ = o._,
            sw;

        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(o, tstr);

        o.clip && !_.clipispath && $(o.clip, {
            transform: o.matrix.invert()
        });
        o.pattern && updatePosition(o);
        o.node && $(o.node, {
            transform: o.matrix
        });

        if (_.sx != 1 || _.sy != 1) {
            sw = o.attrs[has]("stroke-width") ? o.attrs["stroke-width"] : 1;
            o.attr({
                "stroke-width": sw
            });
        }

        return o;
    };

    elproto.hide = function() {
        var o = this;
        !o.removed && o.paper.safari(o.node.style.display = "none");
        return o;
    };

    elproto.show = function() {
        var o = this;
        !o.removed && o.paper.safari(o.node.style.display = E);
        return o;
    };

    elproto.remove = function() {
        if (this.removed || !this.parent.canvas) {
            return;
        }

        var o = this,
            node = R._engine.getNode(o),
            paper = o.paper,
            defs = paper.defs,
            i;

        paper.__set__ && paper.__set__.exclude(o);
        eve.unbind("raphael.*.*." + o.id);

        if (o.gradient && defs) {
            updateGradientReference(o);
        }
        while (i = o.followers.pop()) {
            i.el.remove();
        }
        while (i = o.bottom) {
            i.remove();
        }

        if (o._drag) {
            o.undrag();
        }

        if (o.events)  {
            while (i = o.events.pop()) {
                i.unbind();
            }
        }

        o.parent.canvas.removeChild(node);
        o.removeData();
        delete paper._elementsById[o.id]; // remove from lookup hash
        R._tear(o, o.parent);

        for (i in o) {
            o[i] = typeof o[i] === "function" ? R._removedFactory(i) : null;
        }

        o.removed = true;
    };
    elproto._getBBox = function() {
        var o = this,
            node = o.node,
            bbox = {},
            a = o.attrs,
            align,
            hide;

        if (node.style.display === "none") {
            o.show();
            hide = true;
        }

        try {
            bbox = node.getBBox();

            if (o.type == "text") {
                // If bbox does not have x / y, which is possible in certain
                // environments, we mathematically calculate these values by
                // using x, y (adjusted using the values of text-anchor, and
                // vertical-align attributes), of the element along with the
                // width and height provided by the getBBox().
                if (bbox.x === undefined) {
                    bbox.isCalculated = true;
                    align = a['text-anchor'];
                    bbox.x = (a.x || 0) - (bbox.width * ((align === "start") ?
                        0 : (align === "middle") ? 0.5 : 1));
                }

                if (bbox.y === undefined) {
                    bbox.isCalculated = true;
                    align = a['vertical-align'];
                    bbox.y = (a.y || 0) - (bbox.height * ((align === "bottom") ?
                        1 : (align === "middle") ? 0.5 : 0));
                }
            }

        } catch (e) {
        // Firefox 3.0.x plays badly here
        } finally {
            bbox = bbox || {};
        }
        hide && o.hide();
        return bbox;
    };

    elproto.attr = function(name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs)
                if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            if (name == "visibility") {
                return this.node.style.display === "none" ? "hidden" : "visible";
            }
            var names = name.split(separator),
            out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.ca[name], "function")) {
                    out[name] = this.ca[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key], key);
        }
        var todel = {};
        for (key in this.ca) {
            if (this.ca[key] && params[has](key) && R.is(this.ca[key], "function") && !this.ca['_invoked' + key]) {

                this.ca['_invoked'+key] = true; // prevent recursion
                var par = this.ca[key].apply(this, [].concat(params[key]));
                delete this.ca['_invoked'+key];

                for (var subkey in par) {
                    if (par[has](subkey)) {
                         params[subkey] = par[subkey];
                    }
                }
                this.attrs[key] = params[key];
                if (par === false) {
                    todel[key] = params[key];
                    delete params[key];
                }
            }
        }

        setFillAndStroke(this, params);

        var follower;
        for (i = 0, ii = this.followers.length; i < ii; i++) {
            follower = this.followers[i];
            (follower.cb && !follower.cb.call(follower.el, params, this)) ||
                follower.el.attr(params);
        }

        for (subkey in todel) {
            params[subkey] = todel[subkey];
        }
        return this;
    };

    elproto.blur = function(size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
            blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {
                stdDeviation: +size || 1.5
            });
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {
                filter: "url('" + R._url + "#" + fltr.id + "')"
            });
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
    };

    elproto.on = function(eventType, handler) {
        if (this.removed) {
            return this;
        }

        var fn = handler;
        if (R.supportsTouch) {
            eventType = R._touchMap[eventType] ||
                (eventType === 'click' && 'touchstart') || eventType;
            fn = function(e) {
                e.preventDefault();
                handler();
            };
        }
        this.node['on'+ eventType] = fn;
        return this;
    };

    R._engine.path = function(svg, attrs, group) {
        var el = $("path"),
            res = new Element(el, svg, group);

        res.type = "path";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };

    R._engine.group = function(svg, id, group) {
        var el = $("g"),
            res = new Element(el, svg, group);

        res.type = "group";
        res.canvas = res.node;
        res.top = res.bottom = null;
        res._id = id || E;
        id && el.setAttribute('class', 'raphael-group-' + res.id + '-' + id);
        return res;
    };

    R._engine.circle = function(svg, attrs, group) {
        var el = $("circle"),
            res = new Element(el, svg, group);

        res.type = "circle";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.rect = function(svg, attrs, group) {
        var el = $("rect"),
            res = new Element(el, svg, group);

        res.type = "rect";
        attrs.rx = attrs.ry = attrs.r;
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.ellipse = function(svg, attrs, group) {
        var el = $("ellipse"),
            res = new Element(el, svg, group);

        res.type = "ellipse";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.image = function(svg, attrs, group) {
        var el = $("image"),
            src = attrs.src,
            res = new Element(el, svg, group);

        res.type = "image";
        el.setAttribute("preserveAspectRatio", "none");
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.text = function(svg, attrs, group) {
        var el = $("text"),
            res = new Element(el, svg, group);
        res.type = "text";
        res._textdirty = true;
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };

    R._engine.setSize = function(width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function() {
        var con = R._getContainer.apply(0, arguments),
        container = con && con.container,
        x = con.x,
        y = con.y,
        width = con.width,
        height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
        css = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);"+
            "-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;"+
            "-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;",
        isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        $(cnvs, {
            id: "raphael-paper-" + container.id
        });
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function() {
            });
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function(x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var size = mmax(w / this.width, h / this.height),
        top = this.top,
        aspectRatio = fit ? "meet" : "xMinYMin",
        vb,
        sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({
                "stroke-width": sw
            });
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };

    R.prototype.renderfix = function() {
        var cnvs = this.canvas,
        s = cnvs.style,
        pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
        top = - pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };

    R.prototype._desc = function (txt) {
        var desc = this.desc;

        if (!desc) {
            this.desc = desc = $("desc");
            this.canvas.appendChild(desc);
        }
        else {
            while (desc.firstChild) {
                desc.removeChild(desc.firstChild);
            }
        }
        desc.appendChild(R._g.doc.createTextNode(R.is(txt, "string") ? txt : ("Created with Red Rapha\xebl " +
            R.version)));
    };

    R.prototype.clear = function() {
        var c;
        eve("raphael.clear", this);

        while (c = this.bottom) {
            c.remove();
        }

        c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        c.appendChild(this.desc = $("desc"));
        c.appendChild(this.defs = $("defs"));
    };

    R.prototype.remove = function() {
        var i;
        eve("raphael.remove", this);

        while (i = this.bottom) {
            i.remove();
        }

        this.defs && this.defs.parentNode.removeChild(this.defs);
        this.desc && this.desc.parentNode.removeChild(this.desc);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    var setproto = R.st;
    for (var method in elproto)
        if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = (function(methodname) {
                return function() {
                    var arg = arguments;
                    return this.forEach(function(el) {
                        el[methodname].apply(el, arg);
                    });
                };
            })(method);
        }
})();



    // EXPOSE
    // SVG and VML are appended just before the EXPOSE line
    // Even with AMD, Raphael should be defined globally
    oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

    return R;
}));

define('core/globals',[
  'core/dbregistry',
  'core/hookmanager',
  'Raphael'], function(dbRegistry, HookManager) {
  var rf = {
    globals: {
      media: "md",
      dbRegistry: dbRegistry,
      builder: null
    },
    hooks: new HookManager ()
  };

  window.rf = rf;
});

define ('iecompat/polyfills',[], function () {
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement, fromIndex) {
      if ( this === undefined || this === null ) {
        throw new TypeError( '"this" is null or not defined' );
      }

      var length = this.length >>> 0; // Hack to convert object.length to a UInt32

      fromIndex = +fromIndex || 0;

      if (Math.abs(fromIndex) === Infinity) {
        fromIndex = 0;
      }

      if (fromIndex < 0) {
        fromIndex += length;
        if (fromIndex < 0) {
          fromIndex = 0;
        }
      }

      for (;fromIndex < length; fromIndex++) {
        if (this[fromIndex] === searchElement) {
          return fromIndex;
        }
      }

      return -1;
    };
  }
});
define ('iecompat/main',["iecompat/polyfills"], function () {

});
define('core/main',[
  'vendor/lodash',
  'core/dashboard',
  'helpers/standalonedashboard',
  'helpers/embeddeddashboard',
  'helpers/tabbeddashboard',
  'components/kpicomponent',
  'components/gaugecomponent',
  'components/tablecomponent',
  'components/chartcomponent',
  'components/formcomponent',
  'components/kpigroupcomponent',
  'components/kpitablecomponent',
  'utils/rfnotification',
  'utils/rfloggerstub',
  'utils/errorhandler',
  'core/globals',
  'iecompat/main'
], function (Lodash, Dashboard, StandaloneDashboard, EmbeddedDashboard, TabbedDashboard, KPIComponent, GaugeComponent, TableComponent, ChartComponent, FormComponent, KPIGroupComponent, KPITableComponent, RFNotification, RFLogger, ErrorHandler) {
  window.StandaloneDashboard = StandaloneDashboard;
  window.EmbeddedDashboard = EmbeddedDashboard;
  window.TabbedDashboard = TabbedDashboard;
  window.KPIComponent = KPIComponent;
  window.Dashboard = Dashboard;
  window.TableComponent = TableComponent;
  window.ChartComponent = ChartComponent;
  window.FormComponent = FormComponent;
  window.KPIGroupComponent = KPIGroupComponent;
  window.KPITableComponent = KPITableComponent;
  window.GaugeComponent = GaugeComponent;
  window.rf.StandaloneDashboard = StandaloneDashboard;
  window.rf.EmbeddedDashboard = EmbeddedDashboard;
  window.rf.TabbedDashboard = TabbedDashboard;

  window.rf.logger = RFLogger;

  ErrorHandler.init();

  // require('devtools/debug.main');
  window.rf._ = Lodash;

  // Shim for console for IE9
  
  window.console = window.console || {
    log: function() {},
    error: function() {}
  };

  return window.rf;
});


require(["core/main"]);
    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('core/main');
}));